"use strict";
const bouncer = (f,ini) => { let obj = ini; while (obj.tag) obj = f(obj); return obj.h0 };
const Lib_Types_errorMsg = ( _$$0 ) => (( (_$$0.tag) == (1) ? _$$0.h2 : _$$0.h1 ));
const Lib_Types_Lib_Common_HasFC$20Lib_Common_Error$2CgetFC = ( _$$0 ) => (( (_$$0.tag) == (1) ? _$$0.h0 : _$$0.h0 ));
const Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow = ( _$$0 ) => ((((((((((("") + (_$$0.h0)) + (":")) + (Prelude_showInt((_$$0.h1.h0) + (1)))) + (":")) + (Prelude_showInt((_$$0.h1.h1) + (1)))) + ("--")) + (Prelude_showInt((_$$0.h1.h2) + (1)))) + (":")) + (Prelude_showInt((_$$0.h1.h3) + (2)))) + (""));
const Prelude_showInt = (i) => String(i);
const Node_exitFailure = (_, msg) => {
  console.log(msg);
  process.exit(1);
};
const Prelude_MkIORes = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Prelude_MkUnit = 0;
const Prelude_primPutStrLn = (s) => (w) => {
  console.log(s)
  return Prelude_MkIORes(Prelude_MkUnit,w)
};
const Lib_Common_MkBounds = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Common_MkFC = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Common_emptyFC = Lib_Common_MkFC("", Lib_Common_MkBounds(0, 0, 0, 0));
const Lib_Common_E = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Prelude_Left = ( h2 ) => ({ tag: 0,  h0: null,  h1: null,  h2: h2 });
const Lib_Types_MkM = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Main_writeSource = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Compile_compile, ( docs ) => { const src = Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude__$3A$3A_("\"use strict\";", Prelude__$3A$3A_("const bouncer = (f,ini) => { let obj = ini; while (obj.tag) obj = f(obj); return obj.h0 };", Prelude_Nil())), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Prettier_noAlt(_$$5))), Prelude_Lin())), docs))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Node_writeFile(_$$0, src)), ( $$sc ) => (( ($$sc.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Node_exitFailure(null, $$sc.h2) ))); }));
const Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn = ( _$$1 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_(tc, _$$1)), eta)))));
const Prelude__$2C_ = ( h2, h3 ) => ({ tag: 0,  h0: null,  h1: null,  h2: h2,  h3: h3 });
const Prelude_Right = ( h2 ) => ({ tag: 1,  h0: null,  h1: null,  h2: h2 });
const Node_writeFile = (fn, content) => (w) => {
  let fs = require('fs')
  let result
  try {
    fs.writeFileSync(fn, content, 'utf8')
    result = Prelude_Right( Prelude_MkUnit)
  } catch (e) {
      result = Prelude_Left(e+"")
  }
  return Prelude_MkIORes(result, w)
};
const Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO = ( _$$1 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$1, ( result ) => (( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_(tc, result)), eta))), eta)))));
const Prelude_Prelude_Monad$20Prelude_IO$2Cbind = ( _$$2, _$$3, w ) => { const sc$$5 = _$$2(w); return _$$3(sc$$5.h1)(sc$$5.h2); };
const Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind = ( _$$2, _$$3 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$2.h1(tc), ( $$sc ) => (( ($$sc.tag) == (1) ? Lib_Types__runM(_$$3($$sc.h2.h3))($$sc.h2.h2) : ( eta ) => (Prelude_MkIORes(Prelude_Left($$sc.h2), eta)) )), eta)))));
const Lib_Types__runM = ( _$$1 ) => (_$$1.h1);
const Prelude_Lin = (  ) => ({ tag: 0,  h0: null });
const Lib_Prettier_noAlt = ( _$$0 ) => (bouncer(Lib_Prettier_REC_noAlt, { tag: 1,  h0: _$$0 }));
const Lib_Prettier_REC_noAlt = ( arg ) => { switch (arg.h0.tag) { case 5: return { tag: 1,  h0: arg.h0.h0 }; case 4: return { tag: 0,  h0: Lib_Prettier_Seq(Lib_Prettier_noAlt(arg.h0.h0), Lib_Prettier_noAlt(arg.h0.h1)) }; case 3: return { tag: 1,  h0: arg.h0.h1 }; case 2: return { tag: 0,  h0: Lib_Prettier_Text(arg.h0.h0) }; case 1: return { tag: 0,  h0: Lib_Prettier_Line }; case 0: return { tag: 0,  h0: Lib_Prettier_Empty }; } };
const Lib_Prettier_Empty = { tag: 0 };
const Lib_Prettier_Line = { tag: 1 };
const Lib_Prettier_Text = ( h0 ) => ({ tag: 2,  h0: h0 });
const Lib_Prettier_Seq = ( h0, h1 ) => ({ tag: 4,  h0: h0,  h1: h1 });
const Lib_Prettier_best = ( _$$0, _$$1, _$$2 ) => (Prelude_fromMaybe(Prelude_Nil(), Lib_Prettier_be(false, Prelude_Lin(), _$$0, _$$1, Prelude__$3A$3A_(Prelude__$2C_(0, _$$2), Prelude_Nil()))));
const Prelude_Nil = (  ) => ({ tag: 0,  h0: null });
const Prelude__$3A$3A_ = ( h1, h2 ) => ({ tag: 1,  h0: null,  h1: h1,  h2: h2 });
const Lib_Prettier_be = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (bouncer(Lib_Prettier_REC_be, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Lib_Prettier_REC_be = ( arg ) => { if ((arg.h4.tag) == (1)) { switch (arg.h4.h1.h3.tag) { case 5: return { tag: 0,  h0: Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(( eta ) => (Prelude__$3C$3E$3E_(arg.h1, eta)), Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_(Lib_Prettier_be(true, Prelude_Lin(), arg.h2, arg.h3, Prelude__$3A$3A_(Prelude__$2C_(arg.h4.h1.h2, arg.h4.h1.h3.h0), arg.h4.h2)), Lib_Prettier_be(arg.h0, Prelude_Lin(), arg.h2, arg.h3, Prelude__$3A$3A_(Prelude__$2C_(arg.h4.h1.h2, arg.h4.h1.h3.h1), arg.h4.h2)))) }; case 4: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: Prelude__$3A$3A_(Prelude__$2C_(arg.h4.h1.h2, arg.h4.h1.h3.h0), Prelude__$3A$3A_(Prelude__$2C_(arg.h4.h1.h2, arg.h4.h1.h3.h1), arg.h4.h2)) }; case 3: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: Prelude__$3A$3A_(Prelude__$2C_((arg.h4.h1.h2) + (arg.h4.h1.h3.h0), arg.h4.h1.h3.h1), arg.h4.h2) }; case 2: { const sc$$13 = (Prelude_not(arg.h0)) || (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h3) + (Prelude_slen(arg.h4.h1.h3.h0)), arg.h2), 0)); switch (sc$$13) { case true: return { tag: 1,  h0: arg.h0,  h1: Prelude__$3A$3C_(arg.h1, Lib_Prettier_TEXT(arg.h4.h1.h3.h0)),  h2: arg.h2,  h3: (arg.h3) + (Prelude_slen(arg.h4.h1.h3.h0)),  h4: arg.h4.h2 }; case false: return { tag: 0,  h0: Prelude_Nothing() }; } break; } case 1: return { tag: 1,  h0: false,  h1: Prelude__$3A$3C_(arg.h1, Lib_Prettier_LINE(arg.h4.h1.h2)),  h2: arg.h2,  h3: arg.h4.h1.h2,  h4: arg.h4.h2 }; case 0: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2 }; } } else { return { tag: 0,  h0: Prelude_Just(Prelude__$3C$3E$3E_(arg.h1, Prelude_Nil())) }; } };
const Prelude__$3C$3E$3E_ = ( _$$1, _$$2 ) => (bouncer(Prelude_REC__$3C$3E$3E_, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC__$3C$3E$3E_ = ( arg ) => (( (arg.h1.tag) == (1) ? { tag: 1,  h0: null,  h1: arg.h1.h1,  h2: Prelude__$3A$3A_(arg.h1.h2, arg.h2) } : { tag: 0,  h0: arg.h2 } ));
const Prelude_Just = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Lib_Prettier_LINE = ( h0 ) => ({ tag: 1,  h0: h0 });
const Prelude__$3A$3C_ = ( h1, h2 ) => ({ tag: 1,  h0: null,  h1: h1,  h2: h2 });
const Prelude_Nothing = (  ) => ({ tag: 1,  h0: null });
const Prelude_slen = s => s.length;
const Lib_Prettier_TEXT = ( h0 ) => ({ tag: 0,  h0: h0 });
const Prelude_EQ = 1;
const Prelude_LT = 0;
const Prelude_GT = 2;
const Prelude_jsCompare = (_, a, b) => a == b ? Prelude_EQ : a < b ? Prelude_LT : Prelude_GT;
const Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case 2: switch (_$$0) { case 2: return true; default: return false; } break; case 1: switch (_$$0) { case 1: return true; default: return false; } break; case 0: switch (_$$0) { case 0: return true; default: return false; } break; } };
const Prelude_not = ( _$$0 ) => { switch (_$$0) { case true: return false; case false: return true; } };
const Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_ = ( _$$1, _$$2 ) => (( (_$$1.tag) == (1) ? _$$2 : Prelude_Just(_$$1.h1) ));
const Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? Prelude_Nothing() : Prelude_Just(_$$2(_$$3.h1)) ));
const Prelude_fromMaybe = ( _$$1, _$$2 ) => (( (_$$2.tag) == (1) ? _$$1 : _$$2.h1 ));
const Lib_Prettier_layout = ( _$$0, _$$1 ) => (bouncer(Lib_Prettier_REC_layout, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Prettier_REC_layout = ( arg ) => (( (arg.h0.tag) == (1) ? ( (arg.h0.h1.tag) == (1) ? { tag: 1,  h0: arg.h0.h2,  h1: Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h1, "\n"), Prelude_replicate(Prelude_intToNat(arg.h0.h1.h0), " ")) } : { tag: 1,  h0: arg.h0.h2,  h1: Prelude__$3A$3C_(arg.h1, arg.h0.h1.h0) } ) : { tag: 0,  h0: Prelude_fastConcat(Prelude__$3C$3E$3E_(arg.h1, Prelude_Nil())) } ));
const Prelude_listToArray = 
(a, l) => {
  let rval = []
  while (l.tag !== 'Nil' && l.tag) {
    rval.push(l.h1)
    l = l.h2
  }
  return rval
}
;
const Prelude_fastConcat = (xs) => Prelude_listToArray(null, xs).join('');
const Prelude_intToNat = (n) => n>0?n:0;
const Prelude_natToInt = (n) => n;
const Prelude_replicate = (n,c) => c.repeat(Prelude_natToInt(n));
const Prelude_Prelude_Functor$20Prelude_List$2Cmap = ( _$$2, _$$3 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap_go(null, null, _$$2, _$$3, null, _$$2, _$$3, Prelude_Nil()));
const Prelude_Prelude_Functor$20Prelude_List$2Cmap_go = ( _, _1, _2, _3, _4, _$$7, _$$8, _$$9 ) => (bouncer(Prelude_REC_Prelude_Functor$20Prelude_List$2Cmap_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: null,  h6: null,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Prelude_REC_Prelude_Functor$20Prelude_List$2Cmap_go = ( arg ) => (( (arg.h8.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: null,  h6: null,  h7: arg.h7,  h8: arg.h8.h2,  h9: Prelude__$3A$3A_(arg.h7(arg.h8.h1), arg.h9) } : { tag: 0,  h0: Prelude_reverse()(arg.h9) } ));
const Prelude_reverse = (  ) => (( eta ) => (Prelude_reverse_go(null, null, Prelude_Nil(), eta)));
const Prelude_reverse_go = ( _, _1, _$$2, _$$3 ) => (bouncer(Prelude_REC_reverse_go, { tag: 1,  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_reverse_go = ( arg ) => (( (arg.h3.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: Prelude__$3A$3A_(arg.h3.h1, arg.h2),  h3: arg.h3.h2 } : { tag: 0,  h0: arg.h2 } ));
const Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_ = ( _$$1, _$$2 ) => (( (_$$1.tag) == (1) ? Prelude__$3A$3A_(_$$1.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(_$$1.h2, _$$2)) : _$$2 ));
const Prelude_joinBy = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_joinBy, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_joinBy = ( arg ) => (( (arg.h1.tag) == (1) ? ( (arg.h1.h2.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: Prelude__$3A$3A_((arg.h1.h1) + ((arg.h0) + (arg.h1.h2.h1)), arg.h1.h2.h2) } : { tag: 0,  h0: arg.h1.h1 } ) : { tag: 0,  h0: "" } ));
const Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow = ( _$$0 ) => (( (_$$0.h0.tag) == (0) ? _$$0.h1 : (Prelude_joinBy(".", _$$0.h0)) + ((".") + (_$$0.h1)) ));
const Lib_Compile_Var = ( h0 ) => ({ tag: 5,  h0: h0 });
const Lib_Compile_Apply = ( h0, h1 ) => ({ tag: 4,  h0: h0,  h1: h1 });
const Lib_Compile_JPlain = ( h0 ) => ({ tag: 1,  h0: h0 });
const Lib_Compile_stmtToDoc = ( _$$1 ) => { switch (_$$1.tag) { case 8: return Lib_Prettier_Seq(Lib_Prettier_Text("throw new Error("), Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_quoteString(_$$1.h1)), Lib_Prettier_Text(");"))); case 7: return Lib_Prettier_Seq(Lib_Prettier_Text("if ("), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h1), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Compile_stmtToDoc(_$$1.h2), "}"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("else"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Compile_stmtToDoc(_$$1.h3), "}"))))); case 6: return Lib_Prettier_Seq(Lib_Prettier_Text("switch ("), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h1), Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_altToDoc(eta)), _$$1.h2)), "}"))))); case 5: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Compile_jsIdent(_$$1.h0), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$1.h1))), Lib_Prettier_Text(";")); case 4: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_jsIdent(_$$1.h0))), Lib_Prettier_Text(";")), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(_$$1.h1))); case 3: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("return"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$1.h0))), Lib_Prettier_Text(";")); case 2: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("const"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_jsIdent(_$$1.h0))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("="), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h1), Lib_Prettier_Text(";"))))))); case 1: return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h0), Lib_Prettier_Text(";")); case 0: return Lib_Prettier_Seq(Lib_Compile_stmtToDoc(_$$1.h1), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(_$$1.h2))); } };
const Lib_Prettier_line = Lib_Prettier_Line;
const Lib_Compile_expToDoc = ( _$$0 ) => { switch (_$$0.tag) { case 12: return Lib_Prettier_Text(_$$0.h0); case 11: return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("."), Lib_Compile_jsIdent(_$$0.h1))); case 10: return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("["), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h1), Lib_Prettier_Text("]")))); case 9: return Lib_Prettier_bracket("(", Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("?"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$0.h2))), ")"); case 8: return Lib_Prettier_Text("null"); case 7: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Types_parens(0, 1, Lib_Compile_expToDoc(_$$0.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h0))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_parens(0, 1, Lib_Compile_expToDoc(_$$0.h2)))); case 6: return ( (_$$0.h1.tag) == (3) ? Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_jsIdent(eta)), _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(") =>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("("))), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h1.h0), Lib_Prettier_Text(")"))) : Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_jsIdent(eta)), _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(") =>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Compile_stmtToDoc(_$$0.h1), "}"))) ); case 5: return Lib_Compile_jsIdent(_$$0.h0); case 4: return ( (_$$0.h0.tag) == (6) ? Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_expToDoc(eta)), _$$0.h1))), Lib_Prettier_Text(")")))))) : Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_expToDoc(eta)), _$$0.h1))), Lib_Prettier_Text(")")))) ); case 3: return Lib_Prettier_Text(Prelude_showInt(_$$0.h0)); case 2: switch (_$$0.h0) { case true: return Lib_Prettier_Text("true"); case false: return Lib_Prettier_Text("false"); } break; case 1: return Lib_Prettier_Text(Lib_Common_quoteString(_$$0.h0)); case 0: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( e ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(", ")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), e)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_expToDoc_entry(_$$0, _$$0.h0, null, eta)), _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))); } };
const Lib_Compile_expToDoc_entry = ( _, _1, _2, _$$3 ) => (Lib_Prettier_Seq(Lib_Compile_jsIdent(_$$3.h2), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$3.h3)))));
const Lib_Compile_jsIdent = ( _$$0 ) => { const sc$$2 = Prelude_elem(Prelude_Prelude_Eq$20Prim_String, _$$0, Lib_Compile_jsKeywords); switch (sc$$2) { case true: return Lib_Prettier_Text(("$") + (_$$0)); case false: return Lib_Prettier_Text(Prelude_pack(Lib_Compile_jsIdent_fix(_$$0, null, Prelude_unpack(_$$0)))); } };
const Prelude_unpack = (s) => {
    let acc = Prelude_Nil()
    for (let i = s.length - 1; 0 <= i; i--) acc = Prelude__$3A$3A_(s[i], acc)
    return acc
};
const Lib_Compile_jsIdent_fix = ( _, _1, _$$2 ) => { if ((_$$2.tag) == (1)) { const sc$$6 = (Prelude_isAlphaNum(_$$2.h1)) || ((_$$2.h1) == ("_")); switch (sc$$6) { case true: return Prelude__$3A$3A_(_$$2.h1, Lib_Compile_jsIdent_fix(_, _1, _$$2.h2)); case false: { const sc$$7 = (_$$2.h1) == ("."); switch (sc$$7) { case true: return Prelude__$3A$3A_("_", Lib_Compile_jsIdent_fix(_, _1, _$$2.h2)); case false: { const sc$$8 = (_$$2.h1) == ("$"); switch (sc$$8) { case true: return Prelude__$3A$3A_("$", Prelude__$3A$3A_("$", Lib_Compile_jsIdent_fix(_, _1, _$$2.h2))); case false: return Prelude__$3A$3A_("$", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Lib_Common_toHex(Prelude_ord(_$$2.h1)), Lib_Compile_jsIdent_fix(_, _1, _$$2.h2))); } break; } } break; } } } else { return Prelude_Nil(); } };
const Prelude_ord = (c) => c.charCodeAt(0);
const Lib_Common_toHex = ( _$$0 ) => { switch (_$$0) { case 0: return Prelude_Nil(); default: return Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Lib_Common_toHex(((_$$0) / (16)) | (0)), Prelude__$3A$3A_(Prelude_fromMaybe(" ", Prelude_getAt(Prelude_intToNat(Prelude_mod(_$$0, 16)), Lib_Common_hexChars)), Prelude_Nil())); } };
const Lib_Common_hexChars = Prelude_unpack("0123456789ABCDEF");
const Prelude_mod = (a,b) => a % b;
const Prelude_getAt = ( _$$1, _$$2 ) => (bouncer(Prelude_REC_getAt, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_getAt = ( arg ) => { if ((arg.h2.tag) == (1)) { switch (arg.h1) { case 0: return { tag: 0,  h0: Prelude_Just(arg.h2.h1) }; default: { const x = (arg.h1) - (1); return { tag: 1,  h0: null,  h1: x,  h2: arg.h2.h2 }; break; } } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Prelude_isAlphaNum = ( _$$0 ) => { const o = Prelude_ord(_$$0); return ((Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 64, o), 0)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 91), 0))) || (((Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 47, o), 0)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 58), 0))) || ((Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 96, o), 0)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 123), 0)))); };
const Prelude_pack = (cs) => {
  let rval = ''
  while (cs.tag === '_::_' || cs.tag === 1) {
    rval += cs.h1
    cs = cs.h2
  }
  return rval
}
;
const Lib_Compile_jsKeywords = Prelude__$3A$3A_("break", Prelude__$3A$3A_("case", Prelude__$3A$3A_("catch", Prelude__$3A$3A_("continue", Prelude__$3A$3A_("debugger", Prelude__$3A$3A_("default", Prelude__$3A$3A_("delete", Prelude__$3A$3A_("do", Prelude__$3A$3A_("else", Prelude__$3A$3A_("finally", Prelude__$3A$3A_("for", Prelude__$3A$3A_("function", Prelude__$3A$3A_("if", Prelude__$3A$3A_("in", Prelude__$3A$3A_("instanceof", Prelude__$3A$3A_("new", Prelude__$3A$3A_("return", Prelude__$3A$3A_("switch", Prelude__$3A$3A_("this", Prelude__$3A$3A_("throw", Prelude__$3A$3A_("try", Prelude__$3A$3A_("typeof", Prelude__$3A$3A_("var", Prelude__$3A$3A_("void", Prelude__$3A$3A_("while", Prelude__$3A$3A_("with", Prelude__$3A$3A_("class", Prelude__$3A$3A_("const", Prelude__$3A$3A_("enum", Prelude__$3A$3A_("export", Prelude__$3A$3A_("extends", Prelude__$3A$3A_("import", Prelude__$3A$3A_("super", Prelude__$3A$3A_("implements", Prelude__$3A$3A_("class", Prelude__$3A$3A_("let", Prelude__$3A$3A_("package", Prelude__$3A$3A_("private", Prelude__$3A$3A_("protected", Prelude__$3A$3A_("public", Prelude__$3A$3A_("static", Prelude__$3A$3A_("yield", Prelude__$3A$3A_("null", Prelude__$3A$3A_("true", Prelude__$3A$3A_("false", Prelude__$3A$3A_("String", Prelude__$3A$3A_("Number", Prelude__$3A$3A_("Array", Prelude__$3A$3A_("BigInt", Prelude_Nil())))))))))))))))))))))))))))))))))))))))))))))))));
const Prelude_Prelude_Eq$20Prim_String$2C_$3D$3D_ = ( _$$0, _$$1 ) => ((_$$0) == (_$$1));
const Prelude_MkEq = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Prelude_Prelude_Eq$20Prim_String = Prelude_MkEq(( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_String$2C_$3D$3D_(eta, eta1))));
const Prelude_elem = ( _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_elem, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_elem = ( arg ) => { if ((arg.h3.tag) == (1)) { const sc$$7 = Prelude__$3D$3D_(arg.h1)(arg.h2)(arg.h3.h1); switch (sc$$7) { case true: return { tag: 0,  h0: true }; case false: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 }; } } else { return { tag: 0,  h0: false }; } };
const Prelude__$3D$3D_ = ( _$$1 ) => (_$$1.h1);
const Lib_Prettier_Alt = ( h0, h1 ) => ({ tag: 5,  h0: h0,  h1: h1 });
const Lib_Prettier_folddoc = ( _$$0, _$$1 ) => (( (_$$1.tag) == (1) ? ( (_$$1.h2.tag) == (0) ? _$$1.h1 : _$$0(_$$1.h1)(Lib_Prettier_folddoc(_$$0, _$$1.h2)) ) : Lib_Prettier_Empty ));
const Lib_Common_quoteString = ( _$$0 ) => (Prelude_pack(Lib_Common_quoteString_encode(_$$0, null, Prelude_unpack(_$$0), Prelude__$3A$3C_(Prelude_Lin(), "\""))));
const Lib_Common_quoteString_encode = ( _, _1, _$$2, _$$3 ) => (bouncer(Lib_Common_REC_quoteString_encode, { tag: 1,  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Lib_Common_REC_quoteString_encode = ( arg ) => { if ((arg.h2.tag) == (1)) { switch (arg.h2.h1) { case "\"": return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h3, "\\"), "\"") }; case "\n": return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h3, "\\"), "n") }; case "\\": return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h3, "\\"), "\\") }; default: { const v = Prelude_ord(arg.h2.h1); const sc$$8 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, v, 32), 0); switch (sc$$8) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(Prelude__$3A$3C_(Prelude__$3A$3C_(Prelude__$3A$3C_(Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h3, "\\"), "u"), Prelude_fromMaybe(" ", Prelude_getAt(Prelude_intToNat(Prelude_mod(((v) / (4096)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(" ", Prelude_getAt(Prelude_intToNat(Prelude_mod(((v) / (256)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(" ", Prelude_getAt(Prelude_intToNat(Prelude_mod(((v) / (16)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(" ", Prelude_getAt(Prelude_intToNat(Prelude_mod(v, 16)), Lib_Common_hexChars))) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(arg.h3, arg.h2.h1) }; } break; } } } else { return { tag: 0,  h0: Prelude__$3C$3E$3E_(arg.h3, Prelude__$3A$3A_("\"", Prelude_Nil())) }; } };
const Lib_Prettier_Nest = ( h0, h1 ) => ({ tag: 3,  h0: h0,  h1: h1 });
const Lib_Prettier_bracket = ( _$$0, _$$1, _$$2 ) => (Lib_Prettier_Alt(Lib_Prettier_flatten(Lib_Prettier_Seq(Lib_Prettier_Text(_$$0), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text(_$$2))))), Lib_Prettier_Seq(Lib_Prettier_Text(_$$0), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text(_$$2))))));
const Lib_Prettier_flatten = ( _$$0 ) => (bouncer(Lib_Prettier_REC_flatten, { tag: 1,  h0: _$$0 }));
const Lib_Prettier_REC_flatten = ( arg ) => { switch (arg.h0.tag) { case 5: return { tag: 1,  h0: arg.h0.h0 }; case 4: return { tag: 0,  h0: Lib_Prettier_Seq(Lib_Prettier_flatten(arg.h0.h0), Lib_Prettier_flatten(arg.h0.h1)) }; case 3: return { tag: 1,  h0: arg.h0.h1 }; case 2: return { tag: 0,  h0: Lib_Prettier_Text(arg.h0.h0) }; case 1: return { tag: 0,  h0: Lib_Prettier_Text(" ") }; case 0: return { tag: 0,  h0: Lib_Prettier_Empty }; } };
const Lib_Types_parens = ( _$$0, _$$1, _$$2 ) => { const sc$$3 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, _$$1), 0); switch (sc$$3) { case true: return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$2, Lib_Prettier_Text(")"))); case false: return _$$2; } };
const Lib_Compile_altToDoc = ( _$$0 ) => { switch (_$$0.tag) { case 2: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(_$$0.h2))); case 1: return Lib_Prettier_Seq(Lib_Prettier_Text("default"), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(_$$0.h1))); case 0: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(Prelude_showInt(Prelude_natToInt(_$$0.h1))))), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(_$$0.h2))); } };
const Lib_Compile_caseBody = ( _$$1 ) => { switch (_$$1.tag) { case 6: return Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(_$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("break;")))); case 3: return Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(_$$1))); default: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(_$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("break;")))))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("}"))); } };
const Lib_Prettier__$3C$2F$3E_ = ( _$$0, _$$1 ) => (Lib_Prettier_Seq(_$$0, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)));
const Lib_Compile_process = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Compile_getEntries(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), _$$0), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primNewIORef(null, entries)), ( ref ) => { const foo = Lib_Ref2_MkRef(ref); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Compile_eraseEntries(Lib_Ref2_MkRef(ref)), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhere(Lib_Ref2_MkRef(ref)), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, ref)), ( entries1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_mapM(Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (Lib_CompileExp_defToCExp(Lib_Ref2_MkRef(ref), eta)), Data_SortedMap_toList(entries1)), ( exprs ) => { const cexpMap = Data_SortedMap_foldMap(( _$$2 ) => (( _$$3 ) => (_$$2)), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), exprs); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TCO_tailCallOpt(cexpMap), ( cexpMap1 ) => { const names = Lib_Compile_sortedNames(cexpMap1, _$$0); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_cexpToDoc(eta)), Prelude_mapMaybe(( x ) => (Data_SortedMap_lookupMap(x, cexpMap1)), names))); }); }))))))); }))))));
const Data_SortedMap_lookupMap = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? Data_SortedMap_lookupT23(_$$3.h3, _$$2, _$$3.h4) : Prelude_Nothing() ));
const Data_SortedMap_lookupT23 = ( _$$3, _$$4, _$$5 ) => (bouncer(Data_SortedMap_REC_lookupT23, { tag: 1,  h0: null,  h1: null,  h2: null,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Data_SortedMap_REC_lookupT23 = ( arg ) => { switch (arg.h5.tag) { case 2: { const sc$$14 = arg.h3(arg.h4)(arg.h5.h4); switch (sc$$14) { case 2: { const sc$$15 = arg.h3(arg.h4)(arg.h5.h6); switch (sc$$15) { case 2: return { tag: 1,  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h7 }; default: return { tag: 1,  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h5 }; } break; } default: return { tag: 1,  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h3 }; } break; } case 1: { const sc$$12 = arg.h3(arg.h4)(arg.h5.h4); switch (sc$$12) { case 2: return { tag: 1,  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h5 }; default: return { tag: 1,  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h3 }; } break; } case 0: { const sc$$10 = arg.h3(arg.h5.h2)(arg.h4); switch (sc$$10) { case 1: return { tag: 0,  h0: Prelude_Just(Prelude__$2C_(arg.h5.h2, arg.h5.h3)) }; default: return { tag: 0,  h0: Prelude_Nothing() }; } break; } } };
const Prelude_mapMaybe = ( _$$2, _$$3 ) => (Prelude_mapMaybe_go(null, null, _$$2, _$$3, null, Prelude_Lin(), _$$3));
const Prelude_mapMaybe_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Prelude_REC_mapMaybe_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Prelude_REC_mapMaybe_go = ( arg ) => { if ((arg.h6.tag) == (1)) { const sc$$10 = arg.h2(arg.h6.h1); return ( (sc$$10.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h2 } : { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Prelude__$3A$3C_(arg.h5, sc$$10.h1),  h6: arg.h6.h2 } ); } else { return { tag: 0,  h0: Prelude__$3C$3E$3E_(arg.h5, Prelude_Nil()) }; } };
const Lib_Compile_cexpToDoc = ( _$$0 ) => { const exp = Lib_Compile_maybeWrap(Lib_Compile_termToJS(Lib_Compile_emptyJSEnv, _$$0.h3, ( eta ) => (Lib_Compile_JReturn(eta)))); return Lib_Compile_stmtToDoc(Lib_Compile_JConst(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h2), exp)); };
const Lib_Compile_JConst = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_Compile_JReturn = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_Compile_MkEnv = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Compile_emptyJSEnv = Lib_Compile_MkEnv(Prelude_Nil(), 0);
const Lib_Compile_termToJS = ( _$$1, _$$2, _$$3 ) => (bouncer(Lib_Compile_REC_termToJS, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Compile_REC_termToJS = ( arg ) => { if ((arg.tag) == (1)) { switch (arg.h2.tag) { case 14: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h1,  h3: ( t ) => (Lib_Compile_termToJS(arg.h1, arg.h2.h2, ( u ) => (arg.h3(Lib_Compile_JPrimOp(arg.h2.h0, t, u))))) }; case 13: return { tag: 0,  h0: arg.h3(Lib_Compile_Raw(arg.h2.h0)) }; case 12: return { tag: 2,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h2.h0,  h5: arg.h2.h1,  h6: arg.h2.h2,  h7: null,  h8: null,  h9: arg.h2.h2,  h10: 0,  h11: ( args ) => (arg.h3(Lib_Compile_LitObject(Prelude__$3A$3A_(Prelude__$2C_("tag", Lib_Compile_LitInt(Prelude_natToInt(arg.h2.h0))), args)))) }; case 11: return { tag: 0,  h0: arg.h3(Lib_Compile_JUndefined) }; case 10: { if ((arg.h2.h1.tag) == (11)) { return { tag: 1,  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_JUndefined, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 }; } else { const nm$27 = Lib_Compile_freshName(arg.h2.h0, arg.h1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), arg.h1.h0), arg.h1.h1); const sc$$9 = Lib_Compile_termToJS(env$27, arg.h2.h1, ( eta ) => (Lib_Compile_JAssign(nm$27, eta))); return ( (sc$$9.tag) == (5) ? { tag: 0,  h0: Lib_Compile_JSnoc(Lib_Compile_JConst(nm$27, sc$$9.h1), Lib_Compile_termToJS(env$27, arg.h2.h2, arg.h3)) } : { tag: 0,  h0: Lib_Compile_JSnoc(Lib_Compile_JLet(nm$27, sc$$9), Lib_Compile_termToJS(env$27, arg.h2.h2, arg.h3)) } ); } break; } case 9: { if ((arg.h2.h1.tag) == (0)) { const sc$$8 = Prelude_getAt(Prelude_intToNat(arg.h2.h1.h0), arg.h1.h0); return ( (sc$$8.tag) == (1) ? { tag: 0,  h0: Prelude_fatalError(null, "bad bounds") } : { tag: 1,  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(sc$$8.h1, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 } ); } else { const nm$27 = Lib_Compile_freshName(arg.h2.h0, arg.h1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), arg.h1.h0), arg.h1.h1); const sc$$9 = Lib_Compile_termToJS(arg.h1, arg.h2.h1, ( eta ) => (Lib_Compile_JAssign(nm$27, eta))); if ((sc$$9.tag) == (5)) { const sc$$12 = Lib_Compile_simpleJSExp(sc$$9.h1); switch (sc$$12) { case true: return { tag: 1,  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(sc$$9.h1, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 }; case false: return { tag: 0,  h0: Lib_Compile_JSnoc(Lib_Compile_JConst(nm$27, sc$$9.h1), Lib_Compile_termToJS(env$27, arg.h2.h2, arg.h3)) }; } } else { return { tag: 0,  h0: Lib_Compile_JSnoc(Lib_Compile_JLet(nm$27, sc$$9), Lib_Compile_termToJS(env$27, arg.h2.h2, arg.h3)) }; } } break; } case 8: return { tag: 0,  h0: arg.h3(Lib_Compile_litToJS(arg.h2.h0)) }; case 7: return { tag: 0,  h0: arg.h3(Lib_Compile_LitString((("META ") + (Prelude_showInt(arg.h2.h0))) + (""))) }; case 6: return { tag: 0,  h0: arg.h3(Lib_Compile_Var(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h2.h0))) }; case 5: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h0,  h3: ( $$case ) => { if (($$case.tag) == (5)) { return Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, null, null, arg.h1, Lib_Compile_Var($$case.h0), arg.h2.h1); } else { const nm = (("_sc$") + (Prelude_showInt(arg.h1.h1))) + (""); const env$27 = Lib_Compile_MkEnv(arg.h1.h0, (1) + (arg.h1.h1)); const sc$$14 = Lib_Compile_simpleJSExp($$case); switch (sc$$14) { case true: return Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, null, null, env$27, $$case, arg.h2.h1); case false: return Lib_Compile_JSnoc(Lib_Compile_JConst(nm, $$case), Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, null, null, env$27, Lib_Compile_Var(nm), arg.h2.h1)); } } } }; case 4: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h0,  h3: ( t$27 ) => (Lib_Compile_termToJS(arg.h1, arg.h2.h1, ( arg$27 ) => (arg.h3(Lib_Compile_Apply(t$27, Prelude__$3A$3A_(arg$27, Prelude_Nil())))))) }; case 3: return { tag: 1,  h0: null,  h1: arg.h1,  h2: Lib_CompileExp_CRef(arg.h2.h0),  h3: ( t$27 ) => (Lib_Compile_termToJS_etaExpand_apply_argsToJS(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, arg.h2.h2, null, null, null, arg.h1, t$27, arg.h2.h1, arg.h2.h2, Prelude_Lin(), arg.h3)) }; case 2: { const sc$$6 = Lib_Compile_freshNames(arg.h2.h0, arg.h1); return { tag: 0,  h0: arg.h3(Lib_Compile_JLam(sc$$6.h2, Lib_Compile_termToJS(sc$$6.h3, arg.h2.h1, ( eta ) => (Lib_Compile_JReturn(eta))))) }; break; } case 1: { const sc$$6 = Lib_Compile_freshName$27(arg.h2.h0, arg.h1); return { tag: 0,  h0: arg.h3(Lib_Compile_JLam(Prelude__$3A$3A_(sc$$6.h2, Prelude_Nil()), Lib_Compile_termToJS(sc$$6.h3, arg.h2.h1, ( eta ) => (Lib_Compile_JReturn(eta))))) }; break; } case 0: { const sc$$5 = Prelude_getAt(Prelude_intToNat(arg.h2.h0), arg.h1.h0); return ( (sc$$5.tag) == (1) ? { tag: 0,  h0: Prelude_fatalError(null, "Bad bounds") } : { tag: 0,  h0: arg.h3(sc$$5.h1) } ); break; } } } else { return ( (arg.h9.tag) == (1) ? { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h9.h1,  h3: ( t$27 ) => (Lib_Compile_termToJS_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h9.h2, (arg.h10) + (1), ( args ) => (arg.h11(Prelude__$3A$3A_(Prelude__$2C_((("h") + (Prelude_showInt(arg.h10))) + (""), t$27), args))))) } : { tag: 0,  h0: arg.h11(Prelude_Nil()) } ); } };
const Lib_Compile_termToJS_go = ( _, _1, _2, _3, _4, _5, _6, _7, _$$9, _$$10, _$$11 ) => (bouncer(Lib_Compile_REC_termToJS, { tag: 2,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: null,  h9: _$$9,  h10: _$$10,  h11: _$$11 }));
const Prelude_fatalError = (_, msg) => { throw new Error(msg) };
const Lib_Compile_JLam = ( h0, h1 ) => ({ tag: 6,  h0: h0,  h1: h1 });
const Lib_Compile_freshName$27 = ( _$$0, _$$1 ) => { const nm$27 = Lib_Compile_freshName(_$$0, _$$1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), _$$1.h0), _$$1.h1); return Prelude__$2C_(nm$27, env$27); };
const Lib_Compile_freshName = ( _$$0, _$$1 ) => { const sc$$4 = Lib_Compile_freshName_free(_$$0, _$$1, null, _$$1.h0, _$$0); switch (sc$$4) { case true: return _$$0; case false: return Lib_Compile_freshName_free_go(_$$0, _$$1, null, null, _$$0, 1); } };
const Lib_Compile_freshName_free_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Lib_Compile_REC_freshName_free_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Lib_Compile_REC_freshName_free_go = ( arg ) => { const nm$27 = (((("") + (arg.h4)) + ("")) + (Prelude_showInt(arg.h5))) + (""); const sc$$7 = Lib_Compile_freshName_free(arg.h0, arg.h1, arg.h2, arg.h1.h0, nm$27); switch (sc$$7) { case true: return { tag: 0,  h0: nm$27 }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (1) + (arg.h5) }; } };
const Lib_Compile_freshName_free = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Compile_REC_freshName_free, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Compile_REC_freshName_free = ( arg ) => { if ((arg.h3.tag) == (1)) { if ((arg.h3.h1.tag) == (5)) { const sc$$9 = (arg.h3.h1.h0) == (arg.h4); switch (sc$$9) { case true: return { tag: 0,  h0: false }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: arg.h4 }; } } else { return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: arg.h4 }; } } else { return { tag: 0,  h0: true }; } };
const Lib_Compile_freshNames = ( _$$0, _$$1 ) => (Lib_Compile_freshNames_go(_$$0, _$$1, null, _$$0, _$$1, Prelude_Lin()));
const Lib_Compile_freshNames_go = ( _, _1, _2, _$$3, _$$4, _$$5 ) => (bouncer(Lib_Compile_REC_freshNames_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Lib_Compile_REC_freshNames_go = ( arg ) => { if ((arg.h3.tag) == (1)) { switch (arg.h3.h1.h2) { case true: { const sc$$13 = Lib_Compile_freshName$27(arg.h3.h1.h3, arg.h4); return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: sc$$13.h3,  h5: Prelude__$3A$3C_(arg.h5, sc$$13.h2) }; break; } case false: { const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_JUndefined, arg.h4.h0), arg.h4.h1); return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: env$27,  h5: arg.h5 }; break; } } } else { return { tag: 0,  h0: Prelude__$2C_(Prelude__$3C$3E$3E_(arg.h5, Prelude_Nil()), arg.h4) }; } };
const Lib_Compile_JUndefined = { tag: 8 };
const Lib_Compile_termToJS_etaExpand_apply_argsToJS = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$11, _$$12, _$$13, _$$14, _$$15, _$$16 ) => (bouncer(Lib_Compile_REC_termToJS_etaExpand_apply_argsToJS, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: _9,  h10: null,  h11: _$$11,  h12: _$$12,  h13: _$$13,  h14: _$$14,  h15: _$$15,  h16: _$$16 }));
const Lib_Compile_REC_termToJS_etaExpand_apply_argsToJS = ( arg ) => { if ((arg.h13.tag) == (1)) { if ((arg.h14.tag) == (1)) { switch (arg.h14.h1) { case true: return { tag: 0,  h0: Lib_Compile_termToJS(arg.h11, arg.h13.h1, ( x$27 ) => (Lib_Compile_termToJS_etaExpand_apply_argsToJS(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, Lib_Compile_MkEnv(arg.h11.h0, (1) + (arg.h11.h1)), arg.h12, arg.h13.h2, arg.h14.h2, Prelude__$3A$3C_(arg.h15, x$27), arg.h16))) }; default: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: null,  h11: Lib_Compile_MkEnv(arg.h11.h0, (1) + (arg.h11.h1)),  h12: arg.h12,  h13: arg.h13.h2,  h14: arg.h14.h2,  h15: arg.h15,  h16: arg.h16 }; } } else { return ( (arg.h6.tag) == (0) ? { tag: 0,  h0: Lib_Compile_termToJS_etaExpand_apply(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h11, arg.h12, Prelude__$3A$3A_(arg.h13.h1, arg.h13.h2), arg.h16) } : { tag: 0,  h0: Lib_Compile_termToJS_etaExpand_apply(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h11, Lib_Compile_Apply(arg.h12, Prelude__$3C$3E$3E_(arg.h15, Prelude_Nil())), Prelude__$3A$3A_(arg.h13.h1, arg.h13.h2), arg.h16) } ); } } else { return { tag: 0,  h0: arg.h16(Lib_Compile_termToJS_etaExpand(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h11, arg.h14, arg.h15, arg.h12)) }; } };
const Lib_Compile_termToJS_etaExpand = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11 ) => { if ((_$$9.tag) == (1)) { const nm$27 = Lib_Compile_freshName("eta", _$$8); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), _$$8.h0), _$$8.h1); switch (_$$9.h1) { case true: return Lib_Compile_JLam(Prelude__$3A$3A_(nm$27, Prelude_Nil()), Lib_Compile_JReturn(Lib_Compile_termToJS_etaExpand(_, _1, _2, _3, _4, _5, _6, _7, Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), _$$8.h0), _$$8.h1), _$$9.h2, Prelude__$3A$3C_(_$$10, Lib_Compile_Var(nm$27)), _$$11))); default: return Lib_Compile_JLam(Prelude__$3A$3A_(nm$27, Prelude_Nil()), Lib_Compile_JReturn(Lib_Compile_termToJS_etaExpand(_, _1, _2, _3, _4, _5, _6, _7, Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Var(nm$27), _$$8.h0), _$$8.h1), _$$9.h2, _$$10, _$$11))); } } else { return Lib_Compile_Apply(_$$11, Prelude__$3C$3E$3E_(_$$10, Prelude_Nil())); } };
const Lib_Compile_termToJS_etaExpand_apply = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11, _$$12, _$$13 ) => (( (_$$12.tag) == (1) ? Lib_Compile_termToJS(_$$10, _$$12.h1, ( x$27 ) => (Lib_Compile_termToJS_etaExpand_apply(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, Lib_Compile_Apply(_$$11, Prelude__$3A$3A_(x$27, Prelude_Nil())), _$$12.h2, _$$13))) : _$$13(_$$11) ));
const Lib_CompileExp_CRef = ( h0 ) => ({ tag: 6,  h0: h0 });
const Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs_maybeCaseStmt = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11, _$$12 ) => { if ((_$$12.tag) == (1)) { switch (_$$12.h1.tag) { case 2: return Lib_Compile_JCase(_$$11, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); case 0: { if ((_$$12.h2.tag) == (0)) { return Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, _$$12.h1.h3), _$$12.h1.h4, _3); } else { if ((_$$12.tag) == (1)) { switch (_$$12.h1.tag) { case 2: { if ((_$$12.h1.h0.tag) == (3)) { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const t$27 = Lib_Compile_termToJS(_$$10, _$$12.h1.h1, _3); const e$27 = Lib_Compile_termToJS(_$$10, Lib_CompileExp_getBody(_$$12.h2.h1), _3); switch (_$$12.h1.h0.h0) { case true: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, t$27, e$27, _3); case false: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, e$27, t$27, _3); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } case 0: { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const cond = Lib_Compile_JPrimOp("==", Lib_Compile_Dot(_$$11, "tag"), Lib_Compile_LitInt(Prelude_natToInt(_$$12.h1.h0))); const t$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, _$$12.h1.h3), _$$12.h1.h4, _3); const u$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$12.h2.h1)), Lib_CompileExp_getBody(_$$12.h2.h1), _3); return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, cond, t$27, u$27, _3); } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } default: return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } break; } default: { if ((_$$12.tag) == (1)) { switch (_$$12.h1.tag) { case 2: { if ((_$$12.h1.h0.tag) == (3)) { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const t$27 = Lib_Compile_termToJS(_$$10, _$$12.h1.h1, _3); const e$27 = Lib_Compile_termToJS(_$$10, Lib_CompileExp_getBody(_$$12.h2.h1), _3); switch (_$$12.h1.h0.h0) { case true: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, t$27, e$27, _3); case false: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, e$27, t$27, _3); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } case 0: { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const cond = Lib_Compile_JPrimOp("==", Lib_Compile_Dot(_$$11, "tag"), Lib_Compile_LitInt(Prelude_natToInt(_$$12.h1.h0))); const t$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, _$$12.h1.h3), _$$12.h1.h4, _3); const u$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$12.h2.h1)), Lib_CompileExp_getBody(_$$12.h2.h1), _3); return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, cond, t$27, u$27, _3); } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } default: return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } } } else { if ((_$$12.tag) == (1)) { switch (_$$12.h1.tag) { case 2: { if ((_$$12.h1.h0.tag) == (3)) { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const t$27 = Lib_Compile_termToJS(_$$10, _$$12.h1.h1, _3); const e$27 = Lib_Compile_termToJS(_$$10, Lib_CompileExp_getBody(_$$12.h2.h1), _3); switch (_$$12.h1.h0.h0) { case true: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, t$27, e$27, _3); case false: return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, _$$11, e$27, t$27, _3); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } case 0: { if ((_$$12.h2.tag) == (1)) { if ((_$$12.h2.h2.tag) == (0)) { const cond = Lib_Compile_JPrimOp("==", Lib_Compile_Dot(_$$11, "tag"), Lib_Compile_LitInt(Prelude_natToInt(_$$12.h1.h0))); const t$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, _$$12.h1.h3), _$$12.h1.h4, _3); const u$27 = Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$11, 0, _$$10, Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$12.h2.h1)), Lib_CompileExp_getBody(_$$12.h2.h1), _3); return Lib_Compile_termToJS_tertiary(_, _1, _2, _3, _4, _5, _6, cond, t$27, u$27, _3); } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } break; } default: return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } else { return Lib_Compile_JCase(Lib_Compile_Dot(_$$11, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_termToJS_tertiary_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, eta)), _$$12)); } } };
const Lib_Compile_termToJS_tertiary_termToJSAlt = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10 ) => { switch (_$$10.tag) { case 2: return Lib_Compile_JLitAlt(Lib_Compile_litToJS(_$$10.h0), Lib_Compile_termToJS(_$$8, _$$10.h1, _3)); case 1: return Lib_Compile_JDefAlt(Lib_Compile_termToJS(_$$8, _$$10.h0, _3)); case 0: return Lib_Compile_JConAlt(_$$10.h0, Lib_Compile_termToJS(Lib_Compile_conAltEnv(_$$9, 0, _$$8, _$$10.h3), _$$10.h4, _3)); } };
const Lib_Compile_conAltEnv = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Compile_REC_conAltEnv, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Compile_REC_conAltEnv = ( arg ) => (( (arg.h3.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: (1) + (arg.h1),  h2: Lib_Compile_MkEnv(Prelude__$3A$3A_(Lib_Compile_Dot(arg.h0, (("h") + (Prelude_showInt(arg.h1))) + ("")), arg.h2.h0), arg.h2.h1),  h3: arg.h3.h2 } : { tag: 0,  h0: arg.h2 } ));
const Lib_Compile_Dot = ( h0, h1 ) => ({ tag: 11,  h0: h0,  h1: h1 });
const Lib_Compile_JConAlt = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Lib_Compile_JDefAlt = ( h1 ) => ({ tag: 1,  h0: null,  h1: h1 });
const Lib_Compile_litToJS = ( _$$0 ) => { switch (_$$0.tag) { case 3: return Lib_Compile_LitBool(_$$0.h0); case 2: return Lib_Compile_LitString(Prelude_pack(Prelude__$3A$3A_(_$$0.h0, Prelude_Nil()))); case 1: return Lib_Compile_LitInt(_$$0.h0); case 0: return Lib_Compile_LitString(_$$0.h0); } };
const Lib_Compile_LitString = ( h0 ) => ({ tag: 1,  h0: h0 });
const Lib_Compile_LitInt = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_Compile_LitBool = ( h0 ) => ({ tag: 2,  h0: h0 });
const Lib_Compile_JLitAlt = ( h1, h2 ) => ({ tag: 2,  h0: null,  h1: h1,  h2: h2 });
const Lib_Compile_JCase = ( h1, h2 ) => ({ tag: 6,  h0: null,  h1: h1,  h2: h2 });
const Lib_Compile_termToJS_tertiary = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9, _$$10 ) => { switch (_$$9.tag) { case 5: return ( (_$$8.tag) == (5) ? Lib_Compile_JAssign(_$$8.h0, Lib_Compile_JTernary(_$$7, _$$8.h1, _$$9.h1)) : Lib_Compile_JIfThen(_$$7, _$$8, _$$9) ); case 3: return ( (_$$8.tag) == (3) ? Lib_Compile_JReturn(Lib_Compile_JTernary(_$$7, _$$8.h0, _$$9.h0)) : Lib_Compile_JIfThen(_$$7, _$$8, _$$9) ); default: return Lib_Compile_JIfThen(_$$7, _$$8, _$$9); } };
const Lib_Compile_JIfThen = ( h1, h2, h3 ) => ({ tag: 7,  h0: null,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Compile_JTernary = ( h0, h1, h2 ) => ({ tag: 9,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_JAssign = ( h0, h1 ) => ({ tag: 5,  h0: h0,  h1: h1 });
const Lib_CompileExp_getBody = ( _$$0 ) => { switch (_$$0.tag) { case 2: return _$$0.h1; case 1: return _$$0.h0; case 0: return _$$0.h4; } };
const Lib_Compile_termToJS_tertiary_termToJSAlt_getArgs = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9 ) => { switch (_$$9.tag) { case 2: return Prelude_Nil(); case 1: return Prelude_Nil(); case 0: return _$$9.h3; } };
const Lib_Compile_JPrimOp = ( h0, h1, h2 ) => ({ tag: 7,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_JSnoc = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Lib_Compile_simpleJSExp = ( _$$0 ) => (bouncer(Lib_Compile_REC_simpleJSExp, { tag: 1,  h0: _$$0 }));
const Lib_Compile_REC_simpleJSExp = ( arg ) => { switch (arg.h0.tag) { case 11: return { tag: 1,  h0: arg.h0.h0 }; case 10: { const sc$$3 = Lib_Compile_simpleJSExp(arg.h0.h0); switch (sc$$3) { case true: return { tag: 1,  h0: arg.h0.h1 }; case false: return { tag: 0,  h0: false }; } break; } case 8: return { tag: 0,  h0: true }; case 5: return { tag: 0,  h0: true }; case 3: return { tag: 0,  h0: true }; case 2: return { tag: 0,  h0: true }; case 1: return { tag: 0,  h0: true }; default: return { tag: 0,  h0: false }; } };
const Lib_Compile_JLet = ( h0, h1 ) => ({ tag: 4,  h0: h0,  h1: h1 });
const Lib_Compile_LitObject = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_Compile_Raw = ( h0 ) => ({ tag: 12,  h0: h0 });
const Lib_Compile_maybeWrap = ( _$$0 ) => (( (_$$0.tag) == (3) ? _$$0.h0 : Lib_Compile_Apply(Lib_Compile_JLam(Prelude_Nil(), _$$0), Prelude_Nil()) ));
const Lib_Compile_sortedNames = ( _$$0, _$$1 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h3), Prelude_filter(( _$$5 ) => (Prelude_not(_$$5.h2)), Lib_Compile_sortedNames_getBody_getNames_go(_$$0, _$$1, null, null, null, Prelude_Nil(), Prelude_Nil(), Prelude__$2C_(true, _$$1)))));
const Lib_Compile_sortedNames_getBody_getNames_go = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => { let acc; const sc$$12 = (_$$7.h2) && ((Prelude_not(Prelude_elem(Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), Prelude__$2C_(false, _$$7.h3), _$$6))) && (Prelude_not(Prelude_elem(Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), Prelude__$2C_(false, _$$7.h3), _$$5)))); switch (sc$$12) { case true: { acc = Lib_Compile_sortedNames_getBody_getNames_go(_, _1, _2, _3, _4, _$$5, _$$6, Prelude__$2C_(false, _$$7.h3)); break; } case false: { acc = _$$6; break; } } const sc$$13 = Prelude_elem(Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), _$$7, _$$5); switch (sc$$13) { case true: return acc; case false: { const sc$$14 = Prelude_elem(Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), _$$7, acc); switch (sc$$14) { case true: return acc; case false: { const sc$$15 = Data_SortedMap_lookupMap$27(_$$7.h3, _); return ( (sc$$15.tag) == (1) ? acc : Prelude__$3A$3A_(_$$7, Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames_go(_, _1, _2, _3, _4, Prelude__$3A$3A_(_$$7, _$$5), eta, eta1))), acc, Lib_Compile_sortedNames_getBody_getNames(_, _1, _2, _3, _$$7.h2, Prelude_Nil(), sc$$15.h1))) ); break; } } break; } } };
const Lib_Compile_sortedNames_getBody_getNames = ( _, _1, _2, _3, deep$$4, _$$5, _$$6 ) => (bouncer(Lib_Compile_REC_sortedNames_getBody_getNames, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: deep$$4,  h5: _$$5,  h6: _$$6 }));
const Lib_Compile_REC_sortedNames_getBody_getNames = ( arg ) => { switch (arg.h6.tag) { case 14: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case 13: return { tag: 0,  h0: Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude__$2C_(arg.h4, eta)), arg.h6.h1), arg.h5) }; case 12: return { tag: 0,  h0: Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), arg.h5, arg.h6.h2) }; case 11: return { tag: 0,  h0: arg.h5 }; case 10: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case 9: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case 8: return { tag: 0,  h0: arg.h5 }; case 7: return { tag: 0,  h0: arg.h5 }; case 6: return { tag: 0,  h0: Prelude__$3A$3A_(Prelude__$2C_(arg.h4, arg.h6.h0), arg.h5) }; case 5: return { tag: 0,  h0: Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), arg.h5, Prelude__$3A$3A_(arg.h6.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Compile_sortedNames_getBody(arg.h0, arg.h1, arg.h2, eta)), arg.h6.h1))) }; case 4: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: true,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h0 }; case 3: { const sc$$10 = (Prelude_length$27(arg.h6.h1)) == (Prelude_length$27(arg.h6.h2)); switch (sc$$10) { case true: return ( (arg.h6.h1.tag) == (0) ? { tag: 0,  h0: Prelude__$3A$3A_(Prelude__$2C_(true, arg.h6.h0), arg.h5) } : { tag: 0,  h0: Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, true, eta, eta1))), Prelude__$3A$3A_(Prelude__$2C_(true, arg.h6.h0), arg.h5), arg.h6.h1) } ); case false: return { tag: 0,  h0: Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), Prelude__$3A$3A_(Prelude__$2C_(arg.h4, arg.h6.h0), arg.h5), arg.h6.h1) }; } break; } case 2: switch (arg.h4) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; case false: return { tag: 0,  h0: arg.h5 }; } break; case 1: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; case 0: return { tag: 0,  h0: arg.h5 }; } };
const Prelude_foldl = ( _$$2, _$$3, _$$4 ) => (bouncer(Prelude_REC_foldl, { tag: 1,  h0: null,  h1: null,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Prelude_REC_foldl = ( arg ) => (( (arg.h4.tag) == (1) ? { tag: 1,  h0: null,  h1: null,  h2: arg.h2,  h3: arg.h2(arg.h3)(arg.h4.h1),  h4: arg.h4.h2 } : { tag: 0,  h0: arg.h3 } ));
const Prelude_length$27 = ( _$$1 ) => (Prelude_length$27_go(null, _$$1, null, _$$1, 0));
const Prelude_length$27_go = ( _, _1, _2, _$$4, _$$5 ) => (bouncer(Prelude_REC_length$27_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: null,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_length$27_go = ( arg ) => (( (arg.h4.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: null,  h4: arg.h4.h2,  h5: (arg.h5) + (1) } : { tag: 0,  h0: arg.h5 } ));
const Lib_Compile_sortedNames_getBody = ( _, _1, _2, _$$3 ) => { switch (_$$3.tag) { case 2: return _$$3.h1; case 1: return _$$3.h0; case 0: return _$$3.h4; } };
const Data_SortedMap_lookupMap$27 = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(( _$$21 ) => (_$$21.h3), Data_SortedMap_lookupT23(_$$3.h3, _$$2, _$$3.h4)) : Prelude_Nothing() ));
const Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_ = ( _$$0, _$$1 ) => { const sc$$6 = (_$$0.h1) == (_$$1.h1); switch (sc$$6) { case true: return Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(Prelude_Prelude_Eq$20Prim_String, _$$0.h0, _$$1.h0); case false: return false; } };
const Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_ = ( _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_ = ( arg ) => { if ((arg.h3.tag) == (1)) { if ((arg.h2.tag) == (1)) { const sc$$10 = Prelude__$3D$3D_(arg.h1)(arg.h2.h1)(arg.h3.h1); switch (sc$$10) { case true: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h2,  h3: arg.h3.h2 }; case false: return { tag: 0,  h0: false }; } } else { return { tag: 0,  h0: false }; } } else { return ( (arg.h2.tag) == (0) ? { tag: 0,  h0: true } : { tag: 0,  h0: false } ); } };
const Lib_Common_Prelude_Eq$20Lib_Common_QName = Prelude_MkEq(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(eta, eta1))));
const Prelude_Prelude_Eq$20Prelude_Bool$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$0) { case true: return _$$1; case false: switch (_$$1) { case false: return true; default: return false; } break; } };
const Prelude_Prelude_Eq$20Prelude_Bool = Prelude_MkEq(( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prelude_Bool$2C_$3D$3D_(eta, eta1))));
const Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29 = ( _, _1 ) => (Prelude_MkEq(( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2C_$3D$3D_(_, _1, eta, eta1)))));
const Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2C_$3D$3D_ = ( _$$2, _$$3, _$$4, _$$5 ) => ((Prelude__$3D$3D_(_$$2)(_$$4.h2)(_$$5.h2)) && (Prelude__$3D$3D_(_$$3)(_$$4.h3)(_$$5.h3)));
const Prelude_filter = ( _$$1, _$$2 ) => (Prelude_filter_go(null, _$$1, _$$2, null, _$$2, Prelude_Lin()));
const Prelude_filter_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Prelude_REC_filter_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_filter_go = ( arg ) => { if ((arg.h4.tag) == (1)) { const sc$$9 = arg.h1(arg.h4.h1); switch (sc$$9) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: Prelude__$3A$3C_(arg.h5, arg.h4.h1) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: arg.h5 }; } } else { return { tag: 0,  h0: Prelude__$3C$3E$3E_(arg.h5, Prelude_Nil()) }; } };
const Lib_TCO_tailCallOpt = ( _$$0 ) => { const graph = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap(( _$$1 ) => (_$$1), ( eta ) => (Lib_TCO_tailNames(eta)), eta)), Data_SortedMap_toList(_$$0)); const groups = Data_Graph_tarjan(Lib_Common_Prelude_Eq$20Lib_Common_QName, Lib_Common_Prelude_Ord$20Lib_Common_QName, graph); return Prelude_foldlM(Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_TCO_tailCallOpt_doUpdate_processGroup(_$$0, null, null, eta, eta1))), _$$0, groups); };
const Lib_TCO_tailCallOpt_doUpdate_processGroup = ( _, _1, _2, _$$3, _$$4 ) => { const pairs = Prelude_mapMaybe(( _$$5 ) => (Data_SortedMap_lookupMap(_$$5, _$$3)), _$$4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TCO_doOptimize(pairs), ( updates ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_foldl(( eta ) => (( eta1 ) => (Lib_TCO_tailCallOpt_doUpdate(_, _1, eta, eta1))), _$$3, updates)))); };
const Lib_TCO_tailCallOpt_doUpdate = ( _, _1, _$$2, _$$3 ) => (Data_SortedMap_updateMap(_$$3.h2, _$$3.h3, _$$2));
const Data_SortedMap_updateMap = ( _$$2, _$$3, _$$4 ) => { if ((_$$4.tag) == (1)) { const sc$$10 = Data_SortedMap_insertT23(_$$4.h3, _$$2, _$$3, _$$4.h4); return ( (sc$$10.tag) == (1) ? Data_SortedMap_MapOf((1) + (_$$4.h2), _$$4.h3, Data_SortedMap_Node2(sc$$10.h2.h2, sc$$10.h2.h3.h2, sc$$10.h2.h3.h3)) : Data_SortedMap_MapOf(_$$4.h2, _$$4.h3, sc$$10.h2) ); } else { return Data_SortedMap_MapOf(0, _$$4.h2, Data_SortedMap_Leaf(_$$2, _$$3)); } };
const Data_SortedMap_Leaf = ( h2, h3 ) => ({ tag: 0,  h0: null,  h1: null,  h2: h2,  h3: h3 });
const Data_SortedMap_MapOf = ( h2, h3, h4 ) => ({ tag: 1,  h0: null,  h1: null,  h2: h2,  h3: h3,  h4: h4 });
const Data_SortedMap_Node2 = ( h3, h4, h5 ) => ({ tag: 1,  h0: null,  h1: null,  h2: null,  h3: h3,  h4: h4,  h5: h5 });
const Data_SortedMap_insertT23 = ( _$$3, _$$4, _$$5, _$$6 ) => { switch (_$$6.tag) { case 2: { const sc$$15 = _$$3(_$$4)(_$$6.h4); switch (sc$$15) { case 2: { const sc$$16 = _$$3(_$$4)(_$$6.h6); switch (sc$$16) { case 2: { const sc$$17 = Data_SortedMap_insertT23(_$$3, _$$4, _$$5, _$$6.h7); return ( (sc$$17.tag) == (1) ? Prelude_Right(Prelude__$2C_(Data_SortedMap_Node2(_$$6.h3, _$$6.h4, _$$6.h5), Prelude__$2C_(_$$6.h6, Data_SortedMap_Node2(sc$$17.h2.h2, sc$$17.h2.h3.h2, sc$$17.h2.h3.h3)))) : Prelude_Left(Data_SortedMap_Node3(_$$6.h3, _$$6.h4, _$$6.h5, _$$6.h6, sc$$17.h2)) ); break; } default: { const sc$$17 = Data_SortedMap_insertT23(_$$3, _$$4, _$$5, _$$6.h5); return ( (sc$$17.tag) == (1) ? Prelude_Right(Prelude__$2C_(Data_SortedMap_Node2(_$$6.h3, _$$6.h4, sc$$17.h2.h2), Prelude__$2C_(sc$$17.h2.h3.h2, Data_SortedMap_Node2(sc$$17.h2.h3.h3, _$$6.h6, _$$6.h7)))) : Prelude_Left(Data_SortedMap_Node3(_$$6.h3, _$$6.h4, sc$$17.h2, _$$6.h6, _$$6.h7)) ); break; } } break; } default: { const sc$$16 = Data_SortedMap_insertT23(_$$3, _$$4, _$$5, _$$6.h3); return ( (sc$$16.tag) == (1) ? Prelude_Right(Prelude__$2C_(Data_SortedMap_Node2(sc$$16.h2.h2, sc$$16.h2.h3.h2, sc$$16.h2.h3.h3), Prelude__$2C_(_$$6.h4, Data_SortedMap_Node2(_$$6.h5, _$$6.h6, _$$6.h7)))) : Prelude_Left(Data_SortedMap_Node3(sc$$16.h2, _$$6.h4, _$$6.h5, _$$6.h6, _$$6.h7)) ); break; } } break; } case 1: { const sc$$13 = _$$3(_$$4)(_$$6.h4); switch (sc$$13) { case 2: { const sc$$14 = Data_SortedMap_insertT23(_$$3, _$$4, _$$5, _$$6.h5); return ( (sc$$14.tag) == (1) ? Prelude_Left(Data_SortedMap_Node3(_$$6.h3, _$$6.h4, sc$$14.h2.h2, sc$$14.h2.h3.h2, sc$$14.h2.h3.h3)) : Prelude_Left(Data_SortedMap_Node2(_$$6.h3, _$$6.h4, sc$$14.h2)) ); break; } default: { const sc$$14 = Data_SortedMap_insertT23(_$$3, _$$4, _$$5, _$$6.h3); return ( (sc$$14.tag) == (1) ? Prelude_Left(Data_SortedMap_Node3(sc$$14.h2.h2, sc$$14.h2.h3.h2, sc$$14.h2.h3.h3, _$$6.h4, _$$6.h5)) : Prelude_Left(Data_SortedMap_Node2(sc$$14.h2, _$$6.h4, _$$6.h5)) ); break; } } break; } case 0: { const sc$$11 = _$$3(_$$4)(_$$6.h2); switch (sc$$11) { case 2: return Prelude_Right(Prelude__$2C_(Data_SortedMap_Leaf(_$$6.h2, _$$6.h3), Prelude__$2C_(_$$6.h2, Data_SortedMap_Leaf(_$$4, _$$5)))); case 1: return Prelude_Left(Data_SortedMap_Leaf(_$$4, _$$5)); case 0: return Prelude_Right(Prelude__$2C_(Data_SortedMap_Leaf(_$$4, _$$5), Prelude__$2C_(_$$4, Data_SortedMap_Leaf(_$$6.h2, _$$6.h3)))); } break; } } };
const Data_SortedMap_Node3 = ( h3, h4, h5, h6, h7 ) => ({ tag: 2,  h0: null,  h1: null,  h2: null,  h3: h3,  h4: h4,  h5: h5,  h6: h6,  h7: h7 });
const Lib_TCO_doOptimize = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt_splitFun(_$$0, null, null, null, null, eta)), _$$0), ( splitFuns ) => { const nms = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0); const alts = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt(_$$0, null, null, null, nms, eta)), Prelude_enumerate(splitFuns)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TCO_doOptimize_mkWrap_mkRecName(_$$0, null, null, nms), ( recName ) => { const recfun = Lib_CompileExp_CFun(Prelude__$3A$3A_(Prelude__$2C_(true, "arg"), Prelude_Nil()), Lib_CompileExp_CCase(Lib_CompileExp_CBnd(0), alts)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_TCO_doOptimize_mkWrap(_$$0, null, recName, eta)), Prelude_enumerate(_$$0)), ( wrapped ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(recName, recfun), wrapped)))); }); }));
const Prelude_enumerate = ( _$$1 ) => (Prelude_enumerate_go(null, _$$1, null, 0, _$$1));
const Prelude_enumerate_go = ( _, _1, _2, _$$3, _$$4 ) => (( (_$$4.tag) == (1) ? Prelude__$3A$3A_(Prelude__$2C_(_$$3, _$$4.h1), Prelude_enumerate_go(_, _1, _2, (1) + (_$$3), _$$4.h2)) : Prelude_Nil() ));
const Lib_TCO_doOptimize_mkWrap = ( _, _1, _$$2, _$$3 ) => { if ((_$$3.h3.h3.tag) == (2)) { const arglen = Prelude_length$27(_$$3.h3.h3.h0); const arg = Lib_CompileExp_CConstr((1) + (_$$3.h2), Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h3.h2), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( k ) => (Lib_CompileExp_CBnd(((arglen) - (k)) - (1))), Lib_Common_range(0, arglen))); const body = Lib_CompileExp_CAppRef(Lib_TCO_bouncer, Prelude__$3A$3A_(Lib_CompileExp_CRef(_$$2), Prelude__$3A$3A_(arg, Prelude_Nil())), Prelude__$3A$3A_(true, Prelude__$3A$3A_(true, Prelude_Nil()))); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$3.h3.h2, Lib_CompileExp_CFun(_$$3.h3.h3.h0, body))); } else { return Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("error in mkWrap: ") + (Prelude_showInt(Prelude_natToInt(_$$3.h2)))) + (" not a CFun"))), eta)))); } };
const Lib_CompileExp_CFun = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_Common_QN = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_TCO_bouncer = Lib_Common_QN(Prelude_Nil(), "bouncer");
const Lib_CompileExp_CAppRef = ( h0, h1, h2 ) => ({ tag: 3,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Common_range = ( _$$0, _$$1 ) => { const sc$$2 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, _$$1), 0); switch (sc$$2) { case true: return Prelude__$3A$3A_(_$$0, Lib_Common_range((_$$0) + (1), _$$1)); case false: return Prelude_Nil(); } };
const Lib_CompileExp_CBnd = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_CompileExp_CConstr = ( h0, h1, h2 ) => ({ tag: 12,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_ = ( _$$2, _$$3 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$2.h1(tc), ( $$sc ) => (( ($$sc.tag) == (1) ? ( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$3.h1($$sc.h2.h2), ( $$sc1 ) => (( ($$sc1.tag) == (1) ? ( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_($$sc1.h2.h2, $$sc.h2.h3($$sc1.h2.h3))), eta)) : ( eta ) => (Prelude_MkIORes(Prelude_Left($$sc1.h2), eta)) )), eta)) : ( eta ) => (Prelude_MkIORes(Prelude_Left($$sc.h2), eta)) )), eta)))));
const Prelude_MkApplicative = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Lib_Types_Prelude_Applicative$20Lib_Types_M = Prelude_MkApplicative(( a ) => (( eta ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(eta))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(eta, eta1))))));
const Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse = ( _$$3, _$$4, _$$5 ) => (( (_$$5.tag) == (1) ? Prelude__$3C$2A$3E_(_$$3)(null)(null)(Prelude__$3C$2A$3E_(_$$3)(null)(null)(Prelude_return(_$$3)(null)(( eta ) => (( eta1 ) => (Prelude__$3A$3A_(eta, eta1)))))(_$$4(_$$5.h1)))(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(_$$3, _$$4, _$$5.h2)) : Prelude_return(_$$3)(null)(Prelude_Nil()) ));
const Prelude_return = ( _$$1 ) => (( a ) => (_$$1.h1(null)));
const Prelude__$3C$2A$3E_ = ( _$$1 ) => (( a ) => (( b ) => (_$$1.h2(null)(null))));
const Lib_CompileExp_CCase = ( h0, h1 ) => ({ tag: 5,  h0: h0,  h1: h1 });
const Lib_TCO_doOptimize_mkWrap_mkRecName = ( _, _1, _2, _$$3 ) => (( (_$$3.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Common_QN(_$$3.h1.h0, (("REC_") + (_$$3.h1.h1)) + (""))) : Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "INTERNAL ERROR: Empty List in doOptimize")), eta)))) ));
const Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt = ( _, _1, _2, _3, _$$4, _$$5 ) => (Lib_CompileExp_CConAlt((1) + (_$$5.h2), Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h3.h2), 0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h3), _$$5.h3.h3.h2), Lib_TCO_rewriteTailCalls(_$$4, _$$5.h3.h3.h3)));
const Lib_TCO_rewriteTailCalls = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 10: return Lib_CompileExp_CLetRec(_$$1.h0, _$$1.h1, Lib_TCO_rewriteTailCalls(_$$0, _$$1.h2)); case 9: return Lib_CompileExp_CLet(_$$1.h0, _$$1.h1, Lib_TCO_rewriteTailCalls(_$$0, _$$1.h2)); case 5: return Lib_CompileExp_CCase(_$$1.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_TCO_rewriteTailCalls_getTag_rewriteAlt(_$$0, _$$1, null, null, eta)), _$$1.h1)); case 3: { const sc$$8 = (Prelude_length$27(_$$1.h1)) == (Prelude_length$27(_$$1.h2)); switch (sc$$8) { case true: { const sc$$9 = Lib_TCO_rewriteTailCalls_getTag(_$$0, _$$1, null, (1) + (0), _$$1.h0, _$$0); return ( (sc$$9.tag) == (1) ? Lib_CompileExp_CConstr(0, "return", Prelude__$3A$3A_(_$$1, Prelude_Nil())) : Lib_CompileExp_CConstr(sc$$9.h1, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h0), _$$1.h1) ); break; } case false: return Lib_CompileExp_CConstr(0, "return", Prelude__$3A$3A_(_$$1, Prelude_Nil())); } break; } default: return Lib_CompileExp_CConstr(0, "return", Prelude__$3A$3A_(_$$1, Prelude_Nil())); } };
const Lib_TCO_rewriteTailCalls_getTag = ( _, _1, _2, _$$3, _$$4, _$$5 ) => (bouncer(Lib_TCO_REC_rewriteTailCalls_getTag, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Lib_TCO_REC_rewriteTailCalls_getTag = ( arg ) => { if ((arg.h5.tag) == (1)) { const sc$$9 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h5.h1, arg.h4); switch (sc$$9) { case true: return { tag: 0,  h0: Prelude_Just(arg.h3) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: (1) + (arg.h3),  h4: arg.h4,  h5: arg.h5.h2 }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_TCO_rewriteTailCalls_getTag_rewriteAlt = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.tag) { case 2: return Lib_CompileExp_CLitAlt(_$$4.h0, Lib_TCO_rewriteTailCalls(_, _$$4.h1)); case 1: return Lib_CompileExp_CDefAlt(Lib_TCO_rewriteTailCalls(_, _$$4.h0)); case 0: return Lib_CompileExp_CConAlt(_$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, Lib_TCO_rewriteTailCalls(_, _$$4.h4)); } };
const Lib_CompileExp_CConAlt = ( h0, h1, h2, h3, h4 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_CompileExp_CDefAlt = ( h0 ) => ({ tag: 1,  h0: h0 });
const Lib_CompileExp_CLitAlt = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_CompileExp_CLet = ( h0, h1, h2 ) => ({ tag: 9,  h0: h0,  h1: h1,  h2: h2 });
const Lib_CompileExp_CLetRec = ( h0, h1, h2 ) => ({ tag: 10,  h0: h0,  h1: h1,  h2: h2 });
const Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt_splitFun = ( _, _1, _2, _3, _4, _$$5 ) => (( (_$$5.h3.tag) == (2) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$5.h2, Prelude__$2C_(_$$5.h3.h0, _$$5.h3.h1))) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("TCO error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h2))) + (" not a function"))), eta)))) ));
const Prelude_MkMonad = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Lib_Types_Prelude_Monad$20Lib_Types_M = Prelude_MkMonad(( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(eta, eta1))))), ( a ) => (( eta ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(eta))));
const Prelude_foldlM = ( _$$3, _$$4, _$$5, _$$6 ) => (Prelude_foldl(( ma ) => (( b ) => (Prelude_bind(_$$3)(null)(null)(ma)(( _$$51 ) => (_$$4(_$$51)(b))))), Prelude_pure(_$$3)(null)(_$$5), _$$6));
const Prelude_pure = ( _$$1 ) => (( a ) => (_$$1.h2(null)));
const Prelude_bind = ( _$$1 ) => (( a ) => (( b ) => (_$$1.h1(null)(null))));
const Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare = ( _$$0, _$$1 ) => { const sc$$6 = Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(Prelude_Prelude_Eq$20Prim_String, _$$0.h0, _$$1.h0); switch (sc$$6) { case true: return Prelude_jsCompare(null, _$$0.h1, _$$1.h1); case false: return Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare(Prelude_Prelude_Ord$20Prim_String, _$$0.h0, _$$1.h0); } };
const Prelude_Prelude_Ord$20Prim_String$2Ccompare = ( _$$0, _$$1 ) => (Prelude_jsCompare(null, _$$0, _$$1));
const Prelude_MkOrd = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Prelude_Prelude_Ord$20Prim_String = Prelude_MkOrd(( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))));
const Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare = ( _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare = ( arg ) => { if ((arg.h3.tag) == (1)) { if ((arg.h2.tag) == (1)) { const sc$$10 = Prelude_compare(arg.h1)(arg.h2.h1)(arg.h3.h1); switch (sc$$10) { case 1: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h2,  h3: arg.h3.h2 }; default: return { tag: 0,  h0: sc$$10 }; } } else { return { tag: 0,  h0: 0 }; } } else { return ( (arg.h2.tag) == (0) ? { tag: 0,  h0: 1 } : { tag: 0,  h0: 2 } ); } };
const Prelude_compare = ( _$$1 ) => (_$$1.h1);
const Lib_Common_Prelude_Ord$20Lib_Common_QName = Prelude_MkOrd(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1))));
const Data_Graph_tarjan = ( _$$1, _$$2, _$$3 ) => { const g = Data_SortedMap_foldMap(( _$$21 ) => (( _$$31 ) => (_$$21)), Data_SortedMap_EmptyMap(_$$2.h1), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Data_Graph_tarjan_mkVertex(null, _$$1, _$$2, _$$3, null, eta)), _$$3)); const _sc$$0 = Prelude_foldl(( eta ) => (( eta1 ) => (Data_Graph_tarjan_mkVertex_checkVertex(null, _$$1, _$$2, _$$3, null, null, eta, eta1))), Data_Graph_MkTState(0, Prelude_Nil(), Prelude_Nil(), g), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$3)); return _sc$$0.h3; };
const Data_Graph_MkTState = ( h1, h2, h3, h4 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Data_Graph_tarjan_mkVertex_checkVertex = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { const sc$$8 = Data_SortedMap_lookupMap$27(_$$7, _$$6.h4); if ((sc$$8.tag) == (0)) { const sc$$11 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$8.h1.h3, 0), 2); switch (sc$$11) { case true: return _$$6; case false: return Data_Graph_strongConnect(_1, _2, _$$6, sc$$8.h1); } } else { return _$$6; } };
const Data_Graph_strongConnect = ( _$$1, _$$2, _$$3, _$$4 ) => { const index$27 = (_$$3.h1) + (1); const vtx$27 = Data_Graph_MkTV(_$$4.h1, _$$4.h2, index$27, index$27, true); const stack$27 = Prelude__$3A$3A_(_$$4.h1, _$$3.h2); const graph$27 = Data_SortedMap_updateMap(vtx$27.h1, vtx$27, _$$3.h4); const st$27 = Data_Graph_MkTState(index$27, stack$27, _$$3.h3, graph$27); return Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge_checkRoot(null, _$$1, _$$2, _$$3, _$$4, null, null, null, null, null, null, null, Prelude_foldl(( eta ) => (( eta1 ) => (Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge(null, _$$1, _$$2, _$$3, _$$4, null, null, null, null, null, null, eta, eta1))), st$27, _$$4.h2)); };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$11, _$$12 ) => { const sc$$13 = Data_SortedMap_lookupMap$27(_$$12, _$$11.h4); if ((sc$$13.tag) == (0)) { switch (sc$$13.h1.h5) { case true: return Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$11, _4.h1, sc$$13.h1.h3); case false: { const sc$$17 = (sc$$13.h1.h3) == (0); switch (sc$$17) { case true: { const st$27 = Data_Graph_strongConnect(_1, _2, _$$11, sc$$13.h1); const sc$$19 = Data_SortedMap_lookupMap$27(_$$12, st$27.h4); return ( (sc$$19.tag) == (0) ? Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink(_, _1, _2, _3, _4, _5, _6, _7, _8, st$27, _4.h1, sc$$19.h1.h4) : st$27 ); break; } case false: return _$$11; } break; } } } else { return _$$11; } };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11 ) => (Data_Graph_strongConnect_min_splitComp_updateNode(_, _1, _2, _3, _4, _5, _6, _7, _$$9, _$$10, ( vt ) => (Data_Graph_MkTV(vt.h1, vt.h2, vt.h3, Data_Graph_strongConnect_min(_, _1, _2, _3, _4, _5, vt.h4, _$$11), vt.h5))));
const Data_Graph_strongConnect_min = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { const sc$$8 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$6, _$$7), 0); switch (sc$$8) { case true: return _$$6; case false: return _$$7; } };
const Data_Graph_MkTV = ( h1, h2, h3, h4, h5 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Data_Graph_strongConnect_min_splitComp_updateNode = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10 ) => { const sc$$16 = Data_SortedMap_lookupMap$27(_$$9, _$$8.h4); return ( (sc$$16.tag) == (1) ? _$$8 : Data_Graph_MkTState(_$$8.h1, _$$8.h2, _$$8.h3, Data_SortedMap_updateMap(_$$9, _$$10(sc$$16.h1), _$$8.h4)) ); };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge_checkRoot = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { const sc$$13 = Data_SortedMap_lookupMap$27(_4.h1, _$$12.h4); if ((sc$$13.tag) == (0)) { const sc$$16 = (sc$$13.h1.h4) == (sc$$13.h1.h3); switch (sc$$16) { case true: { const sc$$17 = Data_Graph_strongConnect_min_splitComp(_, _1, _2, _3, _4, _5, _6, Prelude_Nil(), _$$12.h2); const st = Prelude_foldl(( eta ) => (( eta1 ) => (Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, eta, eta1))), _$$12, sc$$17.h2); const sc$$23 = (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, Prelude_length$27(sc$$17.h2), 1), 2)) || (Prelude_elem(_1, sc$$13.h1.h1, sc$$13.h1.h2)); switch (sc$$23) { case true: return Data_Graph_MkTState(st.h1, sc$$17.h3, Prelude__$3A$3A_(sc$$17.h2, st.h3), st.h4); case false: return Data_Graph_MkTState(st.h1, sc$$17.h3, st.h3, st.h4); } break; } case false: return _$$12; } } else { return _$$12; } };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => (Data_Graph_strongConnect_min_splitComp_updateNode(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, ( vt ) => (Data_Graph_MkTV(vt.h1, vt.h2, vt.h3, vt.h4, false))));
const Data_Graph_strongConnect_min_splitComp = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (bouncer(Data_Graph_REC_strongConnect_min_splitComp, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8 }));
const Data_Graph_REC_strongConnect_min_splitComp = ( arg ) => { if ((arg.h8.tag) == (1)) { const sc$$12 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_compare(arg.h2)(arg.h8.h1)(arg.h4.h1), 1); switch (sc$$12) { case true: return { tag: 0,  h0: Prelude__$2C_(Prelude__$3A$3A_(arg.h8.h1, arg.h7), arg.h8.h2) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: Prelude__$3A$3A_(arg.h8.h1, arg.h7),  h8: arg.h8.h2 }; } } else { return { tag: 0,  h0: Prelude__$2C_(arg.h7, Prelude_Nil()) }; } };
const Data_Graph_tarjan_mkVertex = ( _, _1, _2, _3, _4, _$$5 ) => (Prelude__$2C_(_$$5.h2, Data_Graph_MkTV(_$$5.h2, _$$5.h3, 0, 0, false)));
const Data_SortedMap_EmptyMap = ( h2 ) => ({ tag: 0,  h0: null,  h1: null,  h2: h2 });
const Data_SortedMap_foldMap = ( _$$2, _$$3, _$$4 ) => (bouncer(Data_SortedMap_REC_foldMap, { tag: 1,  h0: null,  h1: null,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Data_SortedMap_REC_foldMap = ( arg ) => { if ((arg.h4.tag) == (1)) { const sc$$12 = Data_SortedMap_lookupMap(arg.h4.h1.h2, arg.h3); return ( (sc$$12.tag) == (1) ? { tag: 1,  h0: null,  h1: null,  h2: arg.h2,  h3: Data_SortedMap_updateMap(arg.h4.h1.h2, arg.h4.h1.h3, arg.h3),  h4: arg.h4.h2 } : { tag: 1,  h0: null,  h1: null,  h2: arg.h2,  h3: Data_SortedMap_updateMap(arg.h4.h1.h2, arg.h2(sc$$12.h1.h3)(arg.h4.h1.h3), arg.h3),  h4: arg.h4.h2 } ); } else { return { tag: 0,  h0: arg.h3 }; } };
const Data_SortedMap_toList = ( _$$2 ) => (( (_$$2.tag) == (1) ? Prelude_reverse()(Data_SortedMap_toList_go(null, null, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, _$$2.h3, _$$2.h4, null, _$$2.h4, Prelude_Nil())) : Prelude_Nil() ));
const Data_SortedMap_toList_go = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11 ) => (bouncer(Data_SortedMap_REC_toList_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: null,  h10: _$$10,  h11: _$$11 }));
const Data_SortedMap_REC_toList_go = ( arg ) => { switch (arg.h10.tag) { case 2: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: null,  h10: arg.h10.h7,  h11: Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h10.h5, Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h10.h3, arg.h11)) }; case 1: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: null,  h10: arg.h10.h5,  h11: Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h10.h3, arg.h11) }; case 0: return { tag: 0,  h0: Prelude__$3A$3A_(Prelude__$2C_(arg.h10.h2, arg.h10.h3), arg.h11) }; } };
const Lib_TCO_tailNames = ( _$$0 ) => (bouncer(Lib_TCO_REC_tailNames, { tag: 1,  h0: _$$0 }));
const Lib_TCO_REC_tailNames = ( arg ) => { switch (arg.h0.tag) { case 14: return { tag: 0,  h0: Prelude_Nil() }; case 13: return { tag: 0,  h0: Prelude_Nil() }; case 12: return { tag: 0,  h0: Prelude_Nil() }; case 11: return { tag: 0,  h0: Prelude_Nil() }; case 10: return { tag: 1,  h0: arg.h0.h2 }; case 9: return { tag: 1,  h0: arg.h0.h2 }; case 8: return { tag: 0,  h0: Prelude_Nil() }; case 7: return { tag: 0,  h0: Prelude_Nil() }; case 6: return { tag: 0,  h0: Prelude_Nil() }; case 5: return { tag: 0,  h0: Prelude_Prelude_Monad$20Prelude_List$2Cbind(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_TCO_tailNames_altTailNames(arg.h0, arg.h0.h0, arg.h0.h1, null, eta)), arg.h0.h1), ( _$$1 ) => (_$$1)) }; case 4: return { tag: 0,  h0: Prelude_Nil() }; case 3: return { tag: 0,  h0: Prelude__$3A$3A_(arg.h0.h0, Prelude_Nil()) }; case 2: return { tag: 1,  h0: arg.h0.h1 }; case 1: return { tag: 0,  h0: Prelude_Nil() }; case 0: return { tag: 0,  h0: Prelude_Nil() }; } };
const Lib_TCO_tailNames_altTailNames = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.tag) { case 2: return Lib_TCO_tailNames(_$$4.h1); case 1: return Lib_TCO_tailNames(_$$4.h0); case 0: return Lib_TCO_tailNames(_$$4.h4); } };
const Prelude_Prelude_Monad$20Prelude_List$2Cbind = ( _$$2, _$$3 ) => (( (_$$2.tag) == (1) ? Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(_$$3(_$$2.h1), Prelude_Prelude_Monad$20Prelude_List$2Cbind(_$$2.h2, _$$3)) : Prelude_Nil() ));
const Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap = ( _$$4, _$$5, _$$6 ) => (Prelude__$2C_(_$$4(_$$6.h2), _$$5(_$$6.h3)));
const Lib_Ref2_MkRef = ( h2 ) => ({ tag: 0,  h0: null,  h1: null,  h2: h2 });
const Lib_CompileExp_defToCExp = ( _$$0, _$$1 ) => { switch (_$$1.h3.tag) { case 6: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$2C_(_$$1.h2, eta)), Lib_CompileExp_compilePop(_$$1.h2)); case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1.h2, Lib_CompileExp_CRaw(_$$1.h3.h0, _$$1.h3.h2))); case 4: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1.h2, Lib_CompileExp_compileDCon(0, _$$1.h2, 0, Prelude_replicate$27(Prelude_intToNat(_$$1.h3.h0), true)))); case 3: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$2C_(_$$1.h2, eta)), Lib_CompileExp_compileFun(_$$0, _$$1.h3.h0)); case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1.h2, Lib_CompileExp_compileDCon(_$$1.h3.h0, _$$1.h2, _$$1.h3.h1, _$$1.h3.h2))); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1.h2, Lib_CompileExp_compileDCon(0, _$$1.h2, 0, Prelude_replicate$27(Prelude_intToNat(_$$1.h3.h0), true)))); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1.h2, Lib_CompileExp_CErased)); } };
const Lib_CompileExp_CErased = { tag: 11 };
const Prelude_replicate$27 = ( _$$1, _$$2 ) => (Prelude_replicate$27_go(null, _$$1, _$$2, null, _$$1, Prelude_Nil()));
const Prelude_replicate$27_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Prelude_REC_replicate$27_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_replicate$27_go = ( arg ) => { switch (arg.h4) { case 0: return { tag: 0,  h0: arg.h5 }; default: { const x = (arg.h4) - (1); return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: x,  h5: Prelude__$3A$3A_(arg.h2, arg.h5) }; break; } } };
const Lib_CompileExp_compileDCon = ( _$$0, _$$1, _$$2, _$$3 ) => { if ((_$$3.tag) == (0)) { switch (_$$2) { case 5: return Lib_CompileExp_CLit(Lib_Types_LBool(false)); case 4: return Lib_CompileExp_CLit(Lib_Types_LBool(true)); case 3: return Lib_CompileExp_CLit(Lib_Types_LInt(Prelude_natToInt(_$$0))); default: return Lib_CompileExp_CConstr(_$$0, _$$1.h1, Prelude_Nil()); } } else { const args = Lib_CompileExp_compileDCon_mkArgs(_$$0, _$$1, _$$2, _$$3, _$$1.h0, _$$1.h1, null, 0, _$$3); const alen = Prelude_length$27(_$$3); return Lib_CompileExp_CFun(args, Lib_CompileExp_CConstr(_$$0, _$$1.h1, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( k ) => (Lib_CompileExp_CBnd(((alen) - (k)) - (1))), Lib_Common_range(0, alen)))); } };
const Lib_CompileExp_compileDCon_mkArgs = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (( (_$$8.tag) == (1) ? Prelude__$3A$3A_(Prelude__$2C_(_$$8.h1, (("h") + (Prelude_showInt(Prelude_natToInt(_$$7)))) + ("")), Lib_CompileExp_compileDCon_mkArgs(_, _1, _2, _3, _4, _5, _6, (1) + (_$$7), _$$8.h2)) : Prelude_Nil() ));
const Lib_Types_LInt = ( h0 ) => ({ tag: 1,  h0: h0 });
const Lib_CompileExp_CLit = ( h0 ) => ({ tag: 8,  h0: h0 });
const Lib_Types_LBool = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_CompileExp_compileFun = ( _$$0, _$$1 ) => (Lib_CompileExp_compileFun_go(_$$0, _$$1, null, _$$1, Prelude_Lin()));
const Lib_CompileExp_compileFun_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_CompileExp_REC_compileFun_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_CompileExp_REC_compileFun_go = ( arg ) => (( (arg.h3.tag) == (3) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h4,  h4: Prelude__$3A$3C_(arg.h4, Prelude__$2C_(arg.h3.h3, arg.h3.h1)) } : ( (arg.h4.tag) == (0) ? { tag: 0,  h0: Lib_CompileExp_compileTerm(arg.h0, arg.h3) } : { tag: 0,  h0: Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_CompileExp_CFun(Prelude__$3C$3E$3E_(arg.h4, Prelude_Nil()), eta)), Lib_CompileExp_compileTerm(arg.h0, arg.h3)) } ) ));
const Lib_CompileExp_compileTerm = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 11: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CErased); case 10: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLit(_$$1.h1)); case 9: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLetRec(_$$1.h1, t$27, u$27)))))); case 8: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLet(_$$1.h1, t$27, u$27)))))); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$1.h2, ( $$case ) => { switch ($$case.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_CompileExp_CLitAlt($$case.h0, eta)), Lib_CompileExp_compileTerm(_$$0, $$case.h1)); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_lookupDef(_$$0, Lib_Common_emptyFC, $$case.h0), ( def ) => (( (def.tag) == (2) ? Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_CompileExp_CConAlt(def.h0, $$case.h0.h1, def.h1, $$case.h1, eta)), Lib_CompileExp_compileTerm(_$$0, $$case.h2)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (("") + ($$case.h0.h1)) + (" is not constructor"))), eta)))) ))))); case 0: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_CompileExp_CDefAlt(eta)), Lib_CompileExp_compileTerm(_$$0, $$case.h0)); } }), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CCase(t$27, Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_doNumCon_fancyCons(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, null, null, null, null, null, t$27, alts$27))))))); case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h4), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, _$$1.h5), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CAppRef(Lib_Common_QN(Lib_Common_primNS, "PiType"), Prelude__$3A$3A_(t$27, Prelude__$3A$3A_(Lib_CompileExp_CLam(_$$1.h1, u$27), Prelude_Nil())), Prelude__$3A$3A_(true, Prelude__$3A$3A_(true, Prelude_Nil())))))))); case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CRef(Lib_Common_QN(Prelude_Nil(), "U"))); case 4: { const sc$$6 = Lib_Util_funArgs(_$$1); switch (sc$$6.h2.tag) { case 2: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), (("Compiling an unsolved meta ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$1))) + (""))), eta)))); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_CompileExp_compileTerm(_$$0, eta)), sc$$6.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_arityForName(_$$0, sc$$6.h2.h0, sc$$6.h2.h1), ( arity ) => { const sc$$16 = Lib_CompileExp_compilePrimOp(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$6.h2.h1), args$27); if ((sc$$16.tag) == (1)) { const sc$$18 = Data_SortedMap_lookupMap$27(sc$$6.h2.h1, defs); if ((sc$$18.tag) == (0)) { if ((sc$$18.h1.tag) == (2)) { switch (sc$$18.h1.h1) { case 1: return Lib_CompileExp_compileTerm_applySucc(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, args$27); default: return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, arity); } } else { return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, arity); } } else { return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, arity); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$16.h1); } }))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("apply other ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$6.h2))), Prelude_Lin()))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_compileTerm(_$$0, sc$$6.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_CompileExp_compileTerm(_$$0, eta)), sc$$6.h3), ( args$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_foldl(( eta ) => (( eta1 ) => (Lib_CompileExp_CApp(eta, eta1))), t$27, args$27)))))))); } break; } case 3: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_CompileExp_CLam(_$$1.h1, eta)), Lib_CompileExp_compileTerm(_$$0, _$$1.h4)); case 2: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (("Compiling meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), eta)))); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_CompileExp_arityForName(_$$0, _$$1.h0, _$$1.h1), ( arity ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { if ((arity.tag) == (0)) { const sc$$10 = Data_SortedMap_lookupMap$27(_$$1.h1, defs); if ((sc$$10.tag) == (0)) { if ((sc$$10.h1.tag) == (2)) { switch (sc$$10.h1.h1) { case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLit(Lib_Types_LBool(false))); case 4: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLit(Lib_Types_LBool(true))); case 3: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLit(Lib_Types_LInt(Prelude_natToInt(sc$$10.h1.h0)))); case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLit(Lib_Types_LInt(0))); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLam("x", Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), Lib_CompileExp_CBnd(0)))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CRef(_$$1.h1)); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CRef(_$$1.h1)); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CRef(_$$1.h1)); } } else { return Lib_CompileExp_apply(_$$1.h1, Prelude_Nil(), arity); } }))); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CBnd(_$$1.h1)); } };
const Lib_CompileExp_apply = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CAppRef(_$$0, _$$1, _$$2)));
const Lib_CompileExp_CPrimOp = ( h0, h1, h2 ) => ({ tag: 14,  h0: h0,  h1: h1,  h2: h2 });
const Lib_CompileExp_CLam = ( h0, h1 ) => ({ tag: 1,  h0: h0,  h1: h1 });
const Data_IORef_primReadIORef = (_, ref) => (w) => Prelude_MkIORes(ref[0], w);
const Lib_CompileExp_arityForName = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$2, defs); if ((sc$$4.tag) == (1)) { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("Name ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2))) + (" not in scope"))), eta)))); } else { switch (sc$$4.h1.tag) { case 6: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(true, Prelude__$3A$3A_(true, Prelude_Nil()))); case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_replicate$27(sc$$4.h1.h1, true)); case 4: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_replicate$27(Prelude_intToNat(sc$$4.h1.h0), true)); case 3: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_lamArity(sc$$4.h1.h0)); case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$4.h1.h2); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_replicate$27(Prelude_intToNat(sc$$4.h1.h0), true)); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()); } } }));
const Lib_CompileExp_lamArity = ( _$$0 ) => (( (_$$0.tag) == (3) ? Prelude__$3A$3A_(_$$0.h3, Lib_CompileExp_lamArity(_$$0.h4)) : Prelude_Nil() ));
const Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap = ( _$$2, _$$3 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$3.h1(tc), ( $$sc ) => (( ($$sc.tag) == (1) ? ( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_($$sc.h2.h2, _$$2($$sc.h2.h3))), eta)) : ( eta ) => (Prelude_MkIORes(Prelude_Left($$sc.h2), eta)) )), eta)))));
const Lib_CompileExp_CApp = ( h0, h1 ) => ({ tag: 4,  h0: h0,  h1: h1 });
const Lib_Types_pprint$27 = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case 11: return Lib_Prettier_Text("ERASED"); case 10: return Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$2.h1)); case 9: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("letrec"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h3))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("in"))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Nest(2, Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h4))))); case 8: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("in"))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Nest(2, Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h3))))); case 7: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("of"))), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_pprintAlt(0, _$$1, eta)), _$$2.h2)))))); case 6: switch (_$$2.h2) { case 2: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("{{"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}}"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h5))))); case 1: switch (_$$2.h3) { case true: switch (_$$2.h1) { case "_": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Types_pprint$27(1, _$$1, _$$2.h4), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_("_", _$$1), _$$2.h5)))); default: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h5)))))); } break; default: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h5)))))); } break; case 0: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h5))))); } break; case 5: return Lib_Prettier_Text("U"); case 4: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Types_pprint$27(0, _$$1, _$$2.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(1, _$$1, _$$2.h2)))); case 3: return Lib_Types_parens(0, _$$0, Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text((((("\\ ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3))) + ("")) + (_$$2.h1)) + (" =>")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Types_pprint$27(0, Prelude__$3A$3A_(_$$2.h1, _$$1), _$$2.h4))))); case 2: return Lib_Prettier_Text((("?m:") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h1))) + ("")); case 1: return Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h1)); case 0: { const sc$$5 = Prelude_getAt(Prelude_intToNat(_$$2.h1), _$$1); return ( (sc$$5.tag) == (1) ? Lib_Prettier_Text((("BND:") + (Prelude_showInt(_$$2.h1))) + ("")) : Lib_Prettier_Text((((("") + (sc$$5.h1)) + (":")) + (Prelude_showInt(_$$2.h1))) + ("")) ); break; } } };
const Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow = ( _$$0 ) => { switch (_$$0) { case true: return ""; case false: return "0 "; } };
const Lib_Types_pprintAlt = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case 2: return Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$2.h0)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("=>"), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Types_pprint$27(_$$0, _$$1, _$$2.h1), Lib_Prettier_Text(";"))))))); case 1: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h0)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Prettier_text, _$$2.h1)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("=>"), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Types_pprint$27(_$$0, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude_reverse()(_$$2.h1), _$$1), _$$2.h2)))))); case 0: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("_"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("=>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(_$$0, Prelude__$3A$3A_("_", _$$1), _$$2.h0))); } };
const Lib_Prettier_text = ( eta ) => (Lib_Prettier_Text(eta));
const Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_ = ( _$$0, _$$1 ) => (Lib_Prettier_Seq(_$$0, Lib_Prettier_Seq(Lib_Prettier_Text(" "), _$$1)));
const Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 3: switch (_$$0.h0) { case true: return "true"; case false: return "false"; } break; case 2: return (("'") + (Prelude_jsShow(null, _$$0.h0))) + ("'"); case 1: return Prelude_showInt(_$$0.h0); case 0: return Lib_Common_quoteString(_$$0.h0); } };
const Prelude_jsShow = (_,a) => ''+a;
const Lib_Types_log = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, top.h6), 2)), ( _ ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn(_$$1(0))))))));
const Prelude_when = ( _$$1, _$$2, _$$3 ) => { switch (_$$2) { case true: return _$$3(0); case false: return Prelude_return(_$$1)(null)(0); } };
const Lib_Types_getTop = Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_(tc, tc)), eta))));
const Lib_CompileExp_compileTerm_applySucc = ( _, _1, _2, _3, _4, _5, _$$6 ) => (( (_$$6.tag) == (1) ? ( (_$$6.h2.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), _$$6.h1)) : Lib_Types_MkM(( _6 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("overapplied Succ ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_1))) + (""))), eta)))) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CLam("x", Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), Lib_CompileExp_CBnd(0)))) ));
const Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 11: return "ERASED"; case 10: return (("(Lit ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1))) + (")"); case 9: return (((((((("(LetRec ") + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h3))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (")"); case 8: return (((((("(Let ") + (_$$0.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h3))) + (")"); case 7: return (((("(Case ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_showCaseAlt(eta)), _$$0.h2))))) + (")"); case 6: switch (_$$0.h2) { case 2: return (((((((("(Pi {{") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + ("}} => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); case 1: return (((((((("(Pi (") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (") => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); case 0: return (((((((("(Pi {") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + ("} => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); } break; case 5: return "U"; case 4: return (((("(") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (")"); case 3: return (((((("(\\ ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + ("  => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (")"); case 2: return (("(Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (")"); case 1: return (("(Ref ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (")"); case 0: return (("(Bnd ") + (Prelude_showInt(_$$0.h1))) + (")"); } };
const Lib_Types_showCaseAlt = ( _$$0 ) => { switch (_$$0.tag) { case 2: return (((("") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h0))) + (" => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (""); case 1: return (((((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h0))) + (" ")) + (Prelude_joinBy(" ", _$$0.h1))) + (" => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (""); case 0: return (("_ => ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h0))) + (""); } };
const Prelude_Prelude_Show$20Prim_String$2Cshow = ( _$$0 ) => (_$$0);
const Lib_CompileExp_compilePrimOp = ( _$$0, _$$1 ) => { if ((_$$1.tag) == (1)) { if ((_$$1.h2.tag) == (1)) { if ((_$$1.h2.h2.tag) == (1)) { if ((_$$1.h2.h2.h2.tag) == (0)) { switch (_$$0) { case "Prelude.jsEq": return Prelude_Just(Lib_CompileExp_CPrimOp("==", _$$1.h2.h1, _$$1.h2.h2.h1)); case "Prelude.jsLt": return Prelude_Just(Lib_CompileExp_CPrimOp("<", _$$1.h2.h1, _$$1.h2.h2.h1)); default: return Prelude_Nothing(); } } else { return Prelude_Nothing(); } } else { switch (_$$0) { case "Prelude.addString": return Prelude_Just(Lib_CompileExp_CPrimOp("+", _$$1.h1, _$$1.h2.h1)); case "Prelude.addInt": return Prelude_Just(Lib_CompileExp_CPrimOp("+", _$$1.h1, _$$1.h2.h1)); case "Prelude.mulInt": return Prelude_Just(Lib_CompileExp_CPrimOp("*", _$$1.h1, _$$1.h2.h1)); case "Prelude.subInt": return Prelude_Just(Lib_CompileExp_CPrimOp("-", _$$1.h1, _$$1.h2.h1)); case "Prelude._&&_": return Prelude_Just(Lib_CompileExp_CPrimOp("&&", _$$1.h1, _$$1.h2.h1)); case "Prelude._||_": return Prelude_Just(Lib_CompileExp_CPrimOp("||", _$$1.h1, _$$1.h2.h1)); case "Prelude.divInt": return Prelude_Just(Lib_CompileExp_CPrimOp("|", Lib_CompileExp_CPrimOp("/", _$$1.h1, _$$1.h2.h1), Lib_CompileExp_CLit(Lib_Types_LInt(0)))); default: return Prelude_Nothing(); } } } else { return Prelude_Nothing(); } } else { return Prelude_Nothing(); } };
const Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case 11: return _$$0.h0; case 10: return _$$0.h0; case 9: return _$$0.h0; case 8: return _$$0.h0; case 7: return _$$0.h0; case 6: return _$$0.h0; case 5: return _$$0.h0; case 4: return _$$0.h0; case 3: return _$$0.h0; case 2: return _$$0.h0; case 1: return _$$0.h0; case 0: return _$$0.h0; } };
const Lib_Util_funArgs = ( _$$0 ) => (Lib_Util_funArgs_go(_$$0, null, _$$0, Prelude_Nil()));
const Lib_Util_funArgs_go = ( _, _1, _$$2, _$$3 ) => (bouncer(Lib_Util_REC_funArgs_go, { tag: 1,  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Lib_Util_REC_funArgs_go = ( arg ) => (( (arg.h2.tag) == (4) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h1,  h3: Prelude__$3A$3A_(arg.h2.h2, arg.h3) } : { tag: 0,  h0: Prelude__$2C_(arg.h2, arg.h3) } ));
const Lib_Common_primNS = Prelude__$3A$3A_("Prim", Prelude_Nil());
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_doNumCon_fancyCons = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$11, _$$12 ) => { const sc$$13 = Lib_CompileExp_any(( eta ) => (Lib_CompileExp_compileTerm_numAltP(_, _1, _2, _3, _4, _5, eta)), _$$12); switch (sc$$13) { case true: return Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_doNumCon(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$11, _$$12); case false: return Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt(_, _1, _2, _3, _4, _5, _6, eta)), _$$12); } };
const Lib_CompileExp_compileTerm_numAltP_enumAlt = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => { if ((_$$7.tag) == (0)) { switch (_$$7.h2) { case 5: return Lib_CompileExp_CLitAlt(Lib_Types_LBool(false), _$$7.h4); case 4: return Lib_CompileExp_CLitAlt(Lib_Types_LBool(true), _$$7.h4); case 3: return Lib_CompileExp_CLitAlt(Lib_Types_LInt(Prelude_natToInt(_$$7.h0)), _$$7.h4); default: return _$$7; } } else { return _$$7; } };
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_doNumCon = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => { let zeroAlt; const sc$$12 = Prelude_find(( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo(_, _1, _2, _3, _4, _5, _6, _7, 2, eta)), _$$11); if ((sc$$12.tag) == (0)) { zeroAlt = ( (sc$$12.h1.tag) == (0) ? Prelude__$3A$3A_(Lib_CompileExp_CLitAlt(Lib_Types_LInt(0), sc$$12.h1.h4), Prelude_Nil()) : Prelude_fatalError(null, (("ERROR zeroAlt mismatch ") + (Prelude_debugStr(null, sc$$12.h1))) + ("")) ); } else { const sc$$13 = Prelude_find(( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef(_, _1, _2, _3, _4, _5, _6, _7, _8, eta)), _$$11); zeroAlt = ( (sc$$13.tag) == (0) ? ( (sc$$13.h1.tag) == (1) ? Prelude__$3A$3A_(Lib_CompileExp_CLitAlt(Lib_Types_LInt(0), sc$$13.h1.h0), Prelude_Nil()) : Prelude_Nil() ) : Prelude_Nil() ); } let succAlt; const sc$$13 = Prelude_find(( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo(_, _1, _2, _3, _4, _5, _6, _7, 1, eta)), _$$11); if ((sc$$13.tag) == (0)) { succAlt = ( (sc$$13.h1.tag) == (0) ? Prelude__$3A$3A_(Lib_CompileExp_CDefAlt(Lib_CompileExp_CLet("x", Lib_CompileExp_CPrimOp("-", _$$10, Lib_CompileExp_CLit(Lib_Types_LInt(1))), sc$$13.h1.h4)), Prelude_Nil()) : Prelude_fatalError(null, (("ERROR succAlt mismatch ") + (Prelude_debugStr(null, sc$$13.h1))) + ("")) ); } else { const sc$$14 = Prelude_find(( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef(_, _1, _2, _3, _4, _5, _6, _7, _8, eta)), _$$11); succAlt = ( (sc$$14.tag) == (0) ? Prelude__$3A$3A_(sc$$14.h1, Prelude_Nil()) : Prelude_Nil() ); } return Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(zeroAlt, succAlt); };
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9 ) => (( (_$$9.tag) == (1) ? true : false ));
const Prelude_find = ( _$$1, _$$2 ) => (bouncer(Prelude_REC_find, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_find = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$6 = arg.h1(arg.h2.h1); switch (sc$$6) { case true: return { tag: 0,  h0: Prelude_Just(arg.h2.h1) }; case false: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Prelude_debugStr = (_, obj) => {
  const go = (obj) => {
    if (obj === null) return "_"
    if (typeof obj == 'bigint') return ''+obj
    if (obj.tag === '_,_') {
      let rval = '('
      while (obj?.tag === '_,_') {
        rval += go(obj.h2) + ', '
        obj = obj.h3
      }
      return rval + go(obj) + ')'
    }
    if (obj?.tag === '_::_' || obj?.tag === 'Nil') {
      let stuff = Prelude_listToArray(null,obj)
      return '['+(stuff.map(go).join(', '))+']'
    }
    if (obj instanceof Array) {
      return 'io['+(obj.map(go).join(', '))+']'
    }
    if (obj?.tag === 'S' || obj?.tag === 'Z') {
      return ''+Prelude_natToInt(obj)
    } else if (obj?.tag) {
      let rval = '('+obj.tag
      for(let i=0;;i++) {
        let key = 'h'+i
        if (!(key in obj)) break
        rval += ' ' + go(obj[key])
      }
      return rval+')'
    } else {
      return JSON.stringify(obj)
    }
  }
  return go(obj)
};
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (( (_$$9.tag) == (0) ? Lib_Types_Prelude_Eq$20Lib_Types_ConInfo$2C_$3D$3D_(_$$8, _$$9.h2) : false ));
const Lib_Types_Prelude_Eq$20Lib_Types_ConInfo$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case 5: switch (_$$0) { case 5: return true; default: return false; } break; case 4: switch (_$$0) { case 4: return true; default: return false; } break; case 3: switch (_$$0) { case 3: return true; default: return false; } break; case 2: switch (_$$0) { case 2: return true; default: return false; } break; case 1: switch (_$$0) { case 1: return true; default: return false; } break; case 0: switch (_$$0) { case 0: return true; default: return false; } break; } };
const Lib_CompileExp_compileTerm_numAltP = ( _, _1, _2, _3, _4, _5, _$$6 ) => { if ((_$$6.tag) == (0)) { switch (_$$6.h2) { case 2: return true; case 1: return true; default: return false; } } else { return false; } };
const Lib_CompileExp_any = ( _$$1, _$$2 ) => (bouncer(Lib_CompileExp_REC_any, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Lib_CompileExp_REC_any = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$6 = arg.h1(arg.h2.h1); switch (sc$$6) { case true: return { tag: 0,  h0: true }; case false: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; } } else { return { tag: 0,  h0: false }; } };
const Lib_CompileExp_lookupDef = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$2, defs); return ( (sc$$4.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2))) + (" not in scope"))), eta)))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$4.h1) ); }));
const Prelude_MkTraversable = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Prelude_Prelude_Traversable$20Prelude_List = Prelude_MkTraversable(( f ) => (( a ) => (( b ) => (( _ ) => (( eta ) => (( eta1 ) => (Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(_, eta, eta1))))))));
const Prelude_for = ( _$$2, appf$$3, _$$6, _$$7 ) => (Prelude_traverse(_$$2)(null)(null)(null)(appf$$3)(_$$7)(_$$6));
const Prelude_traverse = ( _$$1 ) => (( f ) => (( a ) => (( b ) => (( _ ) => (_$$1.h1(null)(null)(null)(_))))));
const Lib_CompileExp_CRaw = ( h0, h1 ) => ({ tag: 13,  h0: h0,  h1: h1 });
const Lib_CompileExp_compilePop = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$2 = Lib_TopContext_lookup(_$$0, top); return ( (sc$$2.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_CompileExp_CErased) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" not found"))), eta)))) ); }));
const Lib_TopContext_lookup = ( _$$0, _$$1 ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$0, _$$1.h4); if ((sc$$4.tag) == (1)) { const sc$$6 = Data_SortedMap_lookupMap$27(_$$0.h0, _$$1.h0); return ( (sc$$6.tag) == (1) ? Prelude_Nothing() : Data_SortedMap_lookupMap$27(_$$0, sc$$6.h1.h1) ); } else { return Prelude_Just(sc$$4.h1); } };
const Prelude_mapM = ( _$$1, _$$4, _$$5 ) => (( (_$$5.tag) == (1) ? Prelude_bind(_$$1)(null)(null)(_$$4(_$$5.h1))(( b ) => (Prelude_bind(_$$1)(null)(null)(Prelude_mapM(_$$1, _$$4, _$$5.h2))(( bs ) => (Prelude_pure(_$$1)(null)(Prelude__$3A$3A_(b, bs)))))) : Prelude_pure(_$$1)(null)(Prelude_Nil()) ));
const Lib_LiftWhere_liftWhere = ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _.h2)), ( defs ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$3 ) => (0), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_LiftWhere_liftWhereFn(_, eta)), Data_SortedMap_toList(defs))))));
const Lib_LiftWhere_liftWhereFn = ( _$$0, _$$1 ) => (( (_$$1.h3.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1.h2, Prelude_Nil(), _$$1.h3.h0), ( tm$27 ) => (Lib_Ref2_modifyRef(Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$0, ( eta ) => (Data_SortedMap_updateMap(_$$1.h2, Lib_Types_Fn(tm$27), eta))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) ));
const Lib_Types_Fn = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_Ref2_Defs = { tag: 0 };
const Prelude_MkHasIO = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Lib_Types_Prelude_HasIO$20Lib_Types_M = Prelude_MkHasIO(( a ) => (( eta ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(eta))));
const Lib_Ref2_modifyRef = ( _$$2, l$$3, _$$4, _$$5 ) => (Prelude_liftIO(_$$2)(null)(Data_IORef_modifyIORef(Prelude_Prelude_Monad$20Prelude_IO, Prelude_Prelude_HasIO$20Prelude_IO, _$$4.h2, _$$5)));
const Prelude_Prelude_HasIO$20Prelude_IO = Prelude_MkHasIO(( a ) => (( _$$1 ) => (_$$1)));
const Prelude_Prelude_Monad$20Prelude_IO = Prelude_MkMonad(( a ) => (( b ) => (( eta ) => (( eta1 ) => (( eta2 ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(eta, eta1, eta2)))))), ( a ) => (( eta ) => (( eta1 ) => (Prelude_MkIORes(eta, eta1)))));
const Data_IORef_modifyIORef = ( _$$2, _$$3, _$$4, _$$5 ) => (Prelude_bind(_$$2)(null)(null)(Prelude_liftIO(_$$3)(null)(Data_IORef_primReadIORef(null, _$$4)))(( a ) => (Prelude_liftIO(_$$3)(null)(Data_IORef_primWriteIORef(null, _$$4, _$$5(a))))));
const Data_IORef_primWriteIORef = (_, ref, a) => (w) => {
  ref[0] = a
  return Prelude_MkIORes(Prelude_MkUnit,w)
};
const Prelude_liftIO = ( _$$1 ) => (( a ) => (_$$1.h1(null)));
const Lib_LiftWhere_liftWhereTm = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case 9: { const l = Prelude_length(_$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm_getName(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, null, _$$1, _$$3.h1), ( qn ) => { const env$27 = Prelude__$3A$3A_(Prelude_Just(Prelude__$2C_(qn, (1) + (l))), _$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, qn, env$27, _$$3.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Ref2_modifyRef(Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$0, ( eta ) => (Data_SortedMap_updateMap(qn, Lib_Types_Fn(Lib_LiftWhere_liftWhereTm_getName_wrapLam(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, null, null, (1) + (l), t$27)), eta))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, qn, env$27, _$$3.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_LetRec(_$$3.h0, _$$3.h1, Lib_Types_Erased(_$$3.h0), Lib_Types_Erased(_$$3.h0), u$27)))))))); }); break; } case 8: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h2), ( v ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(Prelude_Nothing(), _$$2), _$$3.h3), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Let(_$$3.h0, _$$3.h1, v, sc)))))); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h1), ( t ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_LiftWhere_liftWhereTm_liftWhereAlt(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, null, eta)), _$$3.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(_$$3.h0, t, alts$27)))))); case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h4), ( t ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(Prelude_Nothing(), _$$2), _$$3.h5), ( u ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, t, u)))))); case 4: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (Lib_Types_App(_$$3.h0, eta, eta1))), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h1)), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h2)); case 3: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta)), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(Prelude_Nothing(), _$$2), _$$3.h4)); case 0: { const sc$$7 = Prelude_getAt(Prelude_intToNat(_$$3.h1), _$$2); return ( (sc$$7.tag) == (0) ? ( (sc$$7.h1.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_LiftWhere_liftWhereTm_apply(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, null, Prelude_length$27(_$$2), Prelude_natToInt(sc$$7.h1.h1.h3), Lib_Types_Ref(_$$3.h0, sc$$7.h1.h1.h2))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$3) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$3) ); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$3); } };
const Lib_Types_Ref = ( h0, h1 ) => ({ tag: 1,  h0: h0,  h1: h1 });
const Lib_LiftWhere_liftWhereTm_apply = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => { switch (_$$8) { case 0: return _$$9; default: return Lib_Types_App(_4, Lib_LiftWhere_liftWhereTm_apply(_, _1, _2, _3, _4, _5, _6, _$$7, (_$$8) - (1), _$$9), Lib_Types_Bnd(_4, (_$$7) - (_$$8))); } };
const Lib_Types_Bnd = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Types_App = ( h0, h1, h2 ) => ({ tag: 4,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_Lam = ( h0, h1, h2, h3, h4 ) => ({ tag: 3,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_Pi = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: 6,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Types_Case = ( h0, h1, h2 ) => ({ tag: 7,  h0: h0,  h1: h1,  h2: h2 });
const Lib_LiftWhere_liftWhereTm_liftWhereAlt = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => { switch (_$$8.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseLit(_$$8.h0, eta)), Lib_LiftWhere_liftWhereTm(_, _1, _2, _$$8.h1)); case 1: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseCons(_$$8.h0, _$$8.h1, eta)), Lib_LiftWhere_liftWhereTm(_, _1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$3 ) => (Prelude_Nothing()), _$$8.h1), _2), _$$8.h2)); case 0: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseDefault(eta)), Lib_LiftWhere_liftWhereTm(_, _1, _2, _$$8.h0)); } };
const Lib_Types_CaseDefault = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_Types_CaseCons = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_CaseLit = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_Types_Let = ( h0, h1, h2, h3 ) => ({ tag: 8,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_Erased = ( h0 ) => ({ tag: 11,  h0: h0 });
const Lib_Types_LetRec = ( h0, h1, h2, h3, h4 ) => ({ tag: 9,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_LiftWhere_liftWhereTm_getName_wrapLam = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$11, _$$12 ) => { switch (_$$11) { case 0: return _$$12; default: { const x = (_$$11) - (1); return Lib_Types_Lam(_4, "_", 1, true, Lib_LiftWhere_liftWhereTm_getName_wrapLam(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, x, _$$12)); break; } } };
const Lib_LiftWhere_liftWhereTm_getName = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => { const qn$27 = Lib_Common_QN(_$$10.h0, (_$$10.h1) + ((".") + (_$$11))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _.h2)), ( top ) => { const sc$$16 = Data_SortedMap_lookupMap(qn$27, top); return ( (sc$$16.tag) == (0) ? Lib_LiftWhere_liftWhereTm_getName(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, (_$$11) + ("'")) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(qn$27) ); }); };
const Prelude_length = ( _$$1 ) => (( (_$$1.tag) == (1) ? (1) + (Prelude_length(_$$1.h2)) : 0 ));
const Lib_Compile_eraseEntries_go = ( _, _$$1, _$$2 ) => (( (_$$2.h3.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(Prelude_Nil(), _$$2.h3.h0, Prelude_Nil()), ( tm$27 ) => (Lib_Ref2_modifyRef(Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$1, ( eta ) => (Data_SortedMap_updateMap(_$$2.h2, Lib_Types_Fn(tm$27), eta))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) ));
const Lib_Erasure_erase = ( _$$0, _$$1, _$$2 ) => (bouncer(Lib_Erasure_REC_erase, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_Erasure_REC_erase = ( arg ) => { switch (arg.h1.tag) { case 11: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h1.h0, "erased value in relevant context")), eta)))) }; case 10: return { tag: 0,  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Nothing()) }; case 9: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h1, Prelude__$2C_(true, Prelude_Just(arg.h1.h2))), arg.h0), arg.h1.h3, Prelude_Nil()), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h1, Prelude__$2C_(true, Prelude_Just(arg.h1.h2))), arg.h0), arg.h1.h4, Prelude_Nil()), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_LetRec(arg.h1.h0, arg.h1.h1, arg.h1.h2, u$27, v$27), arg.h2, Prelude_Nothing()))))) }; case 8: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h1.h2, Prelude_Nil()), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h1, Prelude__$2C_(true, Prelude_Nothing())), arg.h0), arg.h1.h3, Prelude_Nil()), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Let(arg.h1.h0, arg.h1.h1, u$27, v$27), arg.h2, Prelude_Nothing()))))) }; case 7: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h1.h1, Prelude_Nil()), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Erasure_doAlt(arg.h0, eta)), arg.h1.h2), ( alts$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Case(arg.h1.h0, u$27, alts$27), arg.h2, Prelude_Nothing()))))) }; case 6: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h1.h4, Prelude_Nil()), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h1, Prelude__$2C_(true, Prelude_Just(arg.h1.h4))), arg.h0), arg.h1.h5, Prelude_Nil()), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Pi(arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h3, u$27, v$27), arg.h2, Prelude_Just(Lib_Types_UU(Lib_Common_emptyFC))))))) }; case 5: return { tag: 0,  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Just(Lib_Types_UU(arg.h1.h0))) }; case 4: return { tag: 1,  h0: arg.h0,  h1: arg.h1.h1,  h2: Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h0, arg.h1.h2), arg.h2) }; case 3: return { tag: 0,  h0: Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_Lam(arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h3, eta)), Lib_Erasure_erase(Prelude__$3A$3A_(Prelude__$2C_(arg.h1.h1, Prelude__$2C_(arg.h1.h3, Prelude_Nothing())), arg.h0), arg.h1.h4, Prelude_Nil())) }; case 2: return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(arg.h1) }; case 1: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$7 = Lib_TopContext_lookup(arg.h1.h1, top); return ( (sc$$7.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h1.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h1.h1))) + (" not in scope"))), eta)))) : Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Just(sc$$7.h1.h2)) ); }) }; case 0: { const sc$$6 = Prelude_getAt(Prelude_intToNat(arg.h1.h1), arg.h0); if ((sc$$6.tag) == (1)) { return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h1.h0, (("bad index ") + (Prelude_showInt(arg.h1.h1))) + (""))), eta)))) }; } else { switch (sc$$6.h1.h3.h2) { case true: return { tag: 0,  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, sc$$6.h1.h3.h3) }; case false: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h1.h0, (("used erased value ") + (sc$$6.h1.h2)) + (" (FIXME FC may be wrong here)"))), eta)))) }; } } break; } } };
const Lib_Erasure_eraseSpine = ( _$$0, _$$1, _$$2, ty$$3 ) => (bouncer(Lib_Erasure_REC_eraseSpine, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: ty$$3 }));
const Lib_Erasure_REC_eraseSpine = ( arg ) => { if ((arg.h2.tag) == (1)) { if ((arg.h3.tag) == (0)) { if ((arg.h3.h1.tag) == (6)) { switch (arg.h3.h1.h3) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil()), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Just(arg.h3.h1.h5)))) }; case false: { const u = Lib_Types_Erased(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h2.h1.h3)); return { tag: 1,  h0: arg.h0,  h1: Lib_Types_App(arg.h2.h1.h2, arg.h1, u),  h2: arg.h2.h2,  h3: Prelude_Just(arg.h3.h1.h5) }; break; } } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil()), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Nothing()))) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil()), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Nothing()))) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(arg.h1) }; } };
const Lib_Types_UU = ( h0 ) => ({ tag: 5,  h0: h0 });
const Lib_Erasure_doAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseLit(_$$1.h0, eta)), Lib_Erasure_erase(_$$0, _$$1.h1, Prelude_Nil())); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$7 = Lib_TopContext_lookup(_$$1.h0, top); if ((sc$$7.tag) == (0)) { const env$27 = Lib_Erasure_doAlt_piEnv(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$0, sc$$7.h1.h2, _$$1.h1); return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseCons(_$$1.h0, _$$1.h1, eta)), Lib_Erasure_erase(env$27, _$$1.h2, Prelude_Nil())); } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h0))) + (" dcon missing from context"))), eta)))); } }); case 0: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseDefault(eta)), Lib_Erasure_erase(_$$0, _$$1.h0, Prelude_Nil())); } };
const Lib_Erasure_doAlt_piEnv = ( _, _1, _2, _3, _4, _5, _$$6, _$$7, _$$8 ) => (bouncer(Lib_Erasure_REC_doAlt_piEnv, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7,  h8: _$$8 }));
const Lib_Erasure_REC_doAlt_piEnv = ( arg ) => (( (arg.h8.tag) == (1) ? ( (arg.h7.tag) == (6) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: Prelude__$3A$3A_(Prelude__$2C_(arg.h8.h1, Prelude__$2C_(arg.h7.h3, Prelude_Just(arg.h7.h4))), arg.h6),  h7: arg.h7.h5,  h8: arg.h8.h2 } : { tag: 0,  h0: arg.h6 } ) : { tag: 0,  h0: arg.h6 } ));
const Lib_Compile_eraseEntries = ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, _.h2)), ( defs ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$3 ) => (0), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Compile_eraseEntries_go(null, _, eta)), Data_SortedMap_toList(defs))))));
const Data_IORef_primNewIORef = (_, a) => (w) => Prelude_MkIORes([a], w);
const Lib_Compile_getEntries = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookup(_$$1, top); if ((sc$$3.tag) == (1)) { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("bad name ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$0))); } else { switch (sc$$3.h1.h3.tag) { case 5: { const acc = Data_SortedMap_updateMap(sc$$3.h1.h1, sc$$3.h1.h3, _$$0); return Prelude_foldlM(Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Compile_getEntries(eta, eta1))), acc, sc$$3.h1.h3.h2); break; } case 3: { const sc$$12 = Data_SortedMap_lookupMap$27(sc$$3.h1.h1, _$$0); return ( (sc$$12.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_zonk(top1, 0, Prelude_Nil(), sc$$3.h1.h3.h0), ( exp ) => { const acc = Data_SortedMap_updateMap(sc$$3.h1.h1, Lib_Types_Fn(exp), _$$0); return Prelude_foldlM(Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Compile_getEntries(eta, eta1))), acc, Lib_Compile_getNames(exp, Prelude_Nil())); }))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$0) ); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Data_SortedMap_updateMap(_$$1, sc$$3.h1.h3, _$$0)); } } }));
const Lib_Compile_getNames = ( _$$0, _$$1 ) => (bouncer(Lib_Compile_REC_getNames, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Compile_REC_getNames = ( arg ) => { switch (arg.h0.tag) { case 9: return { tag: 1,  h0: arg.h0.h4,  h1: Lib_Compile_getNames(arg.h0.h3, arg.h1) }; case 8: return { tag: 1,  h0: arg.h0.h3,  h1: Lib_Compile_getNames(arg.h0.h2, arg.h1) }; case 7: return { tag: 1,  h0: arg.h0.h1,  h1: Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Compile_getNames_getAltNames(arg.h0, arg.h1, arg.h0.h0, arg.h0.h1, arg.h0.h2, null, eta, eta1))), arg.h1, arg.h0.h2) }; case 6: return { tag: 1,  h0: arg.h0.h5,  h1: Lib_Compile_getNames(arg.h0.h4, Prelude__$3A$3A_(Lib_Common_QN(Lib_Common_primNS, "PiType"), arg.h1)) }; case 4: return { tag: 1,  h0: arg.h0.h2,  h1: Lib_Compile_getNames(arg.h0.h1, arg.h1) }; case 3: return { tag: 1,  h0: arg.h0.h4,  h1: arg.h1 }; case 1: return { tag: 0,  h0: Prelude__$3A$3A_(arg.h0.h1, arg.h1) }; default: return { tag: 0,  h0: arg.h1 }; } };
const Lib_Compile_getNames_getAltNames = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case 2: return Lib_Compile_getNames(_$$7.h1, _$$6); case 1: return Prelude__$3A$3A_(_$$7.h0, Lib_Compile_getNames(_$$7.h2, _$$6)); case 0: return Lib_Compile_getNames(_$$7.h0, _$$6); } };
const Lib_Eval_zonk = ( _$$0, _$$1, _$$2, _$$3 ) => { const env$27 = Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, _$$1, Prelude_Lin()), _$$2); switch (_$$3.tag) { case 11: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Erased(_$$3.h0)); case 10: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lit(_$$3.h0, _$$3.h1)); case 9: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Types_LetRec(_$$3.h0, _$$3.h1, eta, eta1, eta2)))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h3)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h4)); case 8: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (Lib_Types_Let(_$$3.h0, _$$3.h1, eta, eta1))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h3)); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_zonkAlt(_$$0, _$$1, _$$2, eta)), _$$3.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(_$$3.h0, sc$27, alts$27)))))); case 6: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta, eta1))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h4)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h5)); case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_UU(_$$3.h0)); case 4: return Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3, Prelude_Nil()); case 3: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta)), Lib_Eval_zonk(_$$0, (1) + (_$$1), env$27, _$$3.h4)); case 2: return Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3, Prelude_Nil()); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Ref(_$$3.h0, _$$3.h1)); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Bnd(_$$3.h0, _$$3.h1)); } };
const Lib_Eval_zonkApp = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { switch (_$$3.tag) { case 4: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2), ( u$27 ) => (Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3.h1, Prelude__$3A$3A_(u$27, _$$4)))); case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$3.h1), ( meta ) => (( (meta.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(_$$2, eta)), _$$4), ( sp$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("zonk ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(meta.h2))) + (" spine ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), sp$27)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(meta.h2, Prelude__$3C$3E$3C_(Prelude_Lin(), sp$27)), ( foo ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("-> result is ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(foo))) + (""))), ( _1 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Eval_tweakFC(_$$3.h0, eta)), Lib_Eval_quote(_$$1, foo)))))))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Eval_appSpine(_$$3, _$$4)) ))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3), ( t$27 ) => { const sc$$7 = Lib_Eval_zonkApp_inlineDef(_$$0, _$$1, _$$2, _$$3, _$$4, null, t$27); return ( (sc$$7.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(_$$2, eta)), _$$4), ( sp$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$2, sc$$7.h1), ( vtm ) => (Lib_Types_catchError(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(vtm, Prelude__$3C$3E$3C_(Prelude_Lin(), sp$27)), ( foo ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$1, foo), ( t$271 ) => (Lib_Eval_zonk(_$$0, _$$1, _$$2, t$271))))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Eval_appSpine(t$27, _$$4)))))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Eval_appSpine(t$27, _$$4)) ); }); } };
const Lib_Eval_appSpine = ( _$$0, _$$1 ) => (bouncer(Lib_Eval_REC_appSpine, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Eval_REC_appSpine = ( arg ) => (( (arg.h1.tag) == (1) ? { tag: 1,  h0: Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h0), arg.h0, arg.h1.h1),  h1: arg.h1.h2 } : { tag: 0,  h0: arg.h0 } ));
const Lib_Eval_quote = ( lvl$$0, _$$1 ) => { switch (_$$1.tag) { case 10: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lit(_$$1.h0, _$$1.h1)); case 9: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Erased(_$$1.h0)); case 8: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_UU(_$$1.h0)); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(lvl$$0, _$$1.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (lvl$$0), _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (lvl$$0), _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_LetRec(_$$1.h0, _$$1.h1, ty$27, t$27, u$27)))))))); case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(lvl$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (lvl$$0), _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Let(_$$1.h0, _$$1.h1, t$27, u$27)))))); case 5: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(lvl$$0, _$$1.h4), ( a$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, lvl$$0, Prelude_Lin()), _$$1.h5.h0), _$$1.h5.h1), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (lvl$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Pi(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, a$27, tm)))))))); case 4: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, lvl$$0, Prelude_Lin()), _$$1.h4.h0), _$$1.h4.h1), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (lvl$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, tm)))))); case 3: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$1.h1), ( meta ) => (( (meta.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(meta.h2, _$$1.h2), ( eta ) => (Lib_Eval_quote(lvl$$0, eta))) : Lib_Eval_quoteSp(lvl$$0, Lib_Types_Meta(_$$1.h0, _$$1.h1), _$$1.h2) ))); case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(lvl$$0, _$$1.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_quoteAlt(lvl$$0, eta)), _$$1.h2), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(_$$1.h0, sc$27, alts)))))); case 1: return Lib_Eval_quoteSp(lvl$$0, Lib_Types_Ref(_$$1.h0, _$$1.h1), _$$1.h2); case 0: { const sc$$5 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$1.h1, lvl$$0), 0); switch (sc$$5) { case true: return Lib_Eval_quoteSp(lvl$$0, Lib_Types_Bnd(_$$1.h0, ((lvl$$0) - (_$$1.h1)) - (1)), _$$1.h2); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (((("Bad index in quote ") + (Prelude_showInt(_$$1.h1))) + (" depth ")) + (Prelude_showInt(lvl$$0))) + (""))), eta)))); } break; } } };
const Lib_Eval_quoteSp = ( lvl$$0, _$$1, _$$2 ) => (( (_$$2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quoteSp(lvl$$0, _$$1, _$$2.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(lvl$$0, _$$2.h2), ( x$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_App(Lib_Common_emptyFC, t$27, x$27)))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1) ));
const Lib_Eval_quoteAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseDefault(eta)), Lib_Eval_quote(_$$0, _$$1.h0)); case 1: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseLit(_$$1.h0, eta)), Lib_Eval_quote(_$$0, _$$1.h1)); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Lib_Eval_quoteAlt_mkenv(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, null, _$$0, _$$1.h2, _$$1.h1), _$$1.h3), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((Prelude_length$27(_$$1.h1)) + (_$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_CaseCons(_$$1.h0, _$$1.h1, tm)))))); } };
const Lib_Eval_quoteAlt_mkenv = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_Eval_REC_quoteAlt_mkenv, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_Eval_REC_quoteAlt_mkenv = ( arg ) => (( (arg.h9.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: (arg.h7) + (1),  h8: Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, arg.h7, Prelude_Lin()), arg.h8),  h9: arg.h9.h2 } : { tag: 0,  h0: arg.h8 } ));
const Lib_Types_VVar = ( h0, h1, h2 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Eval_eval = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 11: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VErased(_$$1.h0)); case 10: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VLit(_$$1.h0, _$$1.h1)); case 9: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$1.h0, Prelude_length$27(_$$0), Prelude_Lin()), _$$0), _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$1.h0, Prelude_length$27(_$$0), Prelude_Lin()), _$$0), _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VLetRec(_$$1.h0, _$$1.h1, ty$27, t$27, u$27)))))))); case 8: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$1.h0, Prelude_length$27(_$$0), Prelude_Lin()), _$$0), _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VLet(_$$1.h0, _$$1.h1, t$27, u$27)))))); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_unlet(_$$0, sc$27), ( sc$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_forceType(_$$0, sc$271), ( sc$272 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_evalCase(_$$0, sc$272, _$$1.h2), ( $$sc ) => (( ($$sc.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h1), ( vsc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_evalAlt(_$$0, eta)), _$$1.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VCase(_$$1.h0, vsc, alts$27)))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc.h1) ))))))))); case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h4), ( a$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VPi(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, a$27, Lib_Types_MkClosure(_$$0, _$$1.h5))))); case 5: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VU(_$$1.h0)); case 4: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, _$$1.h2), ( u$27 ) => (Lib_Eval_vapp(t$27, u$27))))); case 3: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VLam(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, Lib_Types_MkClosure(_$$0, _$$1.h4))); case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$1.h1), ( meta ) => (( (meta.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(meta.h2) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VMeta(_$$1.h0, _$$1.h1, Prelude_Lin())) ))); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VRef(_$$1.h0, _$$1.h1, Prelude_Lin())); case 0: { const sc$$4 = Prelude_getAt(Prelude_intToNat(_$$1.h1), _$$0); return ( (sc$$4.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (("Bad deBruin index ") + (Prelude_showInt(_$$1.h1))) + (""))), eta)))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$4.h1) ); break; } } };
const Lib_Types_VRef = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_VMeta = ( h0, h1, h2 ) => ({ tag: 3,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_lookupMeta = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$0, top.h5.h0); if ((sc$$4.tag) == (1)) { const sc$$6 = Data_SortedMap_lookupMap$27(_$$0.h0, top.h0); if ((sc$$6.tag) == (1)) { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("missing module: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$0.h0)))) + (""))), eta)))); } else { const sc$$9 = Data_SortedMap_lookupMap$27(_$$0, sc$$6.h1.h2.h0); return ( (sc$$9.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("missing meta: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (""))), eta)))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$9.h1) ); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$4.h1); } }));
const Lib_Types_MkClosure = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Types_VLam = ( h0, h1, h2, h3, h4 ) => ({ tag: 4,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Eval_vapp = ( _$$0, _$$1 ) => { switch (_$$0.tag) { case 4: return Lib_Eval_eval(Prelude__$3A$3A_(_$$1, _$$0.h4.h0), _$$0.h4.h1); case 3: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VMeta(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(_$$0.h2, _$$1))); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VRef(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(_$$0.h2, _$$1))); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VVar(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(_$$0.h2, _$$1))); default: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (((("impossible in vapp ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0))) + (" to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + ("\n"))), eta)))); } };
const Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 10: return Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1); case 9: return "ERASED"; case 8: return "U"; case 7: return (((((((("(%letrec ") + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (" = ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (" in ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + (""); case 6: return (((((("(%let ") + (_$$0.h1)) + (" = ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (" in ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (""); case 5: switch (_$$0.h2) { case 2: return (((((((("(%pi {{") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("}}. ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); case 1: return (((((((("(%pi (") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("). ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); case 0: return (((((((("(%pi {") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("}. ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); } break; case 4: return (((((("(%lam ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" ")) + (Lib_Types_showClosure(_$$0.h4))) + (")"); case 3: return (((("(%meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" [")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(_$$0.h2))))) + (" sp])"); case 2: return (((("(%case ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow_showAlt(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, eta)), _$$0.h2)))) + (")"); case 1: return ( (_$$0.h2.tag) == (0) ? Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1) : (((("(") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$0.h2, Prelude_Nil()))))) + (")") ); case 0: return ( (_$$0.h2.tag) == (0) ? (("%var") + (Prelude_showInt(_$$0.h1))) + ("") : (((("(%var") + (Prelude_showInt(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$0.h2, Prelude_Nil()))))) + (")") ); } };
const Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow_showAlt = ( _, _1, _2, _3, _4, _$$5 ) => { switch (_$$5.tag) { case 2: return (("(%cdef ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5.h0))) + (")"); case 1: return (("(%clit ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5.h1))) + (")"); case 0: return (((((((("(%ccon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h0))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$5.h1)))) + (" [")) + (Prelude_showInt(Prelude_natToInt(Prelude_length(_$$5.h2))))) + (" env] ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$5.h3))) + (""); } };
const Data_SnocList_snoclen = ( _$$1 ) => (Data_SnocList_snoclen_go(null, _$$1, null, _$$1, 0));
const Data_SnocList_snoclen_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Data_SnocList_REC_snoclen_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Data_SnocList_REC_snoclen_go = ( arg ) => (( (arg.h3.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1,  h4: (1) + (arg.h4) } : { tag: 0,  h0: arg.h4 } ));
const Lib_Types_showClosure = ( _$$0 ) => ((((("(%cl [") + (Prelude_showInt(Prelude_natToInt(Prelude_length(_$$0.h0))))) + (" env] ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (")"));
const Lib_Types_VU = ( h0 ) => ({ tag: 8,  h0: h0 });
const Lib_Types_VPi = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: 5,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Types_VCase = ( h0, h1, h2 ) => ({ tag: 2,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Eval_evalAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_VCaseLit(_$$1.h0, eta)), Lib_Eval_eval(_$$0, _$$1.h1)); case 1: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VCaseCons(_$$1.h0, _$$1.h1, _$$0, _$$1.h2)); case 0: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_VCaseDefault(eta)), Lib_Eval_eval(_$$0, _$$1.h0)); } };
const Lib_Types_VCaseDefault = ( h0 ) => ({ tag: 2,  h0: h0 });
const Lib_Types_VCaseCons = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_VCaseLit = ( h0, h1 ) => ({ tag: 1,  h0: h0,  h1: h1 });
const Lib_Eval_evalCase = ( _$$0, _$$1, _$$2 ) => { if ((_$$2.tag) == (1)) { switch (_$$2.h1.tag) { case 1: switch (_$$1.tag) { case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$14 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$1.h1, _$$2.h1.h0); switch (sc$$14) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((((("ECase ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$1.h2, Prelude_Nil()))))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$2.h1.h1)))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$2.h1.h2))) + (""))), ( _ ) => (Lib_Eval_evalCase_pushArgs(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, _$$2.h1.h0, _$$2.h1.h1, _$$2.h1.h2, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$0, Prelude__$3C$3E$3E_(_$$1.h2, Prelude_Nil()), _$$2.h1.h1))); case false: { const sc$$15 = Lib_TopContext_lookup(_$$1.h1, top); return ( (sc$$15.tag) == (0) ? ( (sc$$15.h1.h3.tag) == (2) ? Lib_Eval_evalCase(_$$0, _$$1, _$$2.h2) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) ); break; } } }); case 0: { const sc$$12 = Lib_Eval_lookupVar(_$$0, _$$1.h1); return ( (sc$$12.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) : ( (sc$$12.h1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$12.h1))) + (""))), ( _ ) => { const sc$$19 = (sc$$12.h1.h1) == (_$$1.h1); switch (sc$$19) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(Lib_Types_VVar(sc$$12.h1.h0, sc$$12.h1.h1, sc$$12.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(sc$$12.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))) ) ); break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))); } break; case 0: { if ((_$$1.tag) == (0)) { const sc$$10 = Lib_Eval_lookupVar(_$$0, _$$1.h1); return ( (sc$$10.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) : ( (sc$$10.h1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$10.h1))) + (""))), ( _ ) => { const sc$$17 = (sc$$10.h1.h1) == (_$$1.h1); switch (sc$$17) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(Lib_Types_VVar(sc$$10.h1.h0, sc$$10.h1.h1, sc$$10.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(sc$$10.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))) ) ); } else { return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_Just(eta)), Lib_Eval_eval(_$$0, _$$2.h1.h0)); } break; } default: { if ((_$$1.tag) == (0)) { const sc$$9 = Lib_Eval_lookupVar(_$$0, _$$1.h1); return ( (sc$$9.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) : ( (sc$$9.h1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$9.h1))) + (""))), ( _ ) => { const sc$$16 = (sc$$9.h1.h1) == (_$$1.h1); switch (sc$$16) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(Lib_Types_VVar(sc$$9.h1.h0, sc$$9.h1.h1, sc$$9.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(sc$$9.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))) ) ); } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))); } break; } } } else { if ((_$$1.tag) == (0)) { const sc$$6 = Lib_Eval_lookupVar(_$$0, _$$1.h1); return ( (sc$$6.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) : ( (sc$$6.h1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$6.h1))) + (""))), ( _ ) => { const sc$$13 = (sc$$6.h1.h1) == (_$$1.h1); switch (sc$$13) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(Lib_Types_VVar(sc$$6.h1.h0, sc$$6.h1.h1, sc$$6.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(sc$$6.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))) ) ); } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))); } } };
const Lib_Eval_vappSpine = ( _$$0, _$$1 ) => (( (_$$1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(_$$0, _$$1.h1), ( rest ) => (Lib_Eval_vapp(rest, _$$1.h2))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$0) ));
const Lib_Eval_lookupVar = ( _$$0, _$$1 ) => { const l = Prelude_natToInt(Prelude_length(_$$0)); const sc$$3 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$1, l), 2); switch (sc$$3) { case true: return Prelude_Nothing(); case false: { const sc$$4 = Prelude_getAt(Prelude_intToNat(((l) - (_$$1)) - (1)), _$$0); if ((sc$$4.tag) == (1)) { return Prelude_Nothing(); } else { if ((sc$$4.h1.tag) == (0)) { const sc$$10 = (_$$1) == (sc$$4.h1.h1); switch (sc$$10) { case true: return Prelude_Nothing(); case false: return Prelude_Just(sc$$4.h1); } } else { return Prelude_Just(sc$$4.h1); } } break; } } };
const Lib_Eval_evalCase_pushArgs = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _$$13, _$$14, _$$15 ) => (bouncer(Lib_Eval_REC_evalCase_pushArgs, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: _9,  h10: _10,  h11: _11,  h12: _12,  h13: _$$13,  h14: _$$14,  h15: _$$15 }));
const Lib_Eval_REC_evalCase_pushArgs = ( arg ) => (( (arg.h15.tag) == (1) ? ( (arg.h14.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: arg.h12,  h13: Prelude__$3A$3A_(arg.h14.h1, arg.h13),  h14: arg.h14.h2,  h15: arg.h15.h2 } : { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) } ) : { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(arg.h13, arg.h8), ( t$27 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_Just(eta)), Lib_Eval_vappSpine(t$27, Prelude__$3C$3E$3C_(Prelude_Lin(), arg.h14))))) } ));
const Prelude__$3C$3E$3C_ = ( _$$1, _$$2 ) => (bouncer(Prelude_REC__$3C$3E$3C_, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC__$3C$3E$3C_ = ( arg ) => (( (arg.h2.tag) == (1) ? { tag: 1,  h0: null,  h1: Prelude__$3A$3C_(arg.h1, arg.h2.h1),  h2: arg.h2.h2 } : { tag: 0,  h0: arg.h1 } ));
const Lib_Eval_forceType = ( _$$0, _$$1 ) => (( (_$$1.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$1.h1), ( meta ) => (( (meta.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(meta.h2, _$$1.h2), ( eta ) => (Lib_Eval_forceType(_$$0, eta))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VMeta(_$$1.h0, _$$1.h1, _$$1.h2)) ))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_tryEval(_$$0, _$$1), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Eval_forceType(_$$0, $$sc.h1) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1) ))) ));
const Lib_Eval_tryEval = ( _$$0, _$$1 ) => (( (_$$1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$6 = Lib_TopContext_lookup(_$$1.h1, top); return ( (sc$$6.tag) == (0) ? ( (sc$$6.h1.h3.tag) == (3) ? Lib_Types_catchError(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("app ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$6.h1.h1))) + (" to ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$1.h2, Prelude_Nil()))))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, sc$$6.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("tm is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$6.h1.h3.h0))), Prelude_Lin()))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(vtm, _$$1.h2), ( val ) => { switch (val.tag) { case 7: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case 4: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(val)); } }))))))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("tryEval blocked on undefined ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) ) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("tryEval blocked on undefined ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))) ); }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) ));
const Lib_Types_catchError = ( _$$1, _$$2 ) => (Lib_Types_MkM(( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(_$$1.h1(tc), ( $$sc ) => (( ($$sc.tag) == (1) ? ( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_($$sc.h2.h2, $$sc.h2.h3)), eta)) : Lib_Types__runM(_$$2($$sc.h2))(tc) )), eta)))));
const Lib_Eval_unlet = ( _$$0, _$$1 ) => { if ((_$$1.tag) == (0)) { const sc$$5 = Lib_Eval_lookupVar(_$$0, _$$1.h1); return ( (sc$$5.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1))) : ( (sc$$5.h1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$5.h1))) + (""))), ( _ ) => { const sc$$12 = (sc$$5.h1.h1) == (_$$1.h1); switch (sc$$12) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(Lib_Types_VVar(sc$$5.h1.h0, sc$$5.h1.h1, sc$$5.h1.h2), _$$1.h2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(sc$$5.h1, _$$1.h2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))) ) ); } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1); } };
const Lib_Types_VLet = ( h0, h1, h2, h3 ) => ({ tag: 6,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_VLetRec = ( h0, h1, h2, h3, h4 ) => ({ tag: 7,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_VLit = ( h0, h1 ) => ({ tag: 10,  h0: h0,  h1: h1 });
const Lib_Types_VErased = ( h0 ) => ({ tag: 9,  h0: h0 });
const Lib_Types_Meta = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_Types_Lit = ( h0, h1 ) => ({ tag: 10,  h0: h0,  h1: h1 });
const Lib_Eval_zonkApp_inlineDef = ( _, _1, _2, _3, _4, _5, _$$6 ) => { if ((_$$6.tag) == (1)) { const sc$$9 = Lib_TopContext_lookup(_$$6.h1, _); if ((sc$$9.tag) == (0)) { if ((sc$$9.h1.h3.tag) == (3)) { const sc$$18 = Prelude_elem(Lib_Types_Prelude_Eq$20Lib_Types_EFlag, true, sc$$9.h1.h4); switch (sc$$18) { case true: return Prelude_Just(sc$$9.h1.h3.h0); case false: return Prelude_Nothing(); } } else { return Prelude_Nothing(); } } else { return Prelude_Nothing(); } } else { return Prelude_Nothing(); } };
const Lib_Types_Prelude_Eq$20Lib_Types_EFlag$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case true: switch (_$$0) { case true: return true; default: return false; } break; case false: switch (_$$0) { case false: return true; default: return false; } break; } };
const Lib_Types_Prelude_Eq$20Lib_Types_EFlag = Prelude_MkEq(( eta ) => (( eta1 ) => (Lib_Types_Prelude_Eq$20Lib_Types_EFlag$2C_$3D$3D_(eta, eta1))));
const Lib_Eval_tweakFC = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 11: return Lib_Types_Erased(_$$0); case 10: return Lib_Types_Lit(_$$0, _$$1.h1); case 9: return Lib_Types_LetRec(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case 8: return Lib_Types_Let(_$$0, _$$1.h1, _$$1.h2, _$$1.h3); case 7: return Lib_Types_Case(_$$0, _$$1.h1, _$$1.h2); case 6: return Lib_Types_Pi(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4, _$$1.h5); case 5: return Lib_Types_UU(_$$0); case 4: return Lib_Types_App(_$$0, _$$1.h1, _$$1.h2); case 3: return Lib_Types_Lam(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case 2: return Lib_Types_Meta(_$$0, _$$1.h1); case 1: return Lib_Types_Ref(_$$0, _$$1.h1); case 0: return Lib_Types_Bnd(_$$0, _$$1.h1); } };
const Lib_Eval_zonkBind = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Eval_zonk(_$$0, (1) + (_$$1), Prelude__$3A$3A_(Lib_Types_VVar(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$3), _$$1, Prelude_Lin()), _$$2), _$$3));
const Lib_Eval_zonkAlt = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case 2: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseLit(_$$3.h0, eta)), Lib_Eval_zonkBind(_$$0, _$$1, _$$2, _$$3.h1)); case 1: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseCons(_$$3.h0, _$$3.h1, eta)), Lib_Eval_zonkAlt_go(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, null, _$$1, _$$2, _$$3.h1, _$$3.h2)); case 0: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseDefault(eta)), Lib_Eval_zonkBind(_$$0, _$$1, _$$2, _$$3.h0)); } };
const Lib_Eval_zonkAlt_go = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11 ) => (bouncer(Lib_Eval_REC_zonkAlt_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8,  h9: _$$9,  h10: _$$10,  h11: _$$11 }));
const Lib_Eval_REC_zonkAlt_go = ( arg ) => (( (arg.h10.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: (1) + (arg.h8),  h9: Prelude__$3A$3A_(Lib_Types_VVar(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h11), arg.h8, Prelude_Lin()), arg.h9),  h10: arg.h10.h2,  h11: arg.h11 } : { tag: 0,  h0: Lib_Eval_zonk(arg.h0, arg.h8, arg.h9, arg.h6) } ));
const Lib_TopContext_lookupRaw = ( _$$0, _$$1 ) => { const sc$$3 = Data_SortedMap_lookupMap$27(Lib_Common_QN(_$$1.h3, _$$0), _$$1.h4); return ( (sc$$3.tag) == (1) ? Lib_TopContext_lookupRaw_go(_$$0, _$$1, null, _$$1.h1) : Prelude_Just(sc$$3.h1) ); };
const Lib_TopContext_lookupRaw_go = ( _, _1, _2, _$$3 ) => (bouncer(Lib_TopContext_REC_lookupRaw_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3 }));
const Lib_TopContext_REC_lookupRaw_go = ( arg ) => { if ((arg.h3.tag) == (1)) { const sc$$7 = Data_SortedMap_lookupMap$27(arg.h3.h1, arg.h1.h0); if ((sc$$7.tag) == (1)) { return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 }; } else { const sc$$10 = Data_SortedMap_lookupMap$27(Lib_Common_QN(arg.h3.h1, arg.h0), sc$$7.h1.h1); return ( (sc$$10.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 } : { tag: 0,  h0: Prelude_Just(sc$$10.h1) } ); } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Compile_compile = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$1 = Lib_TopContext_lookupRaw("main", top); return ( (sc$$1.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "No main function found")), eta)))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Compile_process(sc$$1.h1.h1), ( tmp ) => { const exec = Lib_Compile_stmtToDoc(Lib_Compile_JPlain(Lib_Compile_Apply(Lib_Compile_Var(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$1.h1.h1)), Prelude_Nil()))); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_reverse()(Prelude__$3A$3A_(exec, tmp))); }) ); });
const Lib_Common_renderJson = ( _$$0 ) => { switch (_$$0.tag) { case 4: return ("[") + ((Prelude_joinBy(",", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_renderJson(eta)), _$$0.h0))) + ("]")); case 3: return Prelude_showInt(_$$0.h0); case 2: return Prelude_ite(_$$0.h0, "true", "false"); case 1: return Lib_Common_quoteString(_$$0.h0); case 0: return ("{") + ((Prelude_joinBy(",", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_renderJson_renderPair(_$$0, _$$0.h0, null, eta)), _$$0.h0))) + ("}")); } };
const Lib_Common_renderJson_renderPair = ( _, _1, _2, _$$3 ) => ((Lib_Common_quoteString(_$$3.h2)) + ((":") + (Lib_Common_renderJson(_$$3.h3))));
const Prelude_ite = ( _$$1, _$$2, _$$3 ) => { switch (_$$1) { case true: return _$$2; case false: return _$$3; } };
const Main_jsonTopContext_jsonDef = ( _, _$$1 ) => (Lib_Common_JsonObj(Prelude__$3A$3A_(Prelude__$2C_("fc", Lib_Common_Lib_Common_ToJSON$20Lib_Common_FC$2CtoJson(_$$1.h0)), Prelude__$3A$3A_(Prelude__$2C_("name", Lib_Common_JsonStr(_$$1.h1.h1)), Prelude__$3A$3A_(Prelude__$2C_("type", Lib_Common_JsonStr(Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), _$$1.h2))), Prelude_Lin()))), Prelude_Nil())))));
const Lib_Common_JsonStr = ( h0 ) => ({ tag: 1,  h0: h0 });
const Lib_Common_Lib_Common_ToJSON$20Lib_Common_FC$2CtoJson = ( _$$0 ) => (Lib_Common_JsonObj(Prelude__$3A$3A_(Prelude__$2C_("file", Lib_Common_JsonStr(_$$0.h0)), Prelude__$3A$3A_(Prelude__$2C_("line", Lib_Common_JsonInt(_$$0.h1.h0)), Prelude__$3A$3A_(Prelude__$2C_("col", Lib_Common_JsonInt(_$$0.h1.h1)), Prelude__$3A$3A_(Prelude__$2C_("endline", Lib_Common_JsonInt(_$$0.h1.h2)), Prelude__$3A$3A_(Prelude__$2C_("endcol", Lib_Common_JsonInt(_$$0.h1.h3)), Prelude_Nil())))))));
const Lib_Common_JsonInt = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_Common_JsonObj = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_Common_JsonArray = ( h0 ) => ({ tag: 4,  h0: h0 });
const Data_SortedMap_listValues = ( _$$2 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h3), Data_SortedMap_toList(_$$2)));
const Main_jsonTopContext = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const defs = Prelude_Prelude_Monad$20Prelude_List$2Cbind(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( mod ) => (Data_SortedMap_listValues(mod.h1)), Data_SortedMap_listValues(top.h0)), ( _$$1 ) => (_$$1)); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Common_JsonObj(Prelude__$3A$3A_(Prelude__$2C_("context", Lib_Common_JsonArray(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Main_jsonTopContext_jsonDef(null, eta)), defs))), Prelude_Nil()))); });
const Main_processFile = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("*** Process ") + (_$$0)) + (""))), ( _ ) => { const parts = Data_List1_split1(_$$0, "/"); const sc$$3 = Data_List1_unsnoc(parts); let dir; const sc$$8 = Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(Prelude_Prelude_Eq$20Prim_String, sc$$3.h2, Prelude_Nil()); switch (sc$$8) { case true: { dir = "."; break; } case false: { dir = Prelude_joinBy("/", sc$$3.h2); break; } } const sc$$9 = Data_List1_splitFileName(sc$$3.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((((((("") + (dir)) + (" ")) + (sc$$9.h2)) + (" ")) + (sc$$9.h3)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Node_readFile(_$$0)), ( $$sc ) => { if (($$sc.tag) == (1)) { const sc$$20 = Lib_Tokenizer_tokenise(_$$0, $$sc.h2); if ((sc$$20.tag) == (1)) { const sc$$24 = Lib_Parser_Impl_partialParse(_$$0, Lib_Parser_parseModHeader, Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1)))), sc$$20.h2); return ( (sc$$24.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Util_getBaseDir(_$$0, sc$$24.h2.h2.h2, sc$$24.h2.h2.h3), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "Int", Prelude_Nothing())), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "String", Prelude_Nothing())), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "Char", Prelude_Nothing())), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setDef(Lib_Common_QN(Lib_Common_primNS, "PiType"), Lib_Common_emptyFC, Lib_Types_Erased(Lib_Common_emptyFC), Lib_Types_PrimFn("(h0, h1) => ({ tag: \"PiType\", h0, h1 });", (1) + ((1) + (0)), Prelude_Nil()), Prelude_Nil()), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const modules = Data_SortedMap_updateMap(Lib_Common_primNS, Lib_Types_MkModCtx("", top.h4, Lib_Types_MC(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), 0, 0), top.h8), top.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, Prelude__$3A$3A_(Lib_Common_primNS, Prelude_Nil()), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), tc.h5, tc.h6, tc.h7, tc.h8)))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_processModule(Lib_Common_emptyFC, $$sc1.h2, Prelude_Nil(), $$sc1.h3), ( src ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_showErrors(_$$0, src), ( _7 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0))))))))); }))))))))))) : Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(sc$$24.h2.h2), eta)))) ); } else { return Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(sc$$20.h2), eta)))); } } else { return Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_MkFC(_$$0, Lib_Common_MkBounds(0, 0, 0, 0)), (((("error reading ") + (_$$0)) + (": ")) + ($$sc.h2)) + (""))), eta)))); } }))); }));
const Main_showErrors = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, top.h7)), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( _$$5 ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn(Lib_Common_showError(_$$1, _$$5)))), $$sc), ( _ ) => (Node_exitFailure(null, "Compile failed"))) ))))));
const Lib_Common_showError = ( _$$0, _$$1 ) => (( (_$$1.tag) == (1) ? ((((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$1.h0))) + (": Postpone ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (" ")) + (_$$1.h2)) + ("\n")) + (Lib_Common_showError_go(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, 0, Prelude_lines(_$$0))) : ((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$1.h0))) + (": ")) + (_$$1.h1)) + ("\n")) + (Lib_Common_showError_go$27(_$$0, _$$1, _$$1.h0, _$$1.h1, null, 0, Prelude_lines(_$$0))) ));
const Prelude_arrayToList = (a,arr) => {
  let rval = Prelude_Nil()
  for (let i = arr.length - 1;i >= 0; i--) {
    rval = Prelude__$3A$3A_(arr[i], rval)
  }
  return rval
};
const Prelude_lines = (s) => Prelude_arrayToList(null,s.split('\n'));
const Lib_Common_showError_go$27 = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_Common_REC_showError_go$27, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_Common_REC_showError_go$27 = ( arg ) => { if ((arg.h6.tag) == (1)) { const sc$$10 = (arg.h5) == (arg.h2.h1.h0); switch (sc$$10) { case true: { const width = ((arg.h2.h1.h3) - (arg.h2.h1.h1)) + (1); return { tag: 0,  h0: (((((("  ") + (arg.h6.h1)) + ("\n  ")) + (Prelude_replicate(Prelude_intToNat(arg.h2.h1.h1), " "))) + ("")) + (Prelude_replicate(Prelude_intToNat(width), "^"))) + ("\n") }; break; } case false: { const sc$$11 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h2.h1.h0) - (3), arg.h5), 0); switch (sc$$11) { case true: return { tag: 0,  h0: ("  ") + ((arg.h6.h1) + (("\n") + (Lib_Common_showError_go$27(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, (arg.h5) + (1), arg.h6.h2)))) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (arg.h5) + (1),  h6: arg.h6.h2 }; } break; } } } else { return { tag: 0,  h0: "" }; } };
const Lib_Common_showError_go = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_Common_REC_showError_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_Common_REC_showError_go = ( arg ) => { if ((arg.h7.tag) == (1)) { const sc$$11 = (arg.h6) == (arg.h2.h1.h0); switch (sc$$11) { case true: return { tag: 0,  h0: (((("  ") + (arg.h7.h1)) + ("\n  ")) + (Prelude_replicate(Prelude_intToNat(arg.h2.h1.h1), " "))) + ("^\n") }; case false: { const sc$$12 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h2.h1.h0) - (3), arg.h6), 0); switch (sc$$12) { case true: return { tag: 0,  h0: ("  ") + ((arg.h7.h1) + (("\n") + (Lib_Common_showError_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, (arg.h6) + (1), arg.h7.h2)))) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: (arg.h6) + (1),  h7: arg.h7.h2 }; } break; } } } else { return { tag: 0,  h0: "" }; } };
const Main_processModule = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const modns = Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(_$$3.h0, Prelude__$3A$3A_(_$$3.h1, Prelude_Nil())); const name = Prelude_joinBy(".", modns); const sc$$10 = Data_SortedMap_lookupMap(modns, top.h0); return ( (sc$$10.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(Data_SortedMap_updateMap(modns, Lib_Types_emptyModCtx(""), top.h0), tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _ ) => { const fn = (Prelude_joinBy("/", Prelude__$3A$3A_(_$$1, _$$3.h0))) + (("/") + ((_$$3.h1) + (".newt"))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Node_readFile(fn)), ( $$sc ) => { if (($$sc.tag) == (1)) { const sc$$19 = Lib_Tokenizer_tokenise(fn, $$sc.h2); if ((sc$$19.tag) == (1)) { const sc$$23 = Lib_Parser_Impl_partialParse(fn, Lib_Parser_parseModHeader, top.h8, sc$$19.h2); return ( (sc$$23.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("scan imports for module ") + (sc$$23.h2.h2.h3)) + (""))), ( _1 ) => { const ns = Prelude_split(sc$$23.h2.h2.h3, "."); const sc$$41 = Data_List1_unsnoc(Data_List1_split1(sc$$23.h2.h2.h3, ".")); const sc$$46 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$3, Lib_Common_QN(sc$$41.h2, sc$$41.h3)); switch (sc$$46) { case true: { const sc$$47 = Lib_Parser_Impl_partialParse(fn, Lib_Parser_parseImports, sc$$23.h2.h3.h2, sc$$23.h2.h3.h3); return ( (sc$$47.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, sc$$47.h2.h2, ( $$case ) => { const sc$$63 = Data_List1_unsnoc(Data_List1_split1($$case.h1, ".")); const qname = Lib_Common_QN(sc$$63.h2, sc$$63.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(Prelude_Prelude_Eq$20Prim_String, $$case.h1, _$$2), ( _2 ) => (Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (((("import loop ") + (name)) + (" -> ")) + ($$case.h1)) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_processModule($$case.h0, _$$1, Prelude__$3A$3A_(name, _$$2), qname), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_split($$case.h1, ".")))))); }), ( imported ) => { const imported1 = Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(imported, Prelude__$3A$3A_(Lib_Common_primNS, Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Serialize_checksum($$sc.h2)), ( srcSum ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_moduleHash(srcSum, imported1), ( csum ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("module ") + (sc$$23.h2.h2.h3)) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Serialize_loadModule(_$$3, csum), ( $$sc1 ) => { if (($$sc1.tag) == (1)) { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _3 ) => (("MODNS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), modns))))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_parseDecls(fn, top2.h8, sc$$47.h2.h3.h3, Prelude_Lin()), ( $$sc2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top3 ) => { const freshMC = Lib_Types_MC(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), 0, 0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, imported1, Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), modns, Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), freshMC, tc.h6, tc.h7, $$sc2.h3)))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, imported1, ( ns1 ) => { const sc$$80 = Data_SortedMap_lookupMap$27(ns1, top3.h0); return ( (sc$$80.tag) == (0) ? Main_importHints(Data_SortedMap_listValues(sc$$80.h1.h1)) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("namespace ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), ns1)))) + (" missing"))), eta)))) ); }), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _6 ) => ("process Decls")), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Main_processModule_tryProcessDecl(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, null, $$sc.h2, ns, eta)), Lib_Elab_collectDecl($$sc2.h2)), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top4 ) => { const mod = Lib_Types_MkModCtx(csum, top4.h4, top4.h5, top4.h8); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, top4.h7)), ( errors ) => { const sc$$85 = (Prelude_not(Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(Prelude_Prelude_Eq$20Prim_String, _$$2, Prelude_Nil()))) && ((Prelude_length$27(errors)) == (0)); switch (sc$$85) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Serialize_dumpModule(_$$3, $$sc.h2, mod), ( _8 ) => { const modules = Data_SortedMap_updateMap(modns, mod, top4.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, top4.h7)), ( $$sc3 ) => (( ($$sc3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_logMetas(Prelude_reverse()(Data_SortedMap_listValues(top4.h5.h0))), ( _10 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc.h2))) : Node_exitFailure(null, "Compile failed") ))))); }); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0), ( _8 ) => { const modules = Data_SortedMap_updateMap(modns, mod, top4.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Data_IORef_primReadIORef(null, top4.h7)), ( $$sc3 ) => (( ($$sc3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_logMetas(Prelude_reverse()(Data_SortedMap_listValues(top4.h5.h0))), ( _10 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc.h2))) : Node_exitFailure(null, "Compile failed") ))))); }); } }); }))))))))); }))))))); } else { const modules = Data_SortedMap_updateMap(modns, $$sc1.h1, top1.h0); const ops = Data_SortedMap_foldMap(( _$$21 ) => (( _$$31 ) => (_$$21)), top1.h8, Data_SortedMap_toList($$sc1.h1.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, ops)))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc.h2))); } }))))))))); }) : Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$47.h2.h2)) ); break; } default: return Node_exitFailure(null, (((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$23.h2.h2.h2))) + (": module name ")) + (sc$$23.h2.h2.h3)) + (" doesn't match file name ")) + (fn)) + ("")); } }) : Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$23.h2.h2)) ); } else { return Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$19.h2)); } } else { return Node_exitFailure(null, (((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0))) + (": error reading ")) + (fn)) + (": ")) + ($$sc.h2)) + ("")); } }); }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn("") ); }));
const Lib_Types_MkTop = ( h0, h1, h2, h3, h4, h5, h6, h7, h8 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5,  h6: h6,  h7: h7,  h8: h8 });
const Lib_Types_putTop = ( _$$0 ) => (Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Right(Prelude__$2C_(_$$0, 0)), eta)))));
const Lib_ProcessDecl_logMetas = ( _$$0 ) => (bouncer(Lib_ProcessDecl_REC_logMetas, { tag: 1,  h0: _$$0 }));
const Lib_ProcessDecl_REC_logMetas = ( arg ) => { if ((arg.h0.tag) == (1)) { switch (arg.h0.h1.tag) { case 2: return { tag: 1,  h0: arg.h0.h2 }; case 1: return { tag: 1,  h0: arg.h0.h2 }; case 0: switch (arg.h0.h1.h4) { case 1: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(arg.h0.h1.h2.h0, arg.h0.h1.h3), ( ty$27 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), arg.h0.h1.h2.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_dumpEnv(arg.h0.h1.h2), ( env ) => { const msg = (((("") + (env)) + ("\n  -----------\n  ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, ty$27))), Prelude_Lin()))) + (""); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(arg.h0.h1.h0, (("User Hole\n") + (msg)) + ("")), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))); }); }) }; default: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta(arg.h0.h1.h3), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(arg.h0.h1.h2.h0, ty$27), ( tm ) => { const msg = (((((((("Unsolved meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h0.h1.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(arg.h0.h1.h4))) + (" type ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), arg.h0.h1.h2.h2), tm))), Prelude_Lin()))) + (" ")) + (Prelude_showInt(Prelude_length$27(arg.h0.h1.h5)))) + (" constraints"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, arg.h0.h1.h5, ( $$case ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn((((((("  * (m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h0.h1.h1))) + (" (")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_($$case.h2, Prelude_Nil()))))) + (") =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$case.h3))) + ("")))), ( msgs ) => { switch (arg.h0.h1.h4) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(arg.h0.h1.h2.h0, arg.h0.h1.h3), ( x ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(arg.h0.h1.h2.h1, x), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("AUTO ---> ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { if ((ty.tag) == (1)) { const cands = Prelude_fromMaybe(Prelude_Nil(), Data_SortedMap_lookupMap$27(ty.h1, top.h2)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_findMatches(arg.h0.h1.h2, ty, cands), ( matches ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_((((("  ") + (Prelude_showInt(Prelude_length$27(matches)))) + (" Solutions: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), matches)))) + (""), Prelude_Nil())))); } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()); } }))))))), ( sols ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(arg.h0.h1.h0, Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude__$3A$3A_(msg, Prelude_Nil()), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(msgs, sols)))), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()), ( sols ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(arg.h0.h1.h0, Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(Prelude__$3A$3A_(msg, Prelude_Nil()), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(msgs, sols)))), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))))); } }); }))) }; } break; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) }; } };
const Lib_Types_info = ( _$$0, _$$1 ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((((("INFO at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0))) + (": ")) + (_$$1)) + (""))));
const Lib_Elab_findMatches = ( _$$0, _$$1, _$$2 ) => (bouncer(Lib_Elab_REC_findMatches, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_Elab_REC_findMatches = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$10 = Lib_Elab_isCandidate(arg.h1, arg.h2.h1.h3); switch (sc$$10) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const fc = Lib_Types_getValFC(arg.h1); return Lib_Types_catchError(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("TRY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h2.h1.h2))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), arg.h2.h1.h3))), Prelude_Lin()))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (""))), ( _ ) => { const sc$$18 = Lib_Util_splitTele(arg.h2.h1.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_setMetaMode(1), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(arg.h0, Lib_Syntax_RVar(fc, arg.h2.h1.h2.h1), arg.h1), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("Found ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), tm))), Prelude_Lin()))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _3 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(arg.h2.h1.h2, eta)), Lib_Elab_findMatches(arg.h0, arg.h1, arg.h2.h2)))))))))); }), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("No match ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), arg.h2.h1.h3))), Prelude_Lin()))) + (" ")) + (Lib_Common_showError("", err))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _1 ) => (Lib_Elab_findMatches(arg.h0, arg.h1, arg.h2.h2))))))); }) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2 }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()) }; } };
const Lib_Syntax_RVar = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Elab_check = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_forceType(_$$0.h1, _$$2), ( ty$27 ) => { const sc$$4 = Prelude__$2C_(_$$1, ty$27); switch (sc$$4.h2.tag) { case 15: return Lib_Elab_updateRec(_$$0, sc$$4.h2.h0, sc$$4.h2.h1, sc$$4.h2.h2, sc$$4.h3); case 13: return Lib_Elab_checkWhere(_$$0, Lib_Elab_collectDecl(sc$$4.h2.h1), sc$$4.h2.h2, sc$$4.h3); case 12: { const tm$27 = Lib_Syntax_RCase(sc$$4.h2.h0, sc$$4.h2.h1, Prelude__$3A$3A_(Lib_Syntax_MkAlt(Lib_Syntax_RVar(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2.h2), "True"), sc$$4.h2.h2), Prelude__$3A$3A_(Lib_Syntax_MkAlt(Lib_Syntax_RVar(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2.h3), "False"), sc$$4.h2.h3), Prelude_Nil()))); return Lib_Elab_check(_$$0, tm$27, sc$$4.h3); break; } case 11: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(sc$$4.h2.h0, sc$$4.h2.h1), ( stmts$27 ) => (Lib_Elab_check(_$$0, stmts$27, sc$$4.h3))); case 10: return Lib_Elab_freshMeta(_$$0, sc$$4.h2.h0, sc$$4.h3, 1); case 9: return Lib_Elab_freshMeta(_$$0, sc$$4.h2.h0, sc$$4.h3, 0); case 8: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, sc$$4.h2.h1), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta($$sc.h3), ( scty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("SCTM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2), $$sc.h2))), Prelude_Lin()))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("SCTY ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty))) + (""))), ( _1 ) => { const scnm = Lib_Elab_fresh(_$$0, "sc"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, sc$$4.h2.h2, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_mkPat(Prelude__$2C_($$case.h0, 1)), ( pat$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC($$case.h0), Prelude__$3A$3A_(Prelude__$2C_(scnm, pat$27), Prelude_Nil()), Prelude_Nil(), $$case.h1)))))), ( clauses ) => { let ctx$27; const _sc$$22 = Lib_Types_extend(_$$0, scnm, scty); ctx$27 = Lib_Types_MkCtx(_sc$$22.h0, _sc$$22.h1, _sc$$22.h2, _sc$$22.h3, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, sc$$4.h3)), ( tree ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Let(sc$$4.h2.h0, scnm, $$sc.h2, tree)))); }))); }))))))); case 5: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, sc$$4.h2.h2, Lib_Types_VU(Lib_Common_emptyFC)), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, ty$271), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, sc$$4.h2.h3, vty), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, v$27), ( vv ) => { const ctx$27 = Lib_Types_define(_$$0, sc$$4.h2.h1, vv, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(ctx$27, sc$$4.h2.h4, sc$$4.h3), ( sc$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Let(sc$$4.h2.h0, sc$$4.h2.h1, v$27, sc$27)))); }))))))); case 1: return ( (sc$$4.h3.tag) == (5) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((((("icits ") + (sc$$4.h2.h1.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(sc$$4.h2.h1.h2))) + (" ")) + (sc$$4.h3.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(sc$$4.h3.h2))) + (""))), ( _ ) => { const sc$$23 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(sc$$4.h2.h1.h2, sc$$4.h3.h2); switch (sc$$23) { case true: { const $var = Lib_Types_VVar(sc$$4.h2.h0, Prelude_length$27(_$$0.h1), Prelude_Lin()); const ctx$27 = Lib_Types_extend(_$$0, sc$$4.h2.h1.h1, sc$$4.h3.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_($var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( bapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(ctx$27, sc$$4.h2.h2, bapp), ( tm$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(sc$$4.h2.h0, sc$$4.h2.h1.h1, sc$$4.h2.h1.h2, sc$$4.h3.h3, tm$27)))))); break; } case false: { const sc$$24 = Prelude_not(Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(sc$$4.h3.h2, 1)); switch (sc$$24) { case true: { const $var = Lib_Types_VVar(sc$$4.h2.h0, Prelude_length$27(_$$0.h1), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_($var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(sc$$4.h2.h0, sc$$4.h3.h1, sc$$4.h2.h1.h2, sc$$4.h3.h3, sc)))))); break; } case false: return Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$4.h2.h0, (((("Icity issue checking ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" at ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), eta)))); } break; } } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_prvalCtx(_$$0, sc$$4.h3), ( pty ) => (Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$4.h2.h1.h0, (("Expected pi type, got ") + (pty)) + (""))), eta)))))) ); default: { if ((sc$$4.h3.tag) == (5)) { switch (sc$$4.h3.h2) { case 2: { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("XXX edge case add auto lambda {") + (sc$$4.h3.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3.h4))) + ("} to ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" "))), ( _ ) => { const $var = Lib_Types_VVar(sc$$4.h3.h0, Prelude_length$27(_$$0.h1), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_($var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_logM(2, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_prvalCtx(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), ty$271), ( pty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn((("XXX ty' is ") + (pty$27)) + (""))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), sc$$4.h3.h1, 2, sc$$4.h3.h3, sc)))))))); }); break; } case 0: { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("XXX edge case add implicit lambda {") + (sc$$4.h3.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3.h4))) + ("} to ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" "))), ( _ ) => { const $var = Lib_Types_VVar(sc$$4.h3.h0, Prelude_length$27(_$$0.h1), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_($var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_logM(2, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_prvalCtx(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), ty$271), ( pty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn((("XXX ty' is ") + (pty$27)) + (""))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), sc$$4.h3.h1, 0, sc$$4.h3.h3, sc)))))))); }); break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, sc$$4.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((((("INFER ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" to (")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, $$sc1.h2))), Prelude_Lin()))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc1.h3))) + (") expect ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), _$$0, $$sc1.h3, sc$$4.h3), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc1.h2))))); }))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, sc$$4.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((((("INFER ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" to (")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, $$sc1.h2))), Prelude_Lin()))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc1.h3))) + (") expect ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), _$$0, $$sc1.h3, sc$$4.h3), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn($$sc1.h2))))); }))); } break; } } }));
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case 15: return _$$0.h0; case 14: return _$$0.h0; case 13: return _$$0.h0; case 12: return _$$0.h0; case 11: return _$$0.h0; case 10: return _$$0.h0; case 9: return _$$0.h0; case 8: return _$$0.h0; case 7: return _$$0.h0; case 6: return _$$0.h0; case 5: return _$$0.h0; case 4: return _$$0.h0; case 3: return _$$0.h0; case 2: return _$$0.h0; case 1: return _$$0.h0; case 0: return _$$0.h0; } };
const Lib_Elab_unifyCatch = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_catchError(Lib_Elab_unify(_$$1.h1, false, _$$2, _$$3), ( err ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("fail ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$1.h0, _$$2), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$1.h0, _$$3), ( b ) => { const msg = (((((("unification failure: ") + (Lib_Types_errorMsg(err))) + ("\n  failed to unify ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, a))), Prelude_Lin()))) + ("\n             with ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, b))), Prelude_Lin()))) + ("\n  "); return Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, msg)), eta)))); }))))); }), ( res ) => (( (res.h0.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("fail with constraints ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), res.h0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$1.h0, _$$2), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$1.h0, _$$3), ( b ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$1.h2); const msg = (((("unification failure\n  failed to unify ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, a))), Prelude_Lin()))) + ("\n             with ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, b))), Prelude_Lin()))) + (""); const msg1 = (msg) + ((("\nconstraints ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), res.h0)))) + ("")); return Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, msg1)), eta)))); }))))) ))));
const Prelude_MkShow = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Lib_Types_Prelude_Show$20Lib_Types_Val = Prelude_MkShow(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)));
const Prelude_Prelude_Show$20Prim_Int$2Cshow = ( eta ) => (Prelude_showInt(eta));
const Prelude_Prelude_Show$20Prim_Int = Prelude_MkShow(Prelude_Prelude_Show$20Prim_Int$2Cshow);
const Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow = ( _$$2, _$$3, _$$4 ) => (("(") + ((Prelude_show(_$$2)(_$$4.h2)) + ((", ") + ((Prelude_show(_$$3)(_$$4.h3)) + (")")))));
const Prelude_show = ( _$$1 ) => (_$$1.h1);
const Lib_Elab_unify = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("Unify lvl ") + (Prelude_showInt(Prelude_natToInt(Prelude_length(_$$0))))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("  ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((("  =?= ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta(_$$2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta(_$$3), ( eta ) => (Lib_Eval_unlet(_$$0, eta))), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((("forced ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(t$27))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((("  =?= ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(u$27))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("env ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _$$0)))) + (""))), ( _5 ) => { const l = Prelude_length$27(_$$0); switch (_$$1) { case true: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta_unifyPattern(_$$0, _$$1, _$$2, _$$3, null, null, null, null, null, null, t$27, u$27); case false: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_$$0, _$$1, _$$2, _$$3, null, null, null, null, null, t$27, u$27); } }))))))))))))))));
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10 ) => { if ((_$$10.tag) == (3)) { if ((_$$9.tag) == (3)) { const sc$$17 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$9.h1, _$$10.h1); switch (sc$$17) { case true: return Lib_Elab_unifySpine(_, _1, Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$9.h1, _$$10.h1), _$$9.h2, _$$10.h2); case false: { const sc$$18 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_Prelude_Ord$20Prelude_Nat$2Ccompare(Data_SnocList_snoclen(_$$9.h2), Data_SnocList_snoclen(_$$10.h2)), 0); switch (sc$$18) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_, _$$10.h1, _$$10.h2, Lib_Types_VMeta(_$$9.h0, _$$9.h1, _$$9.h2)), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_, _$$9.h1, _$$9.h2, Lib_Types_VMeta(_$$10.h0, _$$10.h1, _$$10.h2)), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); } break; } } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_, _$$10.h1, _$$10.h2, _$$9), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); } } else { return ( (_$$9.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_, _$$9.h1, _$$9.h2, _$$10), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))) : Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam(_, _1, _2, _3, _4, _5, _6, _7, _$$9, _$$10) ); } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => { if ((_$$9.tag) == (4)) { if ((_$$8.tag) == (4)) { const fresh = Lib_Types_VVar(_$$8.h0, Prelude_length$27(_), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$8.h4.h0), _$$8.h4.h1), ( vappt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$9.h4.h0), _$$9.h4.h1), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(fresh, _), _1, vappt, vappt$27))))); } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => ((("ETA ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), ( _8 ) => { const fresh = Lib_Types_VVar(_$$9.h0, Prelude_length$27(_), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vapp(_$$8, fresh), ( vappt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$9.h4.h0), _$$9.h4.h1), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(fresh, _), _1, vappt, vappt$27))))); }); } } else { return ( (_$$8.tag) == (4) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => ((("ETA' ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$9))) + (""))), ( _8 ) => { const fresh = Lib_Types_VVar(_$$8.h0, Prelude_length$27(_), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$8.h4.h0), _$$8.h4.h1), ( appt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vapp(_$$9, fresh), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(fresh, _), _1, appt, vappt$27))))); }) : Lib_Elab_unify_unifyRest_unifyRef_unifyVar(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9) ); } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => { if ((_$$8.tag) == (0)) { if ((_$$7.tag) == (0)) { const sc$$15 = (_$$7.h1) == (_$$8.h1); switch (sc$$15) { case true: return Lib_Elab_unifySpine(_, _1, (_$$7.h1) == (_$$8.h1), _$$7.h2, _$$8.h2); case false: return Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$7.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))); } } else { return ( (_$$8.h2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_tryEval(_, _$$7), ( vt ) => (( (vt.tag) == (1) ? Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$8.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))) : Lib_Elab_unify(_, _1, vt.h1, _$$8) ))) : Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8) ); } } else { return ( (_$$7.tag) == (0) ? ( (_$$7.h2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_tryEval(_, _$$8), ( vu ) => (( (vu.tag) == (1) ? Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$7.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))) : Lib_Elab_unify(_, _1, _$$7, vu.h1) ))) : Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8) ) : Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8) ); } };
const Lib_Elab_unify_unifyRest_unifyRef = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (( (_$$7.tag) == (1) ? ( (_$$6.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_tryEval(_, _$$6), ( $$sc ) => (( ($$sc.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_tryEval(_, _$$7), ( $$sc1 ) => { if (($$sc1.tag) == (1)) { const sc$$20 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$6.h1, _$$7.h1); switch (sc$$20) { case true: return Lib_Elab_unifySpine(_, _1, Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$6.h1, _$$7.h1), _$$6.h2, _$$7.h2); case false: return Lib_Types_MkM(( _6 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$6.h0, (((("vref mismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), eta)))); } } else { return Lib_Elab_unify(_, _1, _$$6, $$sc1.h1); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((((("tryEval ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h1))) + (""))), ( _6 ) => (Lib_Elab_unify(_, _1, $$sc.h1, _$$7))) ))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((((("expand ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= %ref ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$7.h1))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookup(_$$7.h1, top); return ( (sc$$13.tag) == (0) ? ( (sc$$13.h1.h3.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$13.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(vtm, _$$7.h2), ( appvtm ) => (Lib_Elab_unify(_, _1, _$$6, appvtm))))) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$7.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" [no Fn]"))), eta)))) ) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$7.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" [no Fn]"))), eta)))) ); }))) ) : ( (_$$6.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((((((("expand %ref ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$6.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$6.h2, Prelude_Nil()))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookup(_$$6.h1, top); return ( (sc$$13.tag) == (0) ? ( (sc$$13.h1.h3.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$13.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(vtm, _$$6.h2), ( tmsp ) => (Lib_Elab_unify(_, _1, tmsp, _$$7))))) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$6.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" [no Fn] =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), eta)))) ) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$6.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" [no Fn] =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), eta)))) ); }))) : Lib_Elab_unify_unifyRest(_, _1, _2, _3, _4, _$$6, _$$7) ) ));
const Lib_Elab_unify_unifyRest = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => { switch (_$$6.tag) { case 10: { if ((_$$5.tag) == (10)) { const sc$$11 = Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(_$$5.h1, _$$6.h1); switch (sc$$11) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral); case false: return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$5.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$5.h1))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$6.h1))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _)))) + (""))), eta)))); } break; } case 8: return ( (_$$5.tag) == (8) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _)))) + (""))), eta)))) ); case 5: { if ((_$$5.tag) == (5)) { const fresh = Lib_Types_VVar(_$$5.h0, Prelude_length$27(_), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$5.h5.h0), _$$5.h5.h1), ( xb ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(fresh, _$$6.h5.h0), _$$6.h5.h1), ( xb$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_(eta, eta1))), Lib_Elab_unify(_, _1, _$$5.h4, _$$6.h4)), Lib_Elab_unify(Prelude__$3A$3A_(fresh, _), _1, xb, xb$27)))))); } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _)))) + (""))), eta)))); } break; } default: return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), _)))) + (""))), eta)))); } };
const Lib_Types_getValFC = ( _$$0 ) => { switch (_$$0.tag) { case 10: return _$$0.h0; case 9: return _$$0.h0; case 8: return _$$0.h0; case 7: return _$$0.h0; case 6: return _$$0.h0; case 5: return _$$0.h0; case 4: return _$$0.h0; case 3: return _$$0.h0; case 2: return _$$0.h0; case 1: return _$$0.h0; case 0: return _$$0.h0; } };
const Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_ = ( _$$0, _$$1 ) => (Lib_Elab_MkResult(Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(_$$0.h0, _$$1.h0)));
const Lib_Elab_MkResult = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral = Lib_Elab_MkResult(Prelude_Nil());
const Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 2: return ( (_$$0.tag) == (2) ? (_$$0.h0) == (_$$1.h0) : false ); case 1: return ( (_$$0.tag) == (1) ? (_$$0.h0) == (_$$1.h0) : false ); case 0: return ( (_$$0.tag) == (0) ? (_$$0.h0) == (_$$1.h0) : false ); default: return false; } };
const Lib_Elab_unifySpine = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { switch (_$$2) { case true: return ( (_$$3.tag) == (1) ? ( (_$$4.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (( eta1 ) => (Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_(eta, eta1))), Lib_Elab_unify(_$$0, _$$1, _$$3.h2, _$$4.h2)), Lib_Elab_unifySpine(_$$0, _$$1, true, _$$3.h1, _$$4.h1)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "meta spine length mismatch")), eta)))) ) : ( (_$$4.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_MkResult(Prelude_Nil())) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "meta spine length mismatch")), eta)))) ) ); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "unify failed at head")), eta)))); } };
const Lib_Elab_solve = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$1), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((((((("SOLVE ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow($$sc.h4))) + (" lvl ")) + (Prelude_showInt(Prelude_length$27(_$$0)))) + (" sp ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$2, Prelude_Nil()))))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => { const size = Prelude_length(Prelude_filter(( x ) => (Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_(x, false)), $$sc.h2.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((((((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" size is ")) + (Prelude_showInt(Prelude_natToInt(size)))) + (" sps ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(_$$2))))) + (""))), ( _1 ) => { const sc$$15 = Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_(Data_SnocList_snoclen(_$$2), size); switch (sc$$15) { case true: { const l = Prelude_length$27(_$$0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((("meta ") + (Lib_Types_Prelude_Show$20Lib_Types_MetaEntry$2Cshow($$sc))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_invert(l, _$$2), ( ren ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(l, _$$3), ( hack ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0, hack), ( t ) => (Lib_Types_catchError(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$1, ren, l, t), ( tm ) => { const tm1 = Lib_Elab_lams(Data_SnocList_snoclen(_$$2), Prelude_reverse()(Lib_Elab__boundNames($$sc.h2)), tm); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), tm1), ( soln ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateMeta(_$$1, ( $$case ) => { switch ($$case.tag) { case 2: return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" out of scope"))), eta)))); case 1: return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E($$case.h0, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" already solved! [solve2]"))), eta)))); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Solved($$case.h0, $$case.h1, soln)); } }), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_maybeCheck(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for_(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, $$sc.h5, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(soln, $$case.h2), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((((("discharge l=") + (Prelude_showInt(Prelude_length$27($$case.h1)))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$case.h3))) + (""))), ( _4 ) => (Lib_Elab_unify($$case.h1, false, val, $$case.h3))))))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top1 ) => { switch (top1.h5.h3) { case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((("check autos depending on ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" ")) + (Prelude_debugStr(null, top1.h5.h3))) + (""))), ( _5 ) => (Lib_Elab_checkAutos($$sc.h1, top1.h5.h1))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); } })))), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0))))))))); }), ( $$case ) => (( ($$case.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((((("CONSTRAINT2 m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$2, Prelude_Nil()))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(t))) + (""))), ( _3 ) => (Lib_Elab_addConstraint(_$$0, _$$1, _$$2, t))) : Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left($$case), eta)))) ))))))))))); break; } default: { const l = Prelude_length$27(_$$0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((((((("meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" (")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (") applied to ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(_$$2))))) + (" args instead of ")) + (Prelude_showInt(Prelude_natToInt(size)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((((("CONSTRAINT m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$2, Prelude_Nil()))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Elab_addConstraint(_$$0, _$$1, _$$2, _$$3))))); break; } } }); }) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$3), (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" already solved! [solve]"))), eta)))) ))));
const Lib_Elab_addConstraint = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { switch (top.h5.h3) { case 0: return Lib_Elab_updateMeta(_$$1, ( $$case ) => { switch ($$case.tag) { case 2: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" out of scope"))), eta)))); case 1: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E($$case.h0, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h1))) + (" already solved [addConstraint]"))), eta)))); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("Add constraint m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$2, Prelude_Nil()))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Unsolved($$case.h0, $$case.h1, $$case.h2, $$case.h3, $$case.h4, Prelude__$3A$3A_(Lib_Types_MkMc(Lib_Types_getValFC(_$$3), _$$0, _$$2, _$$3), $$case.h5))))); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); } }));
const Lib_Types_MkMc = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_Unsolved = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Elab_updateMeta = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$0, top.h5.h0); return ( (sc$$4.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(_$$1(sc$$4.h1), ( me ) => { const autos = ( (me.tag) == (1) ? Prelude_filter(( _$$3 ) => (Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$0, _$$3))), top.h5.h1) : top.h5.h1 ); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(Data_SortedMap_updateMap(_$$0, me, top.h5.h0), autos, top.h5.h2, top.h5.h3), tc.h6, tc.h7, tc.h8)))); }) ); }));
const Lib_Types_MC = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Elab_checkAutos = ( _$$0, _$$1 ) => (( (_$$1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$1.h1), ( $$sc ) => { if (($$sc.tag) == (0)) { switch ($$sc.h4) { case 2: { if (($$sc.h3.tag) == (1)) { const sc$$18 = Lib_Elab_checkAutos_checkMeta(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, $$sc.h3.h2); switch (sc$$18) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_trySolveAuto($$sc), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); } break; } default: return Lib_Elab_checkAutos(_$$0, _$$1.h2); } } else { return Lib_Elab_checkAutos(_$$0, _$$1.h2); } }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) ));
const Lib_Elab_trySolveAuto = ( _$$0 ) => { if ((_$$0.tag) == (0)) { switch (_$$0.h4) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("TRYAUTO solving ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_$$0.h2.h0, _$$0.h3), ( x ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h2.h1, x), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("AUTO ---> ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_contextMatches(_$$0.h2, ty), ( $$sc ) => { if (($$sc.tag) == (1)) { return ( ($$sc.h2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h2.h1, $$sc.h1.h2), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("LOCAL SOLUTION ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), $$sc.h1.h2))), Prelude_Lin()))) + (" evaled to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _2 ) => { const sp = Lib_Elab_makeSpine(_$$0.h2.h0, _$$0.h2.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_$$0.h2.h1, _$$0.h1, sp, val), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ("<-- AUTO LOCAL")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => (((">UNIFY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(Lib_Types_getValFC(ty), _$$0.h2, ty, $$sc.h1.h3), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _7 ) => ((("<UNIFY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (""))), ( _7 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true))))))))))); }))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("LOCAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$5 ) => (Lib_Types_pprint$27(0, Prelude_Nil(), _$$5.h2)), $$sc)))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false))) ); } else { if ((ty.tag) == (1)) { const cands = Prelude_fromMaybe(Prelude_Nil(), Data_SortedMap_lookupMap$27(ty.h1, top.h2)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_findMatches(_$$0.h2, ty, cands), ( $$sc1 ) => (( ($$sc1.tag) == (1) ? ( ($$sc1.h2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0.h2, Lib_Syntax_RVar(_$$0.h0, $$sc1.h1.h1), ty), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h2.h1, tm), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("SOLUTION ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), tm))), Prelude_Lin()))) + (" evaled to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((("GLOBAL SOLUTION ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _3 ) => { const sp = Lib_Elab_makeSpine(_$$0.h2.h0, _$$0.h2.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$0.h1), ( $$sc2 ) => (( ($$sc2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solve(_$$0.h2.h1, _$$0.h1, sp, val), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true) ))); }))))))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("GLOBAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), $$sc1)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false))) ) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("GLOBAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), $$sc1)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false))) ))); } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false); } } }))))))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false); } };
const Lib_Elab_makeSpine = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_makeSpine, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_makeSpine = ( arg ) => { if ((arg.h1.tag) == (1)) { switch (arg.h1.h1) { case true: return { tag: 1,  h0: (arg.h0) - (1),  h1: arg.h1.h2 }; case false: return { tag: 0,  h0: Prelude__$3A$3C_(Lib_Elab_makeSpine((arg.h0) - (1), arg.h1.h2), Lib_Types_VVar(Lib_Common_emptyFC, (arg.h0) - (1), Prelude_Lin())) }; } } else { return { tag: 0,  h0: Prelude_Lin() }; } };
const Lib_Elab_contextMatches = ( _$$0, _$$1 ) => (Lib_Elab_contextMatches_go(_$$0, _$$1, null, Prelude_zip(_$$0.h1, _$$0.h2)));
const Prelude_zip = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? ( (_$$2.tag) == (1) ? Prelude__$3A$3A_(Prelude__$2C_(_$$2.h1, _$$3.h1), Prelude_zip(_$$2.h2, _$$3.h2)) : Prelude_Nil() ) : Prelude_Nil() ));
const Lib_Elab_contextMatches_go = ( _, _1, _2, _$$3 ) => (( (_$$3.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$3.h1.h3.h3), ( type ) => { const sc$$16 = Lib_Elab_isCandidate(_1, type); switch (sc$$16) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_catchError(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((((("TRY context ") + (_$$3.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _.h2), type))), Prelude_Lin()))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(Lib_Types_getValFC(_1), _, _1, _$$3.h1.h3.h3), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$3.h1.h2), ( tm ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(Prelude__$2C_(tm, _$$3.h1.h3.h3), eta)), Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2)))))))))), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((((("No match ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_1))) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _.h2), type))), Prelude_Lin()))) + (" ")) + (Lib_Common_showError("", err))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _4 ) => (Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2))))))))); case false: return Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2); } }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()) ));
const Lib_Elab_isCandidate = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_isCandidate, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_isCandidate = ( arg ) => { switch (arg.h1.tag) { case 6: switch (arg.h1.h2) { case 1: return { tag: 0,  h0: false }; default: return { tag: 1,  h0: arg.h0,  h1: arg.h1.h5 }; } break; case 4: return { tag: 1,  h0: arg.h0,  h1: arg.h1.h1 }; case 1: return ( (arg.h0.tag) == (1) ? { tag: 0,  h0: Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h0.h1, arg.h1.h1) } : { tag: 0,  h0: false } ); default: return { tag: 0,  h0: false }; } };
const Lib_Elab_checkAutos_checkMeta = ( _, _1, _2, _3, _4, _5, _$$6 ) => (bouncer(Lib_Elab_REC_checkAutos_checkMeta, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6 }));
const Lib_Elab_REC_checkAutos_checkMeta = ( arg ) => { if ((arg.h6.tag) == (1)) { if ((arg.h6.h2.tag) == (3)) { const sc$$13 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h6.h2.h1, arg.h0); switch (sc$$13) { case true: return { tag: 0,  h0: true }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; } } else { return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; } } else { return { tag: 0,  h0: false }; } };
const Prelude_for_ = ( _$$2, appf$$3, _$$6, _$$7 ) => (Prelude__$3C$2A$3E_(appf$$3)(null)(null)(Prelude_return(appf$$3)(null)(( _$$3 ) => (0)))(Prelude_traverse(_$$2)(null)(null)(null)(appf$$3)(_$$7)(_$$6)));
const Lib_Elab_maybeCheck = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { switch (top.h5.h3) { case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_setMetaMode(2), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(_$$0, ( _1 ) => (Lib_Elab_setMetaMode(1))))); case 0: return _$$0; } }));
const Lib_Elab_setMetaMode = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(tc.h5.h0, tc.h5.h1, tc.h5.h2, _$$0), tc.h6, tc.h7, tc.h8)))));
const Lib_Types_Solved = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab__boundNames = ( _$$0 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h3), Prelude_filter(( x ) => (Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_(x.h2, false)), Prelude_zip(_$$0.h3, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0.h2)))));
const Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case true: switch (_$$0) { case true: return true; default: return false; } break; case false: switch (_$$0) { case false: return true; default: return false; } break; } };
const Lib_Elab_lams = ( _$$0, _$$1, _$$2 ) => { switch (_$$0) { case 0: return _$$2; default: { const x = (_$$0) - (1); return ( (_$$1.tag) == (1) ? Lib_Types_Lam(Lib_Common_emptyFC, _$$1.h1, 1, true, Lib_Elab_lams(x, _$$1.h2, _$$2)) : Lib_Types_Lam(Lib_Common_emptyFC, (("arg_") + (Prelude_showInt(Prelude_natToInt(x)))) + (""), 1, true, Lib_Elab_lams(x, Prelude_Nil(), _$$2)) ); break; } } };
const Lib_Elab_rename = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case 10: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lit(_$$3.h0, _$$3.h1)); case 9: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Erased(_$$3.h0)); case 8: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_UU(_$$3.h0)); case 7: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, Prelude__$3A$3A_(_$$2, _$$1), (1) + (_$$2), _$$3.h3), ( val$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, Prelude__$3A$3A_(_$$2, _$$1), (1) + (_$$2), _$$3.h4), ( body$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_LetRec(_$$3.h0, _$$3.h1, ty$27, val$27, body$27)))))))); case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h2), ( val$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, Prelude__$3A$3A_(_$$2, _$$1), (1) + (_$$2), _$$3.h3), ( body$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Let(_$$3.h0, _$$3.h1, val$27, body$27)))))); case 5: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h4), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, _$$2, Prelude_Lin()), _$$3.h5.h0), _$$3.h5.h1), ( tmapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, Prelude__$3A$3A_(_$$2, _$$1), (1) + (_$$2), tmapp), ( scope$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, ty$27, scope$27)))))))); case 4: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$3.h0, _$$2, Prelude_Lin()), _$$3.h4.h0), _$$3.h4.h1), ( tapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, Prelude__$3A$3A_(_$$2, _$$1), (1) + (_$$2), tapp), ( scope ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, scope)))))); case 3: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("rename Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" spine ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(_$$3.h2, Prelude_Nil()))))) + (""))), ( _ ) => { const sc$$8 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$3.h1, _$$0); switch (sc$$8) { case true: return Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$3.h0, "meta occurs check")), eta)))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$3.h1), ( meta$27 ) => (( (meta$27.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("rename: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" is solved"))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(meta$27.h2, _$$3.h2), ( val$27 ) => (Lib_Elab_rename(_$$0, _$$1, _$$2, val$27))))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("rename: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" is unsolved"))), ( _1 ) => (Lib_Types_catchError(Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Meta(_$$3.h0, _$$3.h1), _$$3.h2), ( err ) => (Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_Postpone(_$$3.h0, _$$3.h1, Lib_Types_errorMsg(err))), eta)))))))) ))); } }); case 2: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$3.h0, "Case in solution")), eta)))); case 1: return Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Ref(_$$3.h0, _$$3.h1), _$$3.h2); case 0: { const sc$$7 = Prelude_findIndex$27(( _$$11 ) => ((_$$3.h1) == (_$$11)), _$$1); return ( (sc$$7.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$3.h0, (((("scope/skolem thinger VVar ") + (Prelude_showInt(_$$3.h1))) + (" ren ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(Prelude_Prelude_Show$20Prim_Int$2Cshow, _$$1)))) + (""))), eta)))) : Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Bnd(_$$3.h0, sc$$7.h1), _$$3.h2) ); break; } } };
const Lib_Elab_renameSpine = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (( (_$$4.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_rename(_$$0, _$$1, _$$2, _$$4.h2), ( xtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_renameSpine(_$$0, _$$1, _$$2, _$$3, _$$4.h1), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_App(Lib_Common_emptyFC, xs$27, xtm)))))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$3) ));
const Prelude_findIndex$27 = ( _$$1, _$$2 ) => (Prelude_findIndex$27_go(null, _$$1, _$$2, null, _$$2, 0));
const Prelude_findIndex$27_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Prelude_REC_findIndex$27_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_findIndex$27_go = ( arg ) => { if ((arg.h4.tag) == (1)) { const sc$$9 = arg.h1(arg.h4.h1); switch (sc$$9) { case true: return { tag: 0,  h0: Prelude_Just(arg.h5) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: (arg.h5) + (1) }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Common_Postpone = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_invert = ( _$$0, _$$1 ) => (Lib_Elab_invert_go(_$$0, _$$1, null, _$$1, Prelude_Nil()));
const Lib_Elab_invert_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Elab_REC_invert_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Elab_REC_invert_go = ( arg ) => { if ((arg.h3.tag) == (1)) { if ((arg.h3.h2.tag) == (0)) { if ((arg.h3.h2.h2.tag) == (0)) { const sc$$12 = Prelude_elem(Prelude_Prelude_Eq$20Prim_Int, arg.h3.h2.h1, arg.h4); switch (sc$$12) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("") + (Prelude_showInt(arg.h3.h2.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(Prelude_Prelude_Show$20Prim_Int$2Cshow, arg.h4)))) + (""))), ( _ ) => (Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h3.h2.h0, (("non-linear pattern: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), Prelude__$3C$3E$3E_(arg.h1, Prelude_Nil()))))) + (""))), eta)))))) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1,  h4: Prelude__$3A$3A_(arg.h3.h2.h1, arg.h4) }; } } else { return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("non-variable in pattern ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3.h2))) + (""))), eta)))) }; } } else { return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("non-variable in pattern ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3.h2))) + (""))), eta)))) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_reverse()(arg.h4)) }; } };
const Prelude_Prelude_Eq$20Prim_Int$2C_$3D$3D_ = ( _$$0, _$$1 ) => ((_$$0) == (_$$1));
const Prelude_Prelude_Eq$20Prim_Int = Prelude_MkEq(( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_Int$2C_$3D$3D_(eta, eta1))));
const Lib_Types_Prelude_Show$20Lib_Types_MetaEntry$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 2: return "OutOfScope"; case 1: return (((("Solved ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (""); case 0: return (((((((((((("Unsolved ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0.h0))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(_$$0.h4))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_BD$2Cshow(eta)), _$$0.h2.h3)))) + (" cs ")) + (Prelude_showInt(Prelude_natToInt(Prelude_length(_$$0.h5))))) + (""); } };
const Lib_Types_Prelude_Show$20Lib_Types_BD$2Cshow = ( _$$0 ) => { switch (_$$0) { case true: return "def"; case false: return "bnd"; } };
const Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow = ( _$$0 ) => { switch (_$$0) { case 2: return "Auto"; case 1: return "User"; case 0: return "Normal"; } };
const Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_ = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_ = ( arg ) => { switch (arg.h1) { case 0: switch (arg.h0) { case 0: return { tag: 0,  h0: true }; default: return { tag: 0,  h0: false }; } break; default: { const x = (arg.h1) - (1); switch (arg.h0) { case 0: return { tag: 0,  h0: false }; default: { const x1 = (arg.h0) - (1); return { tag: 1,  h0: x1,  h1: x }; break; } } break; } } };
const Prelude_Prelude_Ord$20Prelude_Nat$2Ccompare = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_Prelude_Ord$20Prelude_Nat$2Ccompare, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_Prelude_Ord$20Prelude_Nat$2Ccompare = ( arg ) => { switch (arg.h1) { case 0: switch (arg.h0) { case 0: return { tag: 0,  h0: 1 }; default: return { tag: 0,  h0: 2 }; } break; default: { const x = (arg.h1) - (1); switch (arg.h0) { case 0: return { tag: 0,  h0: 0 }; default: { const x1 = (arg.h0) - (1); return { tag: 1,  h0: x1,  h1: x }; break; } } break; } } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta_unifyPattern = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => { if ((_$$11.tag) == (0)) { if ((_$$10.tag) == (0)) { const sc$$18 = (_$$10.h1) == (_$$11.h1); switch (sc$$18) { case true: return Lib_Elab_unifySpine(_, _1, (_$$10.h1) == (_$$11.h1), _$$10.h2, _$$11.h2); case false: { const sc$$19 = Prelude__$2C_(_$$10.h2, _$$11.h2); if ((sc$$19.h2.tag) == (0)) { if ((sc$$19.h3.tag) == (0)) { const sc$$26 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$10.h1, _$$11.h1), 0); switch (sc$$26) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_MkResult(Prelude__$3A$3A_(Prelude__$2C_(_$$10.h1, _$$11), Prelude_Nil()))); case false: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_MkResult(Prelude__$3A$3A_(Prelude__$2C_(_$$11.h1, _$$10), Prelude_Nil()))); } } else { return Lib_Types_MkM(( _10 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$10.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$10))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$11))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _10 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$10.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$10))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$11))) + (""))), eta)))); } break; } } } else { return ( (_$$11.h2.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_MkResult(Prelude__$3A$3A_(Prelude__$2C_(_$$11.h1, _$$10), Prelude_Nil()))) : Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11) ); } } else { return ( (_$$10.tag) == (0) ? ( (_$$10.h2.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_MkResult(Prelude__$3A$3A_(Prelude__$2C_(_$$10.h1, _$$11), Prelude_Nil()))) : Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11) ) : Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11) ); } };
const Lib_Elab_forceMeta = ( _$$0 ) => (( (_$$0.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(_$$0.h1), ( meta ) => (( (meta.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_vappSpine(meta.h2, _$$0.h2), ( eta ) => (Lib_Elab_forceMeta(eta))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VMeta(_$$0.h0, _$$0.h1, _$$0.h2)) ))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$0) ));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 15: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("RUpdateRec", Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_UpdateClause$2Cshow(eta)), _$$0.h1)), Prelude__$3A$3A_(Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, _$$0.h2), Prelude_Nil()))))) + (")")); case 14: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("RAs", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")); case 13: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Where", Prelude__$3A$3A_("FIXME", Prelude_Nil())))) + (")")); case 12: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("If", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude_Nil())))))) + (")")); case 11: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("DO", Prelude__$3A$3A_("FIXME", Prelude_Nil())))) + (")")); case 10: return "?"; case 9: return "_"; case 8: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Case", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_RCaseAlt$2Cshow(eta)), _$$0.h2)), Prelude_Nil()))))) + (")")); case 7: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("RLit", Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1), Prelude_Nil())))) + (")")); case 6: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("RAnn", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")); case 5: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Let", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(" : ", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(" = ", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude__$3A$3A_(" in ", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h4), Prelude_Nil())))))))))) + (")")); case 4: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Pi", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude_Nil())))))) + (")")); case 3: return "U"; case 2: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("App", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h3), Prelude_Nil())))))) + (")")); case 1: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Lam", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")); case 0: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("RVar", Prelude__$3A$3A_(_$$0.h1, Prelude_Nil())))) + (")")); } };
const Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow = ( _$$0 ) => (("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("BI", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h2), Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3), Prelude_Nil())))))) + (")")));
const Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow = ( _$$0 ) => { switch (_$$0) { case 2: return "Auto"; case 1: return "Explicit"; case 0: return "Implicit"; } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_RCaseAlt$2Cshow = ( _$$0 ) => (("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("MkAlt", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h0), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude_Nil()))))) + (")")));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw = Prelude_MkShow(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(eta)));
const Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow = ( _$$1, _$$2 ) => (( (_$$2.tag) == (1) ? "Nothing" : "Just {show a}" ));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_UpdateClause$2Cshow = ( _$$0 ) => (( (_$$0.tag) == (1) ? ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("ModifyField", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")) : ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("AssignField", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")) ));
const Lib_Elab_insert = ( ctx$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta(_$$2), ( ty$27 ) => { if ((ty$27.tag) == (5)) { switch (ty$27.h2) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(ctx$$0, Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), ty$27.h4, 2), ( m ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("INSERT Auto ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), ctx$$0.h2), m))), Prelude_Lin()))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty$27.h4))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("TM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), ctx$$0.h2), _$$1))), Prelude_Lin()))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(ctx$$0.h1, m), ( mv ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(mv, ty$27.h5.h0), ty$27.h5.h1), ( bapp ) => (Lib_Elab_insert(ctx$$0, Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), _$$1, m), bapp))))))))))); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(ctx$$0, Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), ty$27.h4, 0), ( m ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("INSERT ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), ctx$$0.h2), m))), Prelude_Lin()))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty$27.h4))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("TM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), ctx$$0.h2), _$$1))), Prelude_Lin()))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(ctx$$0.h1, m), ( mv ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(mv, ty$27.h5.h0), ty$27.h5.h1), ( bapp ) => (Lib_Elab_insert(ctx$$0, Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), _$$1, m), bapp))))))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1, ty$27)); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$1, ty$27)); } }));
const Lib_Elab_freshMeta = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("fresh meta ") + (Prelude_showInt(top.h5.h2))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (" (")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(_$$3))) + (")"))), ( _ ) => { const qn = Lib_Common_QN(top.h3, (("$m") + (Prelude_showInt(top.h5.h2))) + ("")); const newmeta = Lib_Types_Unsolved(_$$1, qn, _$$0, _$$2, _$$3, Prelude_Nil()); let autos; switch (_$$3) { case 2: { autos = Prelude__$3A$3A_(qn, top.h5.h1); break; } default: { autos = top.h5.h1; break; } } return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(Data_SortedMap_updateMap(qn, newmeta, top.h5.h0), autos, (1) + (top.h5.h2), top.h5.h3), tc.h6, tc.h7, tc.h8)))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_freshMeta_applyBDs(_$$0, _$$1, _$$2, _$$3, null, 0, Lib_Types_Meta(_$$1, qn), _$$0.h3)))); }))));
const Lib_Elab_freshMeta_applyBDs = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => (bouncer(Lib_Elab_REC_freshMeta_applyBDs, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6,  h7: _$$7 }));
const Lib_Elab_REC_freshMeta_applyBDs = ( arg ) => { if ((arg.h7.tag) == (1)) { switch (arg.h7.h1) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (1) + (arg.h5),  h6: arg.h6,  h7: arg.h7.h2 }; case false: return { tag: 0,  h0: Lib_Types_App(Lib_Common_emptyFC, Lib_Elab_freshMeta_applyBDs(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, (1) + (arg.h5), arg.h6, arg.h7.h2), Lib_Types_Bnd(Lib_Common_emptyFC, arg.h5)) }; } } else { return { tag: 0,  h0: arg.h6 }; } };
const Lib_Elab_infer = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 15: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, "I can't infer record updates")), eta)))); case 14: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, "@ can only be used in patterns")), eta)))); case 9: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, ty), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h0, vty, 0), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(tm, vty)))))))); case 7: switch (_$$1.h1.tag) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_primType(_$$1.h0, Lib_Elab_charType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Lit(_$$1.h0, Lib_Types_LChar(_$$1.h1.h0)), ty)))); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_primType(_$$1.h0, Lib_Elab_intType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Lit(_$$1.h0, Lib_Types_LInt(_$$1.h1.h0)), ty)))); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_primType(_$$1.h0, Lib_Elab_stringType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Lit(_$$1.h0, Lib_Types_LString(_$$1.h1.h0)), ty)))); default: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1), (("Implement infer ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$1))) + (""))), eta)))); } break; case 6: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(_$$1.h0)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, ty), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h1, vty), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(tm, vty)))))))); case 5: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(Lib_Common_emptyFC)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, ty$27), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h3, vty), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, v$27), ( vv ) => { const ctx$27 = Lib_Types_define(_$$0, _$$1.h1, vv, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(ctx$27, _$$1.h4), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Let(_$$1.h0, _$$1.h1, v$27, $$sc.h2), $$sc.h3)))); }))))))); case 4: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(_$$1.h1.h0)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, ty$27), ( vty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_extend(_$$0, _$$1.h1.h1, vty$27), _$$1.h3, Lib_Types_VU(_$$1.h1.h0)), ( ty2$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Pi(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, ty$27, ty2$27), Lib_Types_VU(_$$1.h1.h0))))))))); case 3: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_UU(_$$1.h0), Lib_Types_VU(_$$1.h0))); case 2: switch (_$$1.h3) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(2, Prelude__$2C_($$sc.h2, $$sc.h3))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { if ((tty$27.tag) == (5)) { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(tty$27.h4, tty$27.h5)); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0)), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, true, a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(1, Prelude__$2C_($$sc1.h2, $$sc1.h3))))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { if ((tty$27.tag) == (5)) { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(tty$27.h4, tty$27.h5)); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0)), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, true, a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(0, Prelude__$2C_($$sc.h2, $$sc.h3))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { if ((tty$27.tag) == (5)) { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(tty$27.h4, tty$27.h5)); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0)), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, true, a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); } break; case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_freshMeta(_$$0, _$$1.h1.h0, Lib_Types_VU(Lib_Common_emptyFC), 0), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => { const ctx$27 = Lib_Types_extend(_$$0, _$$1.h1.h1, a); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_infer(ctx$27, _$$1.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("make lam for ") + (_$$1.h1.h1)) + (" scope ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0.h2), $$sc.h2))), Prelude_Lin()))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote((1) + (_$$0.h0), $$sc.h3), ( tyb ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Lam(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, $$sc.h2), Lib_Types_VPi(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, a, Lib_Types_MkClosure(_$$0.h1, tyb)))))))))); }); case 0: return Lib_Elab_infer_go(_$$0, _$$1, _$$1.h0, _$$1.h1, null, 0, _$$0.h2); default: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1), (("Implement infer ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$1))) + (""))), eta)))); } };
const Lib_Elab_infer_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_Elab_REC_infer_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_Elab_REC_infer_go = ( arg ) => { if ((arg.h6.tag) == (1)) { const sc$$14 = (arg.h6.h1.h2) == (arg.h3); switch (sc$$14) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Bnd(arg.h2, arg.h5), arg.h6.h1.h3)) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (arg.h5) + (1),  h6: arg.h6.h2 }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$9 = Lib_TopContext_lookupRaw(arg.h3, top); return ( (sc$$9.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h2, (("") + (arg.h3)) + (" not in scope"))), eta)))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$9.h1.h1))) + (" as ")) + (Lib_Types_Prelude_Show$20Lib_Types_Def$2Cshow(sc$$9.h1.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$9.h1.h2), ( vty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Lib_Types_Ref(arg.h2, sc$$9.h1.h1), vty)))))) ); }) }; } };
const Lib_Types_Prelude_Show$20Lib_Types_Def$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 6: return (("PrimOp ") + (_$$0.h0)) + (""); case 5: return (((((("PrimFn ") + (_$$0.h0)) + (" ")) + (Prelude_showInt(Prelude_natToInt(_$$0.h1)))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), _$$0.h2)))) + (""); case 4: return "PrimTCon"; case 3: return (("Fn ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h0))) + (""); case 2: return (((((((("DCon ") + (Prelude_showInt(Prelude_natToInt(_$$0.h0)))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(eta)), _$$0.h2)))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h3))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_ConInfo$2Cshow(_$$0.h1))) + (""); case 1: return (("TCon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), _$$0.h1)))) + (""); case 0: return "axiom"; } };
const Lib_Types_Prelude_Show$20Lib_Types_ConInfo$2Cshow = ( _$$0 ) => { switch (_$$0) { case 5: return "[F]"; case 4: return "[T]"; case 3: return "[E]"; case 2: return "[Z]"; case 1: return "[S]"; case 0: return ""; } };
const Lib_Types_extend = ( _$$0, _$$1, _$$2 ) => (Lib_Types_MkCtx((1) + (_$$0.h0), Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, _$$0.h0, Prelude_Lin()), _$$0.h1), Prelude__$3A$3A_(Prelude__$2C_(_$$1, _$$2), _$$0.h2), Prelude__$3A$3A_(false, _$$0.h3), _$$0.h4));
const Lib_Types_MkCtx = ( h0, h1, h2, h3, h4 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case 2: switch (_$$0) { case 2: return true; default: return false; } break; case 1: switch (_$$0) { case 1: return true; default: return false; } break; case 0: switch (_$$0) { case 0: return true; default: return false; } break; } };
const Lib_Types_define = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_MkCtx((1) + (_$$0.h0), Prelude__$3A$3A_(_$$2, _$$0.h1), Prelude__$3A$3A_(Prelude__$2C_(_$$1, _$$3), _$$0.h2), Prelude__$3A$3A_(true, _$$0.h3), _$$0.h4));
const Lib_Types_LString = ( h0 ) => ({ tag: 0,  h0: h0 });
const Lib_Elab_stringType = Lib_Common_QN(Lib_Common_primNS, "String");
const Lib_Elab_primType = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookup(_$$1, top); return ( (sc$$3.tag) == (0) ? ( (sc$$3.h1.h3.tag) == (4) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_VRef(_$$0, sc$$3.h1.h1, Prelude_Lin())) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, (("Primitive type ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" not in scope"))), eta)))) ) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, (("Primitive type ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" not in scope"))), eta)))) ); }));
const Lib_Elab_intType = Lib_Common_QN(Lib_Common_primNS, "Int");
const Lib_Types_LChar = ( h0 ) => ({ tag: 2,  h0: h0 });
const Lib_Elab_charType = Lib_Common_QN(Lib_Common_primNS, "Char");
const Lib_Eval_prvalCtx = ( ctx$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(ctx$$0.h0, _$$1), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), ctx$$0.h2), tm))), Prelude_Lin())))));
const Lib_Types_logM = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, top.h6), 2)), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(_$$1, ( msg ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn(msg)))))))));
const Lib_Elab_MkProb = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Elab_buildTree = ( _$$0, _$$1 ) => { if ((_$$1.h0.tag) == (1)) { if ((_$$1.h0.h1.h2.tag) == (1)) { if ((_$$1.h1.tag) == (5)) { const l = Prelude_length$27(_$$0.h1); const nm = Lib_Elab_fresh(_$$0, _$$1.h1.h1); const ctx$27 = Lib_Types_extend(_$$0, nm, _$$1.h1.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_introClause(nm, _$$1.h1.h2, eta)), _$$1.h0), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$1.h0.h1.h0, l, Prelude_Lin()), _$$1.h1.h5.h0), _$$1.h1.h5.h1), ( vb ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_Lam(_$$1.h0.h1.h0, nm, _$$1.h1.h2, _$$1.h1.h3, eta)), Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, vb))))))); } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0.h1.h0, (("Extra pattern variables ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(eta)), _$$1.h0.h1.h2)))) + (""))), eta)))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("buildTree ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$1.h0.h1.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$1.h0.h1.h3))) + (""))), ( _ ) => { const sc$$13 = Lib_Elab_findSplit(_$$1.h0.h1.h1); return ( (sc$$13.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((((((("SPLIT on ") + (sc$$13.h1.h2)) + (" because ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3)))) + (""))), ( _1 ) => { const sc$$21 = Lib_Elab_lookupName(_$$0, sc$$13.h1.h2); return ( (sc$$21.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_unlet(_$$0.h1, sc$$21.h1.h3), ( eta ) => (Lib_Eval_forceType(_$$0.h1, eta))), ( scty$27 ) => (( (scty$27.tag) == (3) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_lookupMeta(scty$27.h1), ( meta ) => { switch (meta.tag) { case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(scty$27); case 1: return Lib_Eval_forceType(_$$0.h1, scty$27); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos, ( _2 ) => (Lib_Eval_forceType(_$$0.h1, scty$27))); } }), ( scty$271 ) => { switch (sc$$13.h1.h3.tag) { case 3: { const tyname = Lib_Elab_litTyName(sc$$13.h1.h3.h1); return ( (scty$271.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(scty$271.h1, tyname)), ( _2 ) => (Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))) ); break; } case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("EXP ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_getConstructors(_$$0, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), scty$271), ( cons ) => { const matched = Lib_Elab_matchedConstructors(sc$$13.h1.h2, _$$1.h0); const matched$27 = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h3), matched); const sc$$40 = Prelude_partition(( _$$5 ) => (Prelude_elem(Lib_Common_Prelude_Eq$20Lib_Common_QName, _$$5.h2, matched$27)), cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_filterM(( eta ) => (Lib_Elab_checkCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$40.h3), ( miss$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, matched, ( $$case ) => { const sc$$52 = Prelude_elem(Lib_Common_Prelude_Eq$20Lib_Common_QName, $$case.h3, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), cons)); switch (sc$$52) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); case false: return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E($$case.h2, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h3))) + (" not a constructor for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (""))), eta)))); } }), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((((((("CONS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), cons))))) + (" matched ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_FC, Lib_Common_Prelude_Show$20Lib_Common_QName, eta)), matched)))) + (" miss ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), sc$$40.h3)))) + (" miss' ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), miss$27)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$40.h2), ( alts ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("GOTALTS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Lib_Types_Prelude_Show$20Lib_Types_CaseAlt, eta)), alts)))) + (""))), ( _5 ) => { const alts$27 = Prelude_mapMaybe(( _$$11 ) => (_$$11), alts); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(alts$27)) == (0), ( _6 ) => (Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (("no alts for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), eta)))))), ( _6 ) => (( (miss$27.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_mapMaybe(( _$$11 ) => (_$$11), alts))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildDefault(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), miss$27)), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(alts$27, Prelude__$3A$3A_($$sc, Prelude_Nil())))))) ))); }))))))))); }))); default: return Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), (("Internal error - tried to split on ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (""))), eta)))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(scty$27), ( scty$271 ) => { switch (sc$$13.h1.h3.tag) { case 3: { const tyname = Lib_Elab_litTyName(sc$$13.h1.h3.h1); return ( (scty$271.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(scty$271.h1, tyname)), ( _2 ) => (Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))) ); break; } case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("EXP ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_getConstructors(_$$0, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), scty$271), ( cons ) => { const matched = Lib_Elab_matchedConstructors(sc$$13.h1.h2, _$$1.h0); const matched$27 = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h3), matched); const sc$$40 = Prelude_partition(( _$$5 ) => (Prelude_elem(Lib_Common_Prelude_Eq$20Lib_Common_QName, _$$5.h2, matched$27)), cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_filterM(( eta ) => (Lib_Elab_checkCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$40.h3), ( miss$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, matched, ( $$case ) => { const sc$$52 = Prelude_elem(Lib_Common_Prelude_Eq$20Lib_Common_QName, $$case.h3, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), cons)); switch (sc$$52) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); case false: return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E($$case.h2, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h3))) + (" not a constructor for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (""))), eta)))); } }), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((((((("CONS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), cons))))) + (" matched ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_FC, Lib_Common_Prelude_Show$20Lib_Common_QName, eta)), matched)))) + (" miss ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), sc$$40.h3)))) + (" miss' ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), miss$27)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$40.h2), ( alts ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("GOTALTS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Lib_Types_Prelude_Show$20Lib_Types_CaseAlt, eta)), alts)))) + (""))), ( _5 ) => { const alts$27 = Prelude_mapMaybe(( _$$11 ) => (_$$11), alts); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(alts$27)) == (0), ( _6 ) => (Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$13.h1.h3.h0, (("no alts for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), eta)))))), ( _6 ) => (( (miss$27.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_mapMaybe(( _$$11 ) => (_$$11), alts))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildDefault(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), miss$27)), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(alts$27, Prelude__$3A$3A_($$sc, Prelude_Nil())))))) ))); }))))))))); }))); default: return Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), (("Internal error - tried to split on ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (""))), eta)))); } }) ))) : Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h0.h1.h0, (("Internal Error: can't find ") + (sc$$13.h1.h2)) + (" in environment"))), eta)))) ); }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((("checkDone ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$1.h0.h1.h1)))) + (""))), ( _1 ) => (Lib_Elab_checkDone(_$$0, _$$1.h0.h1.h1, _$$1.h0.h1.h3, _$$1.h1))) ); }); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "no clauses")), eta)))); } };
const Lib_Elab_checkDone = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Elab_REC_checkDone, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Elab_REC_checkDone = ( arg ) => { if ((arg.h1.tag) == (1)) { switch (arg.h1.h1.h3.tag) { case 2: return { tag: 1,  h0: arg.h0,  h1: arg.h1.h2,  h2: arg.h2,  h3: arg.h3 }; case 0: { const ctx = Lib_Types_MkCtx(arg.h0.h0, arg.h0.h1, Lib_Elab_checkDone_rename(arg.h0, arg.h1, arg.h2, arg.h3, arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h1.h0, arg.h1.h1.h1, arg.h1.h1.h2, arg.h1.h1.h3, arg.h1.h1.h3.h0, arg.h1.h1.h3.h1, arg.h1.h1.h3.h2, null, arg.h0.h2), arg.h0.h3, arg.h0.h4); return { tag: 1,  h0: ctx,  h1: arg.h1.h2,  h2: arg.h2,  h3: arg.h3 }; break; } default: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(arg.h1.h1.h3), (((("stray constraint ") + (arg.h1.h1.h2)) + (" /? ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(arg.h1.h1.h3))) + (""))), eta)))) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("DONE-> check body ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h2))) + (" at ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_logM(2, Lib_Elab_showCtx(arg.h0)), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, arg.h0.h1, ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(Prelude_length$27(arg.h0.h1), val), ( ty ) => (Lib_Eval_eval(arg.h0.h1, ty))))), ( env$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, arg.h0.h2, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(Prelude_length$27(env$27), $$case.h3), ( nty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(env$27, nty), ( ty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_($$case.h2, ty$27)))))))), ( types$27 ) => { const ctx = Lib_Types_MkCtx(arg.h0.h0, env$27, types$27, arg.h0.h3, arg.h0.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ("AFTER")), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_logM(2, Lib_Elab_showCtx(ctx)), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(Prelude_length$27(ctx.h1), arg.h3), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(ctx.h1, ty), ( ty1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((("check at ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty1))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(ctx, arg.h2, ty1), ( got ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("DONE<- got ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), ctx.h2), got))), Prelude_Lin()))) + (""))), ( _5 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(got))))))))))))))); }))))))) }; } };
const Lib_Elab_showCtx = ( _$$0 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$5 ) => (Prelude_joinBy("\n", Prelude_reverse()(_$$5))), Lib_Elab_showCtx_isVar_go(_$$0, null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0.h2), 0, Prelude_reverse()(Prelude_zip(_$$0.h1, _$$0.h2)), Prelude_Nil())));
const Lib_Elab_showCtx_isVar_go = ( _, _1, _2, _$$3, _$$4, _$$5, _$$6 ) => { if ((_$$5.tag) == (1)) { const sc$$18 = Lib_Elab_showCtx_isVar(_, _1, _$$4, _$$5.h1.h2); switch (sc$$18) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( tty ) => (Lib_Elab_showCtx_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_((((("  ") + (_$$5.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tty))), Prelude_Lin()))) + (""), _$$6)))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h2), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( tty ) => (Lib_Elab_showCtx_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_((((((("  ") + (_$$5.h1.h3.h2)) + (" = ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tm))), Prelude_Lin()))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tty))), Prelude_Lin()))) + (""), _$$6)))))); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$6); } };
const Lib_Elab_showCtx_isVar = ( _, _1, _$$2, _$$3 ) => (( (_$$3.tag) == (0) ? ( (_$$3.h2.tag) == (0) ? (_$$2) == (_$$3.h1) : false ) : false ));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 3: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PatLit", Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1), Prelude_Nil())))) + (")")); case 2: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PatWild", Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude_Nil())))) + (")")); case 1: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PatCon", Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h2), Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(eta)), _$$0.h3)), Prelude__$3A$3A_(Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Prelude_Prelude_Show$20Prim_String, _$$0.h4), Prelude_Nil()))))))) + (")")); case 0: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PatVar", Prelude__$3A$3A_(Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude__$3A$3A_(_$$0.h2, Prelude_Nil()))))) + (")")); } };
const Prelude_Prelude_Show$20Prim_String = Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)));
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case 3: return _$$0.h0; case 2: return _$$0.h0; case 1: return _$$0.h0; case 0: return _$$0.h0; } };
const Lib_Elab_checkDone_rename = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15 ) => { if ((_$$15.tag) == (1)) { const sc$$23 = (_$$15.h1.h2) == (_9); switch (sc$$23) { case true: return Prelude__$3A$3A_(Prelude__$2C_(_13, _$$15.h1.h3), _$$15.h2); case false: return Prelude__$3A$3A_(Prelude__$2C_(_$$15.h1.h2, _$$15.h1.h3), Lib_Elab_checkDone_rename(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15.h2)); } } else { return Prelude_Nil(); } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern = Prelude_MkShow(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(eta)));
const Lib_Elab_buildDefault = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { const defclauses = Prelude_filter(( eta ) => (Lib_Elab_buildDefault_applied_isDefault(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(defclauses)) == (0), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildDefault_applied(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), _$$4), ( missing ) => (Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$2, (("missing cases: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), missing)))) + (""))), eta)))))))), ( _ ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Types_CaseDefault(eta)), Lib_Elab_buildTree(_$$0, Lib_Elab_MkProb(defclauses, _$$1.h1))))); };
const Lib_Elab_buildDefault_applied = ( _, _1, _2, _3, _4, _5, _$$6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$9 = Lib_TopContext_lookup(_$$6, top); return ( (sc$$9.tag) == (0) ? ( (sc$$9.h1.h3.tag) == (2) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Elab_buildDefault_applied_go(_, _1, _2, _3, _4, _5, _$$6, null, _$$6.h1, sc$$9.h1.h2)) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$6.h1) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$6.h1) ); }));
const Lib_Elab_buildDefault_applied_go = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (bouncer(Lib_Elab_REC_buildDefault_applied_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8,  h9: _$$9 }));
const Lib_Elab_REC_buildDefault_applied_go = ( arg ) => { if ((arg.h9.tag) == (6)) { switch (arg.h9.h2) { case 1: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: (("") + (arg.h8)) + (" _"),  h9: arg.h9.h5 }; default: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9.h5 }; } } else { return { tag: 0,  h0: arg.h8 }; } };
const Lib_Elab_buildDefault_applied_isDefault = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => { const sc$$8 = Prelude_find(( _$$5 ) => ((_3) == (_$$5.h2)), _$$7.h1); if ((sc$$8.tag) == (1)) { return true; } else { switch (sc$$8.h1.h3.tag) { case 2: return true; case 0: return true; default: return false; } } };
const Lib_Types_Prelude_Show$20Lib_Types_CaseAlt$2Cshow = ( eta ) => (Lib_Types_showCaseAlt(eta));
const Lib_Types_Prelude_Show$20Lib_Types_CaseAlt = Prelude_MkShow(Lib_Types_Prelude_Show$20Lib_Types_CaseAlt$2Cshow);
const Lib_Elab_buildCase = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((((("CASE ") + (_$$2)) + (" match ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2), _$$4.h3.h3))), Prelude_Lin()))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), _$$4.h3.h3), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_extendPi(_$$0, vty, Prelude_Lin(), Prelude_Lin()), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _1 ) => ((((("unify dcon cod with scrut\n  ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + ("\n  ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_catchError(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_Just(eta)), Lib_Elab_unify($$sc.h2.h1, true, $$sc.h3.h2, _$$3)), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg(err))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))), ( $$sc1 ) => (( ($$sc1.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("scrut ") + (_$$2)) + (" constrained to ")) + (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Lib_Types_Prelude_Show$20Lib_Types_Val, Lib_Elab_lookupDef(_$$0, _$$2)))) + (""))), ( _2 ) => { if ((_$$3.tag) == (1)) { const sc$$44 = Lib_Elab_lookupDef(_$$0, _$$2); if ((sc$$44.tag) == (0)) { if ((sc$$44.h1.tag) == (1)) { const sc$$50 = Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$44.h1.h1, _$$4.h2)); switch (sc$$50) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because ")) + (_$$2)) + (" forced to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$44.h1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((("case ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" dotted ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$44.h1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_(Prelude_length($$sc.h3.h3.h2), Data_SnocList_snoclen(sc$$44.h1.h2))), ( _4 ) => (Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (((("") + (Prelude_showInt(Prelude_natToInt(Prelude_length($$sc.h3.h3.h2))))) + (" vars /= ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(sc$$44.h1.h2))))) + (""))), eta)))))), ( _4 ) => { const lvl = (Prelude_length$27($$sc.h2.h1)) - (Prelude_length$27($$sc.h3.h3.h2)); const scons = Lib_Elab_buildCase_constrainSpine(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, lvl, Prelude__$3C$3E$3E_(sc$$44.h1.h2, Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateContext($$sc.h2, scons), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow(eta)), $$sc.h3.h3.h2)))) + (") clauses were"))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _7 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_mapMaybe(( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => ("and now:")), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, clauses, ( x ) => (Lib_Types_log(2, ( _9 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(clauses)) == (0), ( _10 ) => (Lib_Types_MkM(( _11 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))); }))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_tryError(Lib_Elab_unify($$sc.h2.h1, true, $$sc.h3.h2, _$$3)), ( $$sc2 ) => { if (($$sc2.tag) == (1)) { const sc$$52 = Prelude_findIndex$27(( _$$5 ) => ((_$$2) == (_$$5.h2)), $$sc.h2.h2); if ((sc$$52.tag) == (1)) { return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (("") + (_$$2)) + (" not is scope?"))), eta)))); } else { const lvl = ((Prelude_length$27($$sc.h2.h1)) - (sc$$52.h1)) - (1); const scon = Prelude__$2C_(lvl, Lib_Types_VRef(_$$0.h4, _$$4.h2, $$sc.h3.h3.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((("scty ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((("UNIFY results ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc2.h2.h0)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("before types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc.h2.h2)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((("before env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), $$sc.h2.h1)))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _7 ) => ((("SC CONSTRAINT: ") + (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, scon))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateContext($$sc.h2, Prelude__$3A$3A_(scon, $$sc2.h2.h0)), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => ((("context types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), ctx$27.h2)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _9 ) => ((("context env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), ctx$27.h1)))) + (""))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _10 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _11 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow(eta)), $$sc.h3.h3.h2)))) + (") clauses were"))), ( _11 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _12 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _12 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_mapMaybe(( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _13 ) => ("and now:")), ( _13 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, clauses, ( x ) => (Lib_Types_log(2, ( _14 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _14 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(clauses)) == (0), ( _15 ) => (Lib_Types_MkM(( _16 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _15 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))))))))))))))))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))); } }); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_tryError(Lib_Elab_unify($$sc.h2.h1, true, $$sc.h3.h2, _$$3)), ( $$sc2 ) => { if (($$sc2.tag) == (1)) { const sc$$50 = Prelude_findIndex$27(( _$$5 ) => ((_$$2) == (_$$5.h2)), $$sc.h2.h2); if ((sc$$50.tag) == (1)) { return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (("") + (_$$2)) + (" not is scope?"))), eta)))); } else { const lvl = ((Prelude_length$27($$sc.h2.h1)) - (sc$$50.h1)) - (1); const scon = Prelude__$2C_(lvl, Lib_Types_VRef(_$$0.h4, _$$4.h2, $$sc.h3.h3.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((("scty ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((("UNIFY results ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc2.h2.h0)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("before types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc.h2.h2)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((("before env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), $$sc.h2.h1)))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _7 ) => ((("SC CONSTRAINT: ") + (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, scon))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateContext($$sc.h2, Prelude__$3A$3A_(scon, $$sc2.h2.h0)), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => ((("context types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), ctx$27.h2)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _9 ) => ((("context env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), ctx$27.h1)))) + (""))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _10 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _11 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow(eta)), $$sc.h3.h3.h2)))) + (") clauses were"))), ( _11 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _12 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _12 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_mapMaybe(( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _13 ) => ("and now:")), ( _13 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, clauses, ( x ) => (Lib_Types_log(2, ( _14 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _14 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(clauses)) == (0), ( _15 ) => (Lib_Types_MkM(( _16 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _15 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))))))))))))))))); } } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()))))); } }); } } else { return Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(_$$3), (("case split on non-inductive ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), eta)))); } }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) ))))))))))));
const Lib_Elab_buildCase_constrainSpine_getName = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15 ) => (_$$15.h0);
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow = ( _$$0 ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Common_Prelude_Show$20Lib_Common_FC, Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_MkShow(( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$2)))), Prelude_MkShow(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Prelude_MkShow(( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(eta)), _$$2)))), Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta))), eta))), Prelude__$2C_(_$$0.h0, Prelude__$2C_(_$$0.h1, Prelude__$2C_(_$$0.h2, _$$0.h3)))));
const Lib_Common_Prelude_Show$20Lib_Common_FC = Prelude_MkShow(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(eta)));
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _$$18, _$$19, _$$20 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _$$18, _$$19, _$$20.h1, Prelude_Nil()), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Lib_Syntax_MkClause(_$$20.h0, $$sc.h1, _$$20.h2, _$$20.h3))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()) ))));
const Lib_Syntax_MkClause = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _$$17, _$$18, _$$19, _$$20 ) => (bouncer(Lib_Elab_REC_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: _9,  h10: _10,  h11: _11,  h12: _12,  h13: _13,  h14: _14,  h15: _15,  h16: _16,  h17: _$$17,  h18: _$$18,  h19: _$$19,  h20: _$$20 }));
const Lib_Elab_REC_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint = ( arg ) => { if ((arg.h19.tag) == (1)) { const sc$$28 = (arg.h19.h1.h2) == (arg.h2); switch (sc$$28) { case true: switch (arg.h19.h1.h3.tag) { case 3: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h19.h1.h3.h0, (("Literal ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(arg.h19.h1.h3.h1))) + (" in constructor split"))), eta)))) }; case 2: return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Prelude__$3A$3A_(arg.h19.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h19.h2, arg.h20)))) }; case 1: { const sc$$35 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h19.h1.h3.h2, arg.h7); switch (sc$$35) { case true: return ( (arg.h19.h1.h3.h4.tag) == (1) ? { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h10, arg.h11, arg.h12, arg.h13, arg.h14, arg.h15, arg.h19.h1.h3.h0, arg.h18, arg.h19.h1.h3.h3), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(rest, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h19.h2, arg.h20)))))) } : { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h10, arg.h11, arg.h12, arg.h13, arg.h14, arg.h15, arg.h19.h1.h3.h0, arg.h18, arg.h19.h1.h3.h3), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Prelude__$3A$3A_(Prelude__$2C_(arg.h2, Lib_Syntax_PatVar(arg.h19.h1.h3.h0, arg.h19.h1.h3.h1, arg.h19.h1.h3.h4.h1)), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(rest, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h19.h2, arg.h20))))))) } ); case false: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$37 = Lib_TopContext_lookup(arg.h19.h1.h3.h2, top); if ((sc$$37.tag) == (1)) { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h19.h1.h3.h0, (("Internal Error: DCon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h19.h1.h3.h2))) + (" not found"))), eta)))); } else { if ((sc$$37.h1.h3.tag) == (2)) { const sc$$49 = Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$37.h1.h3.h3, arg.h17)); switch (sc$$49) { case true: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h19.h1.h3.h0, (((("Constructor is a ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$37.h1.h3.h3))) + (" expected a ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h17))) + (""))), eta)))); case false: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h19.h1.h3.h0, (("Internal Error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h19.h1.h3.h2))) + (" is not a DCon"))), eta)))); } } }) }; } break; } case 0: return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Prelude__$3A$3A_(arg.h19.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h19.h2, arg.h20)))) }; } break; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: arg.h12,  h13: arg.h13,  h14: arg.h14,  h15: arg.h15,  h16: arg.h16,  h17: arg.h17,  h18: arg.h18,  h19: arg.h19.h2,  h20: Prelude__$3A$3A_(arg.h19.h1, arg.h20) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(arg.h20)) }; } };
const Lib_Syntax_PatVar = ( h0, h1, h2 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17, _$$18 ) => { if ((_$$18.tag) == (1)) { if ((_$$17.tag) == (1)) { switch (_$$17.h1.h1) { case 1: { const sc$$28 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(Lib_Syntax_getIcit(_$$18.h1), 1); switch (sc$$28) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, _$$18.h2), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_$$17.h1.h0, _$$18.h1), rest)))); case false: return Lib_Types_MkM(( _16 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_.h4, (("mismatch between Explicit and ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(Lib_Syntax_getIcit(_$$18.h1)))) + (""))), eta)))); } break; } default: { const sc$$28 = Prelude_not(Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(Lib_Syntax_getIcit(_$$18.h1), _$$17.h1.h1)); switch (sc$$28) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude__$3A$3A_(_$$18.h1, _$$18.h2)), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_$$17.h1.h0, Lib_Syntax_PatWild(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(_$$18.h1), _$$17.h1.h1)), rest)))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, _$$18.h2), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_$$17.h1.h0, _$$18.h1), rest)))); } break; } } } else { return Lib_Types_MkM(( _16 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(_$$18.h1), "too many patterns")), eta)))); } } else { if ((_$$17.tag) == (1)) { switch (_$$17.h1.h1) { case 2: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude_Nil()), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_$$17.h1.h0, Lib_Syntax_PatWild(Lib_Common_emptyFC, 2)), rest)))); case 1: return Lib_Types_MkM(( _16 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$16, "not enough patterns")), eta)))); case 0: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude_Nil()), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_$$17.h1.h0, Lib_Syntax_PatWild(Lib_Common_emptyFC, 0)), rest)))); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()); } } };
const Lib_Syntax_PatWild = ( h0, h1 ) => ({ tag: 2,  h0: h0,  h1: h1 });
const Lib_Syntax_getIcit = ( _$$0 ) => { switch (_$$0.tag) { case 3: return 1; case 2: return _$$0.h1; case 1: return _$$0.h1; case 0: return _$$0.h1; } };
const Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow = ( _$$0 ) => ((((("") + (_$$0.h0)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1))) + (""));
const Lib_Elab_updateContext = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_updateContext, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_updateContext = ( arg ) => { if ((arg.h1.tag) == (1)) { const ix = Prelude_intToNat(((Prelude_length$27(arg.h0.h1)) - (arg.h1.h1.h2)) - (1)); const sc$$11 = Prelude_getAt(ix, arg.h0.h1); if ((sc$$11.tag) == (1)) { return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(arg.h1.h1.h3), "INTERNAL ERROR: bad index in updateContext")), eta)))) }; } else { if ((sc$$11.h1.tag) == (0)) { if ((sc$$11.h1.h2.tag) == (0)) { const sc$$18 = Prelude_not((sc$$11.h1.h1) == (arg.h1.h1.h2)); switch (sc$$18) { case true: return { tag: 1,  h0: arg.h0,  h1: Prelude__$3A$3A_(Prelude__$2C_(sc$$11.h1.h1, arg.h1.h1.h3), arg.h1.h2) }; case false: { const ctx$27 = Lib_Types_MkCtx(arg.h0.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Elab_substVal(arg.h1.h1.h2, arg.h1.h1.h3, eta)), arg.h0.h1), arg.h0.h2, Lib_Elab_updateContext_replaceV(arg.h0, arg.h1, arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h1.h0, arg.h1.h1.h1, arg.h1.h1.h2, arg.h1.h1.h3, null, ix, true, arg.h0.h3), arg.h0.h4); return { tag: 1,  h0: ctx$27,  h1: arg.h1.h2 }; break; } } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(Lib_Types_getValFC(arg.h1.h1.h3), (((("need to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1.h1.h3))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$11.h1))) + (" or something")), ( _ ) => (Lib_Elab_updateContext(arg.h0, arg.h1.h2))) }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(Lib_Types_getValFC(arg.h1.h1.h3), (((("need to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1.h1.h3))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$11.h1))) + (" or something")), ( _ ) => (Lib_Elab_updateContext(arg.h0, arg.h1.h2))) }; } } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(arg.h0) }; } };
const Lib_Elab_updateContext_replaceV = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$11, _$$12, _$$13 ) => { if ((_$$13.tag) == (1)) { switch (_$$11) { case 0: return Prelude__$3A$3A_(_$$12, _$$13.h2); default: { const x = (_$$11) - (1); return Prelude__$3A$3A_(_$$13.h1, Lib_Elab_updateContext_replaceV(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, x, _$$12, _$$13.h2)); break; } } } else { return Prelude_Nil(); } };
const Lib_Elab_substVal = ( _$$0, _$$1, _$$2 ) => (Lib_Elab_substVal_go(_$$0, _$$1, _$$2, null, _$$2));
const Lib_Elab_substVal_go = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.tag) { case 6: return Lib_Types_VLet(_$$4.h0, _$$4.h1, Lib_Elab_substVal_go(_, _1, _2, _3, _$$4.h2), _$$4.h3); case 5: return Lib_Types_VPi(_$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, Lib_Elab_substVal_go(_, _1, _2, _3, _$$4.h4), _$$4.h5); case 3: return Lib_Types_VMeta(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); case 1: return Lib_Types_VRef(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); case 0: { const sc$$8 = (_$$4.h1) == (_); switch (sc$$8) { case true: return _1; case false: return Lib_Types_VVar(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); } break; } default: return _$$4; } };
const Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? Prelude__$3A$3C_(Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(_$$2, _$$3.h1), _$$2(_$$3.h2)) : Prelude_Lin() ));
const Lib_Types_tryError = ( _$$1 ) => (Lib_Types_catchError(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_Right(eta)), _$$1), ( _$$5 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Left(_$$5)))));
const Lib_Elab_buildCase_constrainSpine = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _$$14, _$$15 ) => (( (_$$15.tag) == (1) ? Prelude__$3A$3A_(Prelude__$2C_(_$$14, _$$15.h1), Lib_Elab_buildCase_constrainSpine(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, (1) + (_$$14), _$$15.h2)) : Prelude_Nil() ));
const Lib_Elab_lookupDef = ( _$$0, _$$1 ) => (Lib_Elab_lookupDef_go(_$$0, _$$1, null, 0, _$$0.h2, _$$0.h1));
const Lib_Elab_lookupDef_go = ( _, _1, _2, _$$3, _$$4, _$$5 ) => (bouncer(Lib_Elab_REC_lookupDef_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Lib_Elab_REC_lookupDef_go = ( arg ) => { if ((arg.h5.tag) == (1)) { if ((arg.h4.tag) == (1)) { const sc$$16 = (arg.h4.h1.h2) == (arg.h1); switch (sc$$16) { case true: return { tag: 0,  h0: Prelude_Just(arg.h5.h1) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: (1) + (arg.h3),  h4: arg.h4.h2,  h5: arg.h5.h2 }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Elab_extendPi = ( _$$0, _$$1, _$$2, _$$3 ) => { if ((_$$1.tag) == (5)) { const nm = Lib_Elab_fresh(_$$0, _$$1.h1); const ctx$27 = Lib_Types_extend(_$$0, nm, _$$1.h4); const v = Lib_Types_VVar(Lib_Common_emptyFC, Prelude_length$27(_$$0.h1), Prelude_Lin()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(v, _$$1.h5.h0), _$$1.h5.h1), ( tyb ) => (Lib_Elab_extendPi(ctx$27, tyb, Prelude__$3A$3C_(_$$2, Lib_Elab_MkBind(nm, _$$1.h2, _$$1.h4)), Prelude__$3A$3C_(_$$3, Lib_Types_VVar(_$$1.h0, Prelude_length$27(_$$0.h1), Prelude_Lin()))))); } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(_$$0, Prelude__$2C_(_$$1, Prelude__$2C_(Prelude__$3C$3E$3E_(_$$2, Prelude_Nil()), _$$3)))); } };
const Lib_Elab_MkBind = ( h0, h1, h2 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_fresh = ( ctx$$0, _$$1 ) => ((_$$1) + (("$") + (Prelude_showInt(Prelude_length$27(ctx$$0.h1)))));
const Lib_Types_Prelude_Show$20Lib_Types_Tm = Prelude_MkShow(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(eta)));
const Lib_Common_Prelude_Show$20Lib_Common_QName = Prelude_MkShow(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)));
const Lib_Elab_checkCase = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), _$$4.h3.h3), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_extendPi(_$$0, vty, Prelude_Lin(), Prelude_Lin()), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_tryError(Lib_Elab_unify($$sc.h2.h1, true, $$sc.h3.h2, _$$3)), ( $$sc1 ) => { if (($$sc1.tag) == (1)) { const sc$$33 = Lib_Elab_lookupDef(_$$0, _$$2); return ( (sc$$33.tag) == (0) ? ( (sc$$33.h1.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$33.h1.h1, _$$4.h2)) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true) ); } else { return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc1.h2))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false))); } }))))));
const Lib_Types_filterM = ( _$$1, _$$2 ) => (( (_$$2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(_$$1(_$$2.h1), ( check ) => { switch (check) { case true: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(_$$2.h1, eta)), Lib_Types_filterM(_$$1, _$$2.h2)); case false: return Lib_Types_filterM(_$$1, _$$2.h2); } }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()) ));
const Prelude_partition = ( _$$1, _$$2 ) => (Prelude_partition_go(null, _$$1, _$$2, null, _$$2, Prelude_Nil(), Prelude_Nil()));
const Prelude_partition_go = ( _, _1, _2, _3, _$$4, _$$5, _$$6 ) => (bouncer(Prelude_REC_partition_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5,  h6: _$$6 }));
const Prelude_REC_partition_go = ( arg ) => { if ((arg.h4.tag) == (1)) { const sc$$10 = arg.h1(arg.h4.h1); switch (sc$$10) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: Prelude__$3A$3A_(arg.h4.h1, arg.h5),  h6: arg.h6 }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: arg.h5,  h6: Prelude__$3A$3A_(arg.h4.h1, arg.h6) }; } } else { return { tag: 0,  h0: Prelude__$2C_(arg.h5, arg.h6) }; } };
const Lib_Elab_matchedConstructors = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_matchedConstructors, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_matchedConstructors = ( arg ) => { if ((arg.h1.tag) == (1)) { const sc$$9 = Prelude_find(( _$$5 ) => ((arg.h0) == (_$$5.h2)), arg.h1.h1.h1); return ( (sc$$9.tag) == (0) ? ( (sc$$9.h1.h3.tag) == (1) ? { tag: 0,  h0: Prelude__$3A$3A_(Prelude__$2C_(sc$$9.h1.h3.h0, sc$$9.h1.h3.h2), Lib_Elab_matchedConstructors(arg.h0, arg.h1.h2)) } : { tag: 1,  h0: arg.h0,  h1: arg.h1.h2 } ) : { tag: 1,  h0: arg.h0,  h1: arg.h1.h2 } ); } else { return { tag: 0,  h0: Prelude_Nil() }; } };
const Lib_Elab_getConstructors = ( _$$0, _$$1, _$$2 ) => (( (_$$2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_getConstructors_lookupTCon(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, null, _$$2.h1), ( $$sc ) => (Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_getConstructors_lookupTCon_lookupDCon(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, null, null, eta)), $$sc))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_vprint(_$$0, _$$2), ( tms ) => (Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("Can't split - not VRef: ") + (tms)) + (""))), eta)))))) ));
const Lib_Elab_vprint = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(Prelude_length$27(_$$0.h1), _$$1), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0.h2), tm))), Prelude_Lin())))));
const Lib_Elab_getConstructors_lookupTCon_lookupDCon = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$10 = Lib_TopContext_lookup(_$$8, top); return ( (sc$$10.tag) == (1) ? Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_3, (("Internal Error: DCon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$8))) + (" not found"))), eta)))) : ( (sc$$10.h1.h3.tag) == (2) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(sc$$10.h1.h1, Prelude__$2C_(Prelude_length$27(sc$$10.h1.h3.h2), sc$$10.h1.h2))) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_3, (("Internal Error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$8))) + (" is not a DCon"))), eta)))) ) ); }));
const Lib_Elab_getConstructors_lookupTCon = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$9 = Lib_TopContext_lookup(_4, top); return ( (sc$$9.tag) == (0) ? ( (sc$$9.h1.h3.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$9.h1.h3.h1) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_1, (("Not a type constructor: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_4))) + (""))), eta)))) ) : Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_1, (("Not a type constructor: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_4))) + (""))), eta)))) ); }));
const Lib_Elab_buildLitCases = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude_nub(Lib_Types_Prelude_Eq$20Lib_Types_Literal, eta)), Lib_Elab_getLits(_$$4, _$$3, _$$1.h0)), ( lits ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildLitCase(_$$0, _$$1, _$$2, _$$3, _$$4, eta)), lits), ( alts ) => { const defclauses = Prelude_filter(( eta ) => (Lib_Elab_buildLitCases_isDefault(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(defclauses)) == (0), ( _ ) => (Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$2, (("no default for literal slot on ") + (_$$3)) + (""))), eta)))))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(_$$0, Lib_Elab_MkProb(defclauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(alts, Prelude__$3A$3A_(Lib_Types_CaseDefault(tm), Prelude_Nil()))))))); }))));
const Lib_Elab_buildLitCases_isDefault = ( _, _1, _2, _3, _4, _5, _$$6 ) => { const sc$$7 = Prelude_find(( _$$5 ) => ((_3) == (_$$5.h2)), _$$6.h1); if ((sc$$7.tag) == (1)) { return true; } else { switch (sc$$7.h1.h3.tag) { case 2: return true; case 0: return true; default: return false; } } };
const Lib_Elab_buildLitCase = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => { const sc$$8 = Prelude_findIndex$27(( _$$51 ) => ((_$$3) == (_$$51.h2)), _$$0.h2); if ((sc$$8.tag) == (1)) { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (("") + (_$$3)) + (" not is scope?"))), eta)))); } else { const lvl = ((Prelude_length$27(_$$0.h1)) - (sc$$8.h1)) - (1); const scon = Prelude__$2C_(lvl, Lib_Types_VLit(_$$2, _$$5)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateContext(_$$0, Prelude__$3A$3A_(scon, Prelude_Nil())), ( ctx$27 ) => { const clauses = Prelude_mapMaybe(( eta ) => (Lib_Elab_buildLitCase_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$5, null, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, (Prelude_length$27(clauses)) == (0), ( _ ) => (Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$5))) + (" splitting ")) + (_$$3)) + (""))), eta)))))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_CaseLit(_$$5, tm)))))); }); } };
const Lib_Elab_buildLitCase_rewriteConstraint_rewriteClause = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (Prelude_Prelude_Monad$20Prelude_Maybe$2Cbind(Lib_Elab_buildLitCase_rewriteConstraint(_, _1, _2, _3, _4, _5, _6, _$$8.h1, Prelude_Nil()), ( cons ) => (Prelude_Just(Lib_Syntax_MkClause(_$$8.h0, cons, _$$8.h2, _$$8.h3)))));
const Lib_Elab_buildLitCase_rewriteConstraint = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (bouncer(Lib_Elab_REC_buildLitCase_rewriteConstraint, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8 }));
const Lib_Elab_REC_buildLitCase_rewriteConstraint = ( arg ) => { if ((arg.h7.tag) == (1)) { const sc$$16 = (arg.h7.h1.h2) == (arg.h3); switch (sc$$16) { case true: switch (arg.h7.h1.h3.tag) { case 3: { const sc$$20 = Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(arg.h7.h1.h3.h1, arg.h5); switch (sc$$20) { case true: return { tag: 0,  h0: Prelude_Just(Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h7.h2, arg.h8)) }; case false: return { tag: 0,  h0: Prelude_Nothing() }; } break; } case 2: return { tag: 0,  h0: Prelude_Just(Prelude__$3A$3A_(arg.h7.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h7.h2, arg.h8))) }; case 1: return { tag: 0,  h0: Prelude_Nothing() }; case 0: return { tag: 0,  h0: Prelude_Just(Prelude__$3A$3A_(arg.h7.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h7.h2, arg.h8))) }; } break; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7.h2,  h8: Prelude__$3A$3A_(arg.h7.h1, arg.h8) }; } } else { return { tag: 0,  h0: Prelude_Just(arg.h8) }; } };
const Prelude_Prelude_Monad$20Prelude_Maybe$2Cbind = ( _$$2, _$$3 ) => (( (_$$2.tag) == (1) ? Prelude_Nothing() : _$$3(_$$2.h1) ));
const Lib_Elab_getLits = ( _$$0, _$$1, _$$2 ) => (bouncer(Lib_Elab_REC_getLits, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_Elab_REC_getLits = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$10 = Prelude_find(( _$$5 ) => ((arg.h1) == (_$$5.h2)), arg.h2.h1.h1); if ((sc$$10.tag) == (0)) { switch (sc$$10.h1.h3.tag) { case 3: return { tag: 0,  h0: Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(sc$$10.h1.h3.h1, eta)), Lib_Elab_getLits(arg.h0, arg.h1, arg.h2.h2)) }; case 1: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$10.h1.h3.h0, (("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h0))) + (""))), eta)))) }; default: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2 }; } } else { return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2 }; } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nil()) }; } };
const Lib_Types_Prelude_Eq$20Lib_Types_Literal = Prelude_MkEq(( eta ) => (( eta1 ) => (Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(eta, eta1))));
const Prelude_nub = ( _$$1, _$$2 ) => (bouncer(Prelude_REC_nub, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_nub = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$6 = Prelude_elem(arg.h1, arg.h2.h1, arg.h2.h2); switch (sc$$6) { case true: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; case false: return { tag: 0,  h0: Prelude__$3A$3A_(arg.h2.h1, Prelude_nub(arg.h1, arg.h2.h2)) }; } } else { return { tag: 0,  h0: Prelude_Nil() }; } };
const Lib_Elab_litTyName = ( _$$0 ) => { switch (_$$0.tag) { case 3: return Lib_Elab_boolType; case 2: return Lib_Elab_charType; case 1: return Lib_Elab_intType; case 0: return Lib_Elab_stringType; } };
const Lib_Elab_boolType = Lib_Common_QN(Lib_Common_primNS, "Bool");
const Lib_Elab_solveAutos_isAuto_run = ( _, _1, _$$2 ) => (( (_$$2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_trySolveAuto(_$$2.h1), ( res ) => { switch (res) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(true); case false: return Lib_Elab_solveAutos_isAuto_run(_, _1, _$$2.h2); } }) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(false) ));
const Lib_Elab_solveAutos_isAuto = ( _, _$$1 ) => { if ((_$$1.tag) == (0)) { switch (_$$1.h4) { case 2: return true; default: return false; } } else { return false; } };
const Lib_Elab_solveAutos = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const autos = Prelude_filter(( eta ) => (Lib_Elab_solveAutos_isAuto(null, eta)), Prelude_mapMaybe(( _$$5 ) => (Data_SortedMap_lookupMap$27(_$$5, top.h5.h0)), top.h5.h1)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos_isAuto_run(null, null, autos), ( res ) => { switch (res) { case true: return Lib_Elab_solveAutos; case false: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); } }); });
const Lib_Elab_lookupName = ( _$$0, _$$1 ) => (Lib_Elab_lookupName_go(_$$0, _$$1, null, 0, _$$0.h2));
const Lib_Elab_lookupName_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Elab_REC_lookupName_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Elab_REC_lookupName_go = ( arg ) => { if ((arg.h4.tag) == (1)) { const sc$$12 = (arg.h4.h1.h2) == (arg.h1); switch (sc$$12) { case true: return { tag: 0,  h0: Prelude_Just(Prelude__$2C_(Lib_Types_Bnd(Lib_Common_emptyFC, arg.h3), arg.h4.h1.h3)) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: (1) + (arg.h3),  h4: arg.h4.h2 }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Elab_findSplit = ( _$$0 ) => (bouncer(Lib_Elab_REC_findSplit, { tag: 1,  h0: _$$0 }));
const Lib_Elab_REC_findSplit = ( arg ) => { if ((arg.h0.tag) == (1)) { switch (arg.h0.h1.h3.tag) { case 3: return { tag: 0,  h0: Prelude_Just(arg.h0.h1) }; case 1: return { tag: 0,  h0: Prelude_Just(arg.h0.h1) }; default: return { tag: 1,  h0: arg.h0.h2 }; } } else { return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Elab_introClause = ( _$$0, _$$1, _$$2 ) => { if ((_$$2.h2.tag) == (1)) { const sc$$10 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, Lib_Syntax_getIcit(_$$2.h2.h1)); switch (sc$$10) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(Prelude__$2C_(_$$0, _$$2.h2.h1), _$$2.h1), _$$2.h2.h2, _$$2.h3)); case false: { const sc$$11 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, 0); switch (sc$$11) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(Prelude__$2C_(_$$0, Lib_Syntax_PatWild(_$$2.h0, 0)), _$$2.h1), Prelude__$3A$3A_(_$$2.h2.h1, _$$2.h2.h2), _$$2.h3)); case false: { const sc$$12 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, 2); switch (sc$$12) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(Prelude__$2C_(_$$0, Lib_Syntax_PatWild(_$$2.h0, 2)), _$$2.h1), Prelude__$3A$3A_(_$$2.h2.h1, _$$2.h2.h2), _$$2.h3)); case false: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$2.h0, (((((("Explicit arg and ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(Lib_Syntax_getIcit(_$$2.h2.h1)))) + (" pattern ")) + (_$$0)) + ("  ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(_$$2.h2.h1))) + (""))), eta)))); } break; } } break; } } } else { switch (_$$1) { case 2: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(Prelude__$2C_(_$$0, Lib_Syntax_PatWild(_$$2.h0, 2)), _$$2.h1), Prelude_Nil(), _$$2.h3)); case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(Prelude__$2C_(_$$0, Lib_Syntax_PatWild(_$$2.h0, 0)), _$$2.h1), Prelude_Nil(), _$$2.h3)); default: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$2.h0, "Clause size doesn't match")), eta)))); } } };
const Lib_Elab_mkPat = ( _$$0 ) => (( (_$$0.h2.tag) == (14) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_mkPat(Prelude__$2C_(_$$0.h2.h2, _$$0.h3)), ( pat ) => (( (pat.tag) == (1) ? ( (pat.h4.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatCon(pat.h0, pat.h1, pat.h2, pat.h3, Prelude_Just(_$$0.h2.h1))) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(pat.h0, (("Double as pattern ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2.h2))) + (""))), eta)))) ) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0.h2.h0, (("Can't put as on non-constructor ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2.h2))) + (""))), eta)))) ))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$6 = Lib_Elab_splitArgs(_$$0.h2, Prelude_Nil()); switch (sc$$6.h2.tag) { case 9: return ( (sc$$6.h3.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatWild(sc$$6.h2.h0, _$$0.h3)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$6.h2.h0, "implicit pat can't be applied to arguments")), eta)))) ); case 7: return ( (sc$$6.h3.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatLit(sc$$6.h2.h0, sc$$6.h2.h1)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$6.h2.h0, "lit cannot be applied to arguments")), eta)))) ); case 0: { const sc$$13 = Lib_TopContext_lookupRaw(sc$$6.h2.h1, top); return ( (sc$$13.tag) == (0) ? ( (sc$$13.h1.h3.tag) == (2) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_mkPat(eta)), sc$$6.h3), ( bpat ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatCon(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), _$$0.h3, sc$$13.h1.h1, bpat, Prelude_Nothing())))) : ( (sc$$6.h3.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatVar(sc$$6.h2.h0, _$$0.h3, sc$$6.h2.h1)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), "patvar applied to args")), eta)))) ) ) : ( (sc$$6.h3.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_PatVar(sc$$6.h2.h0, _$$0.h3, sc$$6.h2.h1)) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), "patvar applied to args")), eta)))) ) ); break; } default: return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$6.h2), (("expected pat var or constructor, got ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$6.h2))) + (""))), eta)))); } }) ));
const Lib_Syntax_PatCon = ( h0, h1, h2, h3, h4 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Syntax_PatLit = ( h0, h1 ) => ({ tag: 3,  h0: h0,  h1: h1 });
const Lib_Elab_splitArgs = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_splitArgs, { tag: 1,  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_splitArgs = ( arg ) => (( (arg.h0.tag) == (2) ? { tag: 1,  h0: arg.h0.h1,  h1: Prelude__$3A$3A_(Prelude__$2C_(arg.h0.h2, arg.h0.h3), arg.h1) } : { tag: 0,  h0: Prelude__$2C_(arg.h0, arg.h1) } ));
const Lib_Elab_undo = ( _$$0, _$$1 ) => { if ((_$$1.tag) == (1)) { switch (_$$1.h1.tag) { case 2: return ( (_$$1.h1.h1.tag) == (0) ? ( (_$$1.h1.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookupRaw(_$$1.h1.h1.h1, top); return ( (sc$$13.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, 1), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h1.h0, _$$1.h1.h1.h1, 1, true), xs$27), 1)))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), Prelude_Nil()))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, 1), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", 1, true), rest), 1)))))) ); }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), _$$1.h1.h3))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, 1), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", 1, true), rest), 1)))))) ) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), _$$1.h1.h3))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, 1), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", 1, true), rest), 1)))))) ); case 1: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Syntax_RLet(_$$1.h1.h0, _$$1.h1.h1, Lib_Syntax_RImplicit(_$$1.h1.h0), _$$1.h1.h2, eta)), Lib_Elab_undo(_$$1.h1.h0, _$$1.h2)); case 0: return ( (_$$1.h2.tag) == (0) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$1.h1.h1) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h1, 1), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "_", 1, true), xs$27), 1)))) ); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, "do block must end in expression")), eta)))); } };
const Lib_Types_BI = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Syntax_RLam = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_RApp = ( h0, h1, h2, h3 ) => ({ tag: 2,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Syntax_RImplicit = ( h0 ) => ({ tag: 9,  h0: h0 });
const Lib_Syntax_RLet = ( h0, h1, h2, h3, h4 ) => ({ tag: 5,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Syntax_MkAlt = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Syntax_RCase = ( h0, h1, h2 ) => ({ tag: 8,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_collectDecl = ( _$$0 ) => (bouncer(Lib_Elab_REC_collectDecl, { tag: 1,  h0: _$$0 }));
const Lib_Elab_REC_collectDecl = ( arg ) => { if ((arg.h0.tag) == (1)) { if ((arg.h0.h1.tag) == (1)) { if ((arg.h0.h2.tag) == (1)) { if ((arg.h0.h2.h1.tag) == (1)) { const sc$$13 = (arg.h0.h1.h1) == (arg.h0.h2.h1.h1); switch (sc$$13) { case true: return { tag: 1,  h0: Prelude__$3A$3A_(Lib_Syntax_FunDef(arg.h0.h1.h0, arg.h0.h1.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(arg.h0.h1.h2, arg.h0.h2.h1.h2)), arg.h0.h2.h2) }; case false: return { tag: 0,  h0: Prelude__$3A$3A_(Lib_Syntax_FunDef(arg.h0.h1.h0, arg.h0.h1.h1, arg.h0.h1.h2), Lib_Elab_collectDecl(arg.h0.h2)) }; } } else { return { tag: 0,  h0: Prelude__$3A$3A_(arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } } else { return { tag: 0,  h0: Prelude__$3A$3A_(arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } } else { return { tag: 0,  h0: Prelude__$3A$3A_(arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } } else { return { tag: 0,  h0: Prelude_Nil() }; } };
const Lib_Syntax_FunDef = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_checkWhere = ( _$$0, _$$1, _$$2, _$$3 ) => (( (_$$1.tag) == (1) ? ( (_$$1.h1.tag) == (0) ? ( (_$$1.h1.h1.tag) == (1) ? ( (_$$1.h1.h1.h2.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(_$$0, _$$1.h1.h2, Lib_Types_VU(_$$1.h1.h0)), ( funTy ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _ ) => ((((("where clause ") + (_$$1.h1.h1.h1)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h2), _$$0.h2), funTy))), Prelude_Lin()))) + (""))), ( _ ) => (( (_$$1.h2.tag) == (1) ? ( (_$$1.h2.h1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not((_$$1.h1.h1.h1) == (_$$1.h2.h1.h1)), ( _1 ) => (Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h2.h1.h0, (("Expected def for ") + (_$$1.h1.h1.h1)) + (""))), eta)))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_makeClause(eta)), _$$1.h2.h1.h2), ( clauses$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(_$$0.h1, funTy), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((((("") + (_$$1.h1.h1.h1)) + (" vty is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(vty))) + (""))), ( _2 ) => { const ctx$27 = Lib_Types_extend(_$$0, _$$1.h1.h1.h1, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(Lib_Types_MkCtx(ctx$27.h0, ctx$27.h1, ctx$27.h2, ctx$27.h3, _$$1.h2.h1.h0), Lib_Elab_MkProb(clauses$27, vty)), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(ctx$27.h1, tm), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_checkWhere(ctx$27, _$$1.h2.h2, _$$2, _$$3), ( ty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Types_LetRec(_$$1.h1.h0, _$$1.h1.h1.h1, funTy, tm, ty$27)))))))); }))))))))) : Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h2.h1), "expected function definition")), eta)))) ) : Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1.h1.h0, "expected function definition after this signature")), eta)))) ))))) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))) ) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))) ) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))) ) : Lib_Elab_check(_$$0, _$$2, _$$3) ));
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case 10: return _$$0.h0; case 9: return _$$0.h0; case 8: return _$$0.h0; case 7: return _$$0.h0; case 6: return _$$0.h0; case 5: return _$$0.h0; case 4: return _$$0.h0; case 3: return _$$0.h0; case 2: return _$$0.h0; case 1: return _$$0.h0; case 0: return _$$0.h0; } };
const Lib_Elab_makeClause = ( _$$0 ) => { const sc$$5 = Lib_Elab_splitArgs(_$$0.h2, Prelude_Nil()); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_mkPat(eta)), sc$$5.h3), ( pats ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_MkClause(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), Prelude_Nil(), pats, _$$0.h3)))); };
const Lib_Elab_updateRec = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_updateRec_doClause_collect_getTele(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, _$$3, _$$4), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_foldlM(Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Elab_updateRec_doClause(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta, eta1))), $$sc.h3, _$$2), ( args$27 ) => { const tm = Prelude_foldl(( acc ) => (( tm ) => (Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(tm), acc, tm, 1))), Lib_Syntax_RVar(_$$1, $$sc.h2.h1), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$21 ) => (_$$21.h3), args$27)); const tm1 = ( (_$$3.tag) == (1) ? Lib_Syntax_RLam(_$$1, Lib_Types_BI(_$$1, "$ru", 1, true), tm) : tm ); return Lib_Elab_check(_$$0, tm1, _$$4); }))));
const Lib_Elab_updateRec_doClause = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (( (_$$7.tag) == (1) ? Lib_Elab_updateRec_doClause_go(_, _1, _2, _3, _4, _5, _$$6, _$$7, _$$7.h0, _$$7.h1, _$$7.h2, null, _$$6) : Lib_Elab_updateRec_doClause_go$27(_, _1, _2, _3, _4, _5, _$$6, _$$7, _$$7.h0, _$$7.h1, _$$7.h2, null, _$$6) ));
const Lib_Elab_updateRec_doClause_go$27 = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { if ((_$$12.tag) == (1)) { const sc$$16 = (_$$12.h1.h2) == (_9); switch (sc$$16) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_9, _10), _$$12.h2)); case false: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(_$$12.h1, eta)), Lib_Elab_updateRec_doClause_go$27(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12.h2)); } } else { return Lib_Types_MkM(( _12 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_8, (((("") + (_9)) + (" is not a field of ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_4))) + (""))), eta)))); } };
const Lib_Elab_updateRec_doClause_go = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { if ((_$$12.tag) == (1)) { const sc$$16 = (_$$12.h1.h2) == (_9); switch (sc$$16) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(_9, Lib_Syntax_RApp(_8, _10, _$$12.h1.h3, 1)), _$$12.h2)); case false: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Prelude__$3A$3A_(_$$12.h1, eta)), Lib_Elab_updateRec_doClause_go(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12.h2)); } } else { return Lib_Types_MkM(( _12 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_8, (((("") + (_9)) + (" is not a field of ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_4))) + (""))), eta)))); } };
const Lib_Elab_updateRec_doClause_collect_getTele = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (bouncer(Lib_Elab_REC_updateRec_doClause_collect_getTele, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8,  h9: _$$9 }));
const Lib_Elab_REC_updateRec_doClause_collect_getTele = ( arg ) => { switch (arg.h9.tag) { case 5: return ( (arg.h8.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Prelude_Just(Lib_Syntax_RVar(arg.h1, "$ru")),  h9: arg.h9.h4 } : { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a record type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) } ); case 1: return ( (arg.h8.tag) == (1) ? { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a pi type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) } : { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$16 = Lib_TopContext_lookup(arg.h9.h1, top); if ((sc$$16.tag) == (0)) { if ((sc$$16.h1.h3.tag) == (1)) { if ((sc$$16.h1.h3.h1.tag) == (1)) { if ((sc$$16.h1.h3.h1.h2.tag) == (0)) { const sc$$30 = Lib_TopContext_lookup(sc$$16.h1.h3.h1.h1, top); return ( (sc$$30.tag) == (0) ? ( (sc$$30.h1.h3.tag) == (2) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(sc$$16.h1.h3.h1.h1, Lib_Elab_updateRec_doClause_collect(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h8.h1, sc$$30.h1.h2))) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$16.h1.h3.h1.h1))) + (" not a dcon"))), eta)))) ) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$16.h1.h3.h1.h1))) + (" not a dcon"))), eta)))) ); } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } } else { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" not in scope"))), eta)))); } }) } ); default: return ( (arg.h8.tag) == (1) ? { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a pi type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) } : { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a record type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) } ); } };
const Lib_Elab_updateRec_doClause_collect = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (( (_$$8.tag) == (6) ? Prelude__$3A$3A_(Prelude__$2C_(_$$8.h1, Lib_Syntax_RApp(_1, Lib_Syntax_RVar(_1, (".") + (_$$8.h1)), _$$7, 1)), Lib_Elab_updateRec_doClause_collect(_, _1, _2, _3, _4, _5, _6, _$$7, _$$8.h5)) : Prelude_Nil() ));
const Lib_Util_splitTele_go = ( _, _$$1, _$$2 ) => (bouncer(Lib_Util_REC_splitTele_go, { tag: 1,  h0: _,  h1: _$$1,  h2: _$$2 }));
const Lib_Util_splitTele = ( eta ) => (Lib_Util_splitTele_go(null, Prelude_Nil(), eta));
const Lib_Util_REC_splitTele_go = ( arg ) => (( (arg.h2.tag) == (6) ? { tag: 1,  h0: arg.h0,  h1: Prelude__$3A$3A_(Lib_Util_MkBinder(arg.h2.h0, arg.h2.h1, arg.h2.h2, arg.h2.h3, arg.h2.h4), arg.h1),  h2: arg.h2.h5 } : { tag: 0,  h0: Prelude__$2C_(arg.h2, Prelude_reverse()(arg.h1)) } ));
const Lib_Util_MkBinder = ( h0, h1, h2, h3, h4 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_ProcessDecl_dumpEnv = ( _$$0 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$5 ) => (Prelude_joinBy("\n", Prelude_reverse()(_$$5))), Lib_ProcessDecl_dumpEnv_isVar_go(_$$0, null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( _$$2 ) => (_$$2.h2), _$$0.h2), 0, Prelude_reverse()(Prelude_zip(_$$0.h1, _$$0.h2)), Prelude_Nil())));
const Lib_ProcessDecl_dumpEnv_isVar_go = ( _, _1, _2, _$$3, _$$4, _$$5, _$$6 ) => { if ((_$$5.tag) == (1)) { const sc$$18 = Lib_ProcessDecl_dumpEnv_isVar(_, _1, _$$4, _$$5.h1.h2); switch (sc$$18) { case true: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( ty$27 ) => (Lib_ProcessDecl_dumpEnv_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_((((("  ") + (_$$5.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, ty$27))), Prelude_Lin()))) + (""), _$$6)))); case false: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h2), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( ty$27 ) => (Lib_ProcessDecl_dumpEnv_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_((((((("  ") + (_$$5.h1.h3.h2)) + (" = ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, v$27))), Prelude_Lin()))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, ty$27))), Prelude_Lin()))) + (""), _$$6)))))); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$6); } };
const Lib_ProcessDecl_dumpEnv_isVar = ( _, _1, _$$2, _$$3 ) => (( (_$$3.tag) == (0) ? ( (_$$3.h2.tag) == (0) ? (_$$2) == (_$$3.h1) : false ) : false ));
const Serialize_dumpModule = ( _$$0, _$$1, _$$2 ) => { const fn = (("build/") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (".newtmod"); const defs = Data_SortedMap_listValues(_$$2.h1); const ops = Data_SortedMap_toList(_$$2.h3); const mctx = Data_SortedMap_toList(_$$2.h2.h0); return Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Serialize_dumpModFile(fn, Prelude__$2C_(_$$2.h0, Prelude__$2C_(defs, Prelude__$2C_(ops, mctx))))); };
const Serialize_dumpModFile = (fn,a) => (w) => {
  let fs = require('fs')
  try {
    let {EncFile} = require('./serializer')
    let enc = EncFile.encode(a)
    fs.writeFileSync(fn, enc)
  } catch (e) {}
  return Prelude_MkIORes(Prelude_MkUnit, w)
};
const Lib_Types_MkModCtx = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Main_processModule_tryProcessDecl = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_tryError(Lib_ProcessDecl_processDecl(_$$8, _$$9)), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn(Lib_Common_showError(_$$7, $$sc.h2))), ( _7 ) => (Lib_TopContext_addError($$sc.h2))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) ))));
const Lib_TopContext_addError = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Data_IORef_modifyIORef(Lib_Types_Prelude_Monad$20Lib_Types_M, Lib_Types_Prelude_HasIO$20Lib_Types_M, top.h7, ( eta ) => (Prelude__$3A$3A_(_$$0, eta))))));
const Lib_ProcessDecl_processDecl = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case 10: return Lib_ProcessDecl_processRecord(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case 9: return Lib_ProcessDecl_processInstance(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case 8: return Lib_ProcessDecl_processClass(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3); case 7: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); case 6: return Lib_ProcessDecl_processPrimFn(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case 5: return Lib_ProcessDecl_processPrimType(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case 4: return Lib_ProcessDecl_processShortData(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case 3: return Lib_ProcessDecl_processData(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3); case 2: return Lib_ProcessDecl_processCheck(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case 1: return Lib_ProcessDecl_processDef(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case 0: return Lib_ProcessDecl_processTypeSig(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); } };
const Lib_ProcessDecl_processTypeSig = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(_$$1, eta)), _$$2), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$3, Lib_Types_VU(_$$1)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _2 ) => ((((("TypeSig ") + (Prelude_joinBy(" ", _$$2))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), ty))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (0), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$2, ( nm ) => (Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm), _$$1, ty, Lib_Types_Axiom, Prelude_Nil())))))))))))))));
const Lib_Types_Axiom = { tag: 0 };
const Lib_TopContext_setDef = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$6 = Data_SortedMap_lookupMap$27(_$$0, top.h4); return ( (sc$$6.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, Data_SortedMap_updateMap(_$$0, Lib_Types_MkEntry(_$$1, _$$0, _$$2, _$$3, _$$4), tc.h4), tc.h5, tc.h6, tc.h7, tc.h8)))) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" is already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$6.h1.h0))) + (""))), eta)))) ); }));
const Lib_Types_MkEntry = ( h0, h1, h2, h3, h4 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_ProcessDecl_checkAlreadyDef = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookupRaw(_$$1, top); return ( (sc$$3.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$0, (((("") + (_$$1)) + (" is already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$3.h1.h0))) + (""))), eta)))) ); }));
const Lib_ProcessDecl_processDef = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("Def ") + (_$$2)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$8 = Lib_TopContext_lookupRaw(_$$2, top); return ( (sc$$8.tag) == (1) ? Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("No declaration for ") + (_$$2)) + (""))), eta)))) : ( (sc$$8.h1.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _2 ) => ((((("check ") + (_$$2)) + (" at ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$8.h1.h2))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$8.h1.h2), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((((("") + (_$$2)) + (" vty is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(vty))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_makeClause(eta)), _$$3), ( clauses$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_buildTree(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), sc$$8.h1.h0), Lib_Elab_MkProb(clauses$27, vty)), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos, ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((((("Add def ") + (_$$2)) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), tm))), Prelude_Lin()))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$8.h1.h2))), Prelude_Lin()))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), sc$$8.h1.h0, sc$$8.h1.h2, Lib_Types_Fn(tm)), ( _6 ) => { const name = Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(Lib_Common_QN(_$$0, _$$2)); const sc$$26 = (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, Lib_ProcessDecl_complexity(tm), 15), 0)) || (((name) == ("Prelude.Prelude.Monad Prelude.IO,bind")) || ((name) == ("Prelude._>>=_"))); switch (sc$$26) { case true: return Lib_TopContext_setFlag(Lib_Common_QN(_$$0, _$$2), sc$$8.h1.h0, true); case false: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); } }))))))))))))))) : Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (((("") + (_$$2)) + (" already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$8.h1.h0))) + (""))), eta)))) ) ); }))))));
const Lib_TopContext_setFlag = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(_$$0, top.h4); return ( (sc$$4.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" not declared"))), eta)))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, Data_SortedMap_updateMap(_$$0, Lib_Types_MkEntry(sc$$4.h1.h0, _$$0, sc$$4.h1.h2, sc$$4.h1.h3, Prelude__$3A$3A_(_$$2, sc$$4.h1.h4)), tc.h4), tc.h5, tc.h6, tc.h7, tc.h8)))) ); }));
const Lib_ProcessDecl_complexity = ( _$$0 ) => { switch (_$$0.tag) { case 10: return 0; case 7: return ( (_$$0.h2.tag) == (1) ? ( (_$$0.h2.h1.tag) == (1) ? ( (_$$0.h2.h2.tag) == (0) ? ((1) + (Lib_ProcessDecl_complexity(_$$0.h1))) + (Lib_ProcessDecl_complexity(_$$0.h2.h1.h2)) : 100 ) : 100 ) : 100 ); case 5: return 0; case 4: return Lib_ProcessDecl_complexity_go(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, _$$0.h1, Lib_ProcessDecl_complexity(_$$0.h2)); case 3: return (1) + (Lib_ProcessDecl_complexity(_$$0.h4)); case 2: return 1; case 1: return 1; case 0: return 1; default: return 100; } };
const Lib_ProcessDecl_complexity_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_ProcessDecl_REC_complexity_go, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_ProcessDecl_REC_complexity_go = ( arg ) => { switch (arg.h5.tag) { case 4: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h1,  h6: (arg.h6) + (Lib_ProcessDecl_complexity(arg.h5.h2)) }; case 2: return { tag: 0,  h0: 1 }; default: return { tag: 0,  h0: (arg.h6) + (Lib_ProcessDecl_complexity(arg.h5)) }; } };
const Lib_TopContext_updateDef = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$5 = Data_SortedMap_lookupMap$27(_$$0, top.h4); return ( (sc$$5.tag) == (1) ? Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" not declared"))), eta)))) : Lib_Types_putTop(Lib_Types_MkTop(top.h0, top.h1, top.h2, top.h3, Data_SortedMap_updateMap(_$$0, Lib_Types_MkEntry(sc$$5.h1.h0, _$$0, _$$2, _$$3, sc$$5.h1.h4), top.h4), top.h5, top.h6, top.h7, top.h8)) ); }));
const Lib_ProcessDecl_processCheck = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("----- DCheck")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_info(_$$1, (((("check ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$2))) + (" at ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$3))) + ("")), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$3, Lib_Types_VU(_$$1)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("  got type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), ty$27))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), ty$27), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$2, vty), ( res ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("  got ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), res))), Prelude_Lin()))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), res), ( eta ) => (Lib_Eval_quote(Prelude_length$27(Prelude_Nil()), eta))), ( norm ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("  NF ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), norm))), Prelude_Lin()))) + (""))))))))))))))))))))));
const Lib_ProcessDecl_processData = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("Data ") + (_$$2)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$3, Lib_Types_VU(_$$1)), ( tyty ) => { const sc$$12 = Lib_TopContext_lookupRaw(_$$2, top); return ( (sc$$12.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_Axiom, Prelude_Nil()), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(_$$31, ( _$$11 ) => (_$$11))), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_enumerate(_$$4), ( x ) => (( (x.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h3.h0, eta)), x.h3.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h3.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), x.h3.h0), x.h3.h2, Lib_Types_VU(x.h3.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), dty))), Prelude_Lin()))) + (""))), ( _5 ) => { const sc$$26 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse()(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$26.h3)); const sc$$32 = Lib_Util_funArgs(sc$$26.h2); return ( (sc$$32.h2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$32.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$26.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$26.h2))), Prelude_Lin()))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( nm$27 ) => (Lib_Types_MkEntry(x.h3.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon(x.h2, 0, Lib_Elab_getArity(dty), sc$$32.h2.h1), Prelude_Nil())), x.h3.h1)))) : Lib_Types_MkM(( _6 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$32.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$32.h2))), Prelude_Lin()))) + (""))), eta)))) ); }))))))) : Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x.h3), "expected constructor declaration")), eta)))) )))), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))) : ( (sc$$12.h1.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), tyty), ( tyty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$12.h1.h2), ( type$27 ) => (Lib_Elab_unifyCatch(_$$1, Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), tyty$27, type$27))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(_$$31, ( _$$11 ) => (_$$11))), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_enumerate(_$$4), ( x ) => (( (x.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h3.h0, eta)), x.h3.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h3.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), x.h3.h0), x.h3.h2, Lib_Types_VU(x.h3.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), dty))), Prelude_Lin()))) + (""))), ( _5 ) => { const sc$$26 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse()(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$26.h3)); const sc$$32 = Lib_Util_funArgs(sc$$26.h2); return ( (sc$$32.h2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$32.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$26.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$26.h2))), Prelude_Lin()))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( nm$27 ) => (Lib_Types_MkEntry(x.h3.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon(x.h2, 0, Lib_Elab_getArity(dty), sc$$32.h2.h1), Prelude_Nil())), x.h3.h1)))) : Lib_Types_MkM(( _6 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$32.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$32.h2))), Prelude_Lin()))) + (""))), eta)))) ); }))))))) : Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x.h3), "expected constructor declaration")), eta)))) )))), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_MkM(( _2 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("") + (_$$2)) + (" already declared"))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(_$$31, ( _$$11 ) => (_$$11))), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_enumerate(_$$4), ( x ) => (( (x.h3.tag) == (0) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h3.h0, eta)), x.h3.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h3.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), x.h3.h0), x.h3.h2, Lib_Types_VU(x.h3.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), x.h3.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), dty))), Prelude_Lin()))) + (""))), ( _5 ) => { const sc$$26 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse()(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$26.h3)); const sc$$32 = Lib_Util_funArgs(sc$$26.h2); return ( (sc$$32.h2.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$32.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(( _7 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$26.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$26.h2))), Prelude_Lin()))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( nm$27 ) => (Lib_Types_MkEntry(x.h3.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon(x.h2, 0, Lib_Elab_getArity(dty), sc$$32.h2.h1), Prelude_Nil())), x.h3.h1)))) : Lib_Types_MkM(( _6 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$32.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$32.h2))), Prelude_Lin()))) + (""))), eta)))) ); }))))))) : Lib_Types_MkM(( _3 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x.h3), "expected constructor declaration")), eta)))) )))), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))) ) ); }))))))));
const Lib_Types_TCon = ( h0, h1 ) => ({ tag: 1,  h0: h0,  h1: h1 });
const Lib_Util_piArity = ( _$$0 ) => (( (_$$0.tag) == (6) ? (1) + (Lib_Util_piArity(_$$0.h5)) : 0 ));
const Lib_ProcessDecl_populateConInfo = ( _$$0 ) => { const sc$$5 = Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Prelude_Prelude_Applicative$20Prelude_Maybe, ( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum(_$$0, null, null, eta)), _$$0); if ((sc$$5.tag) == (1)) { if ((_$$0.tag) == (1)) { if ((_$$0.h2.tag) == (1)) { if ((_$$0.h2.h2.tag) == (0)) { const sc$$15 = Prelude_find(( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero_isSucc(_$$0, null, null, null, null, eta)), _$$0); if ((sc$$15.tag) == (0)) { const sc$$18 = Prelude_find(( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero(_$$0, null, null, null, eta)), _$$0); return ( (sc$$18.tag) == (0) ? Prelude__$3A$3A_(Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$18.h1, 2), Prelude__$3A$3A_(Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$15.h1, 1), Prelude_Nil())) : _$$0 ); } else { return _$$0; } } else { return _$$0; } } else { return _$$0; } } else { return _$$0; } } else { return ( (sc$$5.h1.tag) == (1) ? ( (sc$$5.h1.h2.tag) == (1) ? ( (sc$$5.h1.h2.h2.tag) == (0) ? Prelude__$3A$3A_(Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$5.h1.h1, 5), Prelude__$3A$3A_(Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$5.h1.h2.h1, 4), Prelude_Nil())) : sc$$5.h1 ) : sc$$5.h1 ) : sc$$5.h1 ); } };
const Lib_ProcessDecl_populateConInfo_setInfo = ( _, _1, _$$2, _$$3 ) => (( (_$$2.h3.tag) == (2) ? Lib_Types_MkEntry(_$$2.h0, _$$2.h1, _$$2.h2, Lib_Types_DCon(_$$2.h3.h0, _$$3, _$$2.h3.h2, _$$2.h3.h3), _$$2.h4) : _$$2 ));
const Lib_Types_DCon = ( h0, h1, h2, h3 ) => ({ tag: 2,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero = ( _, _1, _2, _3, _$$4 ) => (( (_$$4.h3.tag) == (2) ? ( (_$$4.h3.h2.tag) == (0) ? true : false ) : false ));
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero_isSucc = ( _, _1, _2, _3, _4, _$$5 ) => { if ((_$$5.h2.tag) == (6)) { if ((_$$5.h2.h4.tag) == (1)) { if ((_$$5.h2.h5.tag) == (1)) { if ((_$$5.h3.tag) == (2)) { if ((_$$5.h3.h2.tag) == (1)) { switch (_$$5.h3.h2.h1) { case true: return ( (_$$5.h3.h2.h2.tag) == (0) ? Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$5.h2.h4.h1, _$$5.h2.h5.h1) : false ); default: return false; } } else { return false; } } else { return false; } } else { return false; } } else { return false; } } else { return false; } };
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum = ( _, _1, _2, _$$3 ) => (( (_$$3.h3.tag) == (2) ? ( (_$$3.h3.h2.tag) == (0) ? Prelude_Just(Lib_Types_MkEntry(_$$3.h0, _$$3.h1, _$$3.h2, Lib_Types_DCon(_$$3.h3.h0, 3, Prelude_Nil(), _$$3.h3.h3), _$$3.h4)) : Prelude_Nothing() ) : Prelude_Nothing() ));
const Prelude_Prelude_Applicative$20Prelude_Maybe$2C_$3C$2A$3E_ = ( _$$2, _$$3 ) => (( (_$$2.tag) == (1) ? Prelude_Nothing() : Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(_$$2.h1, _$$3) ));
const Prelude_Prelude_Applicative$20Prelude_Maybe = Prelude_MkApplicative(( a ) => (( _$$1 ) => (Prelude_Just(_$$1))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Prelude_Prelude_Applicative$20Prelude_Maybe$2C_$3C$2A$3E_(eta, eta1))))));
const Lib_Elab_getArity = ( _$$0 ) => (( (_$$0.tag) == (6) ? Prelude__$3A$3A_(_$$0.h3, Lib_Elab_getArity(_$$0.h5)) : Prelude_Nil() ));
const Lib_ProcessDecl_processData_binderName = ( _, _1, _2, _3, _4, _5, _$$6 ) => (_$$6.h1);
const Lib_ProcessDecl_processShortData = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processShortData_mkPi_getArgs(_$$0, _$$1, _$$2, _$$3, null, null, _$$2, Prelude_Nil()), ( $$sc ) => { const ty = Prelude_foldr(( eta ) => (( eta1 ) => (Lib_ProcessDecl_processShortData_mkPi(_$$0, _$$1, _$$2, _$$3, null, eta, eta1))), Lib_Syntax_RU(_$$1), $$sc.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl(_$$0, _$$1, _$$2, _$$3, null, null, null, $$sc.h3, Prelude_Nil(), eta)), _$$3), ( cons ) => { const dataDecl = Lib_Syntax_Data(_$$1, $$sc.h2, ty, cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("SHORTDATA")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(dataDecl))), Prelude_Lin()))) + (""))), ( _1 ) => (Lib_ProcessDecl_processDecl(_$$0, dataDecl))))); }); }));
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty = ( _$$0 ) => { switch (_$$0.tag) { case 10: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("record"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_prettyBind(eta)), _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude__$3A$3A_(Prelude_maybe(Lib_Prettier_empty, ( nm$27 ) => (Lib_Prettier_Seq(Lib_Prettier_Text("constructor"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(nm$27)))), _$$0.h3), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(eta)), _$$0.h4)))))))); case 9: return Lib_Prettier_Text("TODO pretty Instance"); case 8: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("class"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_prettyBind(eta)), _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(eta)), _$$0.h3))))))); case 7: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow(_$$0.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(Prelude_showInt(_$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Prettier_text, _$$0.h1)))); case 6: return ( (_$$0.h2.tag) == (0) ? Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("pfunc"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Text(_$$0.h4)))))) : Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("pfunc"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("uses"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Prettier_text, _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Text(_$$0.h4)))))) ); case 5: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("ptype"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Prelude_maybe(Lib_Prettier_empty, ( ty ) => (Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(ty)))), _$$0.h2))); case 4: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("data"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(a, Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("|"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), b)))))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty, _$$0.h2)))); case 3: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("data"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(eta)), _$$0.h3))))))); case 2: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("#check"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2))); case 1: return Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty_prettyPair(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, eta)), _$$0.h2)); case 0: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Prettier_text, _$$0.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2)))); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc = ( _, _1, _2, _$$3, _$$4 ) => { switch (_$$4.tag) { case 15: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("TODO RUpdateRec"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))); case 14: return Lib_Prettier_Seq(Lib_Prettier_Text(_$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text("@("), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text(")")))); case 13: return Lib_Prettier_Text("TODO pretty where"); case 12: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("if"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h1))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("then"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2))))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("else"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h3)))))); case 11: return Lib_Prettier_Text("TODO - RDo"); case 10: return Lib_Prettier_Text("?"); case 9: return Lib_Prettier_Text("_"); case 8: return Lib_Prettier_Text("TODO - RCase"); case 7: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Types_Literal$2Cpretty(_$$4.h1); case 6: return Lib_Prettier_Text("TODO - RAnn"); case 5: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$4.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h3))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("in"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h4)))))); case 4: switch (_$$4.h1.h1) { case "_": switch (_$$4.h1.h2) { case 1: switch (_$$4.h1.h3) { case true: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h3)))); default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; case 3: return Lib_Prettier_Text("U"); case 2: switch (_$$4.h3) { case 2: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("{{"))), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text("}}")))); case 1: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 3, _$$4.h2)))); case 0: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("{"))), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text("}")))); } break; case 1: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Text("\\"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Text(_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("=>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2))))); case 0: return Lib_Prettier_Text(_$$4.h1); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty = ( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(null, null, null, 0, eta));
const Lib_Syntax_wrap = ( _$$0, _$$1 ) => { switch (_$$0) { case 2: return Lib_Prettier_Seq(Lib_Prettier_Text("{{"), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text("}}"))); case 1: return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text(")"))); case 0: return Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text("}"))); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par = ( _, _1, _$$2, _$$3, _$$4 ) => { const sc$$5 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$3, _$$2), 0); switch (sc$$5) { case true: return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$4, Lib_Prettier_Text(")"))); case false: return _$$4; } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Types_Literal$2Cpretty = ( _$$0 ) => { switch (_$$0.tag) { case 3: switch (_$$0.h0) { case true: return Lib_Prettier_Text("true"); case false: return Lib_Prettier_Text("false"); } break; case 2: return Lib_Prettier_Text(Prelude_jsShow(null, _$$0.h0)); case 1: return Lib_Prettier_Text(Prelude_showInt(_$$0.h0)); case 0: return Lib_Prettier_Text(_$$0.h0); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty_prettyPair = ( _, _1, _2, _3, _4, _$$5 ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$5.h2), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$5.h3))));
const Lib_Prettier_empty = Lib_Prettier_Empty;
const Prelude_maybe = ( _$$2, _$$3, _$$4 ) => (( (_$$4.tag) == (1) ? _$$2 : _$$3(_$$4.h1) ));
const Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow = ( _$$0 ) => { switch (_$$0) { case 2: return "infix"; case 1: return "infixr"; case 0: return "infixl"; } };
const Lib_Syntax_prettyBind = ( _$$0 ) => (Lib_Syntax_wrap(_$$0.h2.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h2.h3)) + (_$$0.h2.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3)))));
const Lib_Syntax_Data = ( h0, h1, h2, h3 ) => ({ tag: 3,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_ProcessDecl_REC_processShortData_mkPi_getArgs_mkDecl, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_ProcessDecl_REC_processShortData_mkPi_getArgs_mkDecl = ( arg ) => { switch (arg.h9.tag) { case 2: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Prelude__$3A$3A_(arg.h9.h2, arg.h8),  h9: arg.h9.h1 }; case 0: { const base = Prelude_foldr(( ty ) => (( acc ) => (Lib_Syntax_RPi(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), Lib_Types_BI(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), "_", 1, true), ty, acc))), arg.h2, arg.h8); const ty = Prelude_foldr(( eta ) => (( eta1 ) => (Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl_mkPi(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h9.h0, arg.h9.h1, null, eta, eta1))), base, arg.h7); return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Lib_Syntax_TypeSig(arg.h9.h0, Prelude__$3A$3A_(arg.h9.h1, Prelude_Nil()), ty)) }; break; } default: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h9), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h9))) + (""))), eta)))) }; } };
const Lib_Syntax_TypeSig = ( h0, h1, h2 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2 });
const Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl_mkPi = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _$$13, _$$14 ) => (Lib_Syntax_RPi(_$$13.h2, Lib_Types_BI(_$$13.h2, _$$13.h3, 0, false), Lib_Syntax_RU(_$$13.h2), _$$14));
const Lib_Syntax_RU = ( h0 ) => ({ tag: 3,  h0: h0 });
const Lib_Syntax_RPi = ( h0, h1, h2, h3 ) => ({ tag: 4,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Prelude_foldr = ( _$$2, _$$3, _$$4 ) => (( (_$$4.tag) == (1) ? _$$2(_$$4.h1)(Prelude_foldr(_$$2, _$$3, _$$4.h2)) : _$$3 ));
const Lib_ProcessDecl_processShortData_mkPi = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (Lib_Syntax_RPi(_$$5.h2, Lib_Types_BI(_$$5.h2, _$$5.h3, 1, false), Lib_Syntax_RU(_$$5.h2), _$$6));
const Lib_ProcessDecl_processShortData_mkPi_getArgs = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_ProcessDecl_REC_processShortData_mkPi_getArgs, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_ProcessDecl_REC_processShortData_mkPi_getArgs = ( arg ) => { switch (arg.h6.tag) { case 2: return ( (arg.h6.h2.tag) == (0) ? { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1,  h7: Prelude__$3A$3A_(Prelude__$2C_(arg.h6.h2.h0, arg.h6.h2.h1), arg.h7) } : { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h6), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h6))) + (""))), eta)))) } ); case 0: return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(arg.h6.h1, arg.h7)) }; default: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h6), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h6))) + (""))), eta)))) }; } };
const Lib_ProcessDecl_processPrimType = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), Prelude_maybe(Lib_Syntax_RU(_$$1), ( _$$11 ) => (_$$11), _$$3), Lib_Types_VU(_$$1)), ( ty$27 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(ty$27)); return Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, ty$27, Lib_Types_PrimTCon(arity), Prelude_Nil()); }))));
const Lib_Types_PrimTCon = ( h0 ) => ({ tag: 4,  h0: h0 });
const Lib_ProcessDecl_processPrimFn = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$4, Lib_Types_VU(_$$1)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), ty), ( eta ) => (Lib_Eval_quote(Prelude_length$27(Prelude_Nil()), eta))), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ((((((("pfunc ") + (_$$2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), ty$27))), Prelude_Lin()))) + (" = ")) + (_$$5)) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, _$$3, ( name ) => { const sc$$11 = Lib_TopContext_lookupRaw(name, top); return ( (sc$$11.tag) == (1) ? Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("") + (name)) + (" not in scope"))), eta)))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(sc$$11.h1.h1) ); }), ( used$27 ) => { const arity = Lib_Util_piArity(ty$27); return Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, ty$27, Lib_Types_PrimFn(_$$5, arity, used$27), Prelude_Nil()); }))))))))));
const Lib_Types_PrimFn = ( h0, h1, h2 ) => ({ tag: 5,  h0: h0,  h1: h1,  h2: h2 });
const Lib_ProcessDecl_processClass = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("Class ") + (_$$2)) + (""))), ( _1 ) => { const fields = Lib_ProcessDecl_getSigs(_$$4); const dcName = (("Mk") + (_$$2)) + (""); const tcType = Lib_ProcessDecl_teleToPi(_$$3, Lib_Syntax_RU(_$$1)); const tail = Prelude_foldl(( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi_mkApp(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, eta, eta1))), Lib_Syntax_RVar(_$$1, _$$2), _$$3); const dcType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Prelude_foldr(( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, eta, eta1))), tail, fields)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _2 ) => ((("tcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(tcType))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _3 ) => ((("dcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(dcType))), Prelude_Lin()))) + (""))), ( _3 ) => { const decl = Lib_Syntax_Data(_$$1, _$$2, tcType, Prelude__$3A$3A_(Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(dcName, Prelude_Nil()), dcType), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _4 ) => ("Decl:")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, decl), ( _6 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (0), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, fields, ( $$case ) => { const funType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Lib_Syntax_RPi($$case.h2, Lib_Types_BI($$case.h2, "_", 2, true), tail, $$case.h3.h3)); const autoPat = Prelude_foldl(( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, eta, eta1))), Lib_Syntax_RVar(_$$1, dcName), fields); const lhs = Lib_ProcessDecl_processClass_makeLHS(_$$0, _$$1, _$$2, _$$3, _$$4, null, Lib_Syntax_RVar($$case.h2, $$case.h3.h2), _$$3); const lhs1 = Lib_Syntax_RApp(_$$1, lhs, autoPat, 2); const decl1 = Lib_Syntax_FunDef($$case.h2, $$case.h3.h2, Prelude__$3A$3A_(Prelude__$2C_(lhs1, Lib_Syntax_RVar($$case.h2, $$case.h3.h2)), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _7 ) => ((((("") + ($$case.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(funType))), Prelude_Lin()))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _8 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl1))), Prelude_Lin()))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, Lib_Syntax_TypeSig($$case.h2, Prelude__$3A$3A_($$case.h3.h2, Prelude_Nil()), funType)), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setFlag(Lib_Common_QN(_$$0, $$case.h3.h2), $$case.h2, true), ( _10 ) => (Lib_ProcessDecl_processDecl(_$$0, decl1))))))))); })))))))); }))); }))));
const Lib_ProcessDecl_processClass_makeLHS = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (( (_$$7.tag) == (1) ? Lib_Syntax_RApp(_$$7.h1.h2.h0, Lib_ProcessDecl_processClass_makeLHS(_, _1, _2, _3, _4, _5, _$$6, _$$7.h2), Lib_Syntax_RVar(_$$7.h1.h2.h0, _$$7.h1.h2.h1), 0) : _$$6 ));
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (Lib_Syntax_RApp(_$$8.h2, _$$7, Lib_Syntax_RVar(_$$8.h2, _$$8.h3.h2), 1));
const Lib_ProcessDecl_impTele = ( _$$0 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_ProcessDecl_impTele_foo(_$$0, null, eta)), _$$0));
const Lib_ProcessDecl_impTele_foo = ( _, _1, _$$2 ) => (Prelude__$2C_(Lib_Types_BI(_$$2.h2.h0, _$$2.h2.h1, 0, false), _$$2.h3));
const Lib_ProcessDecl_teleToPi = ( _$$0, _$$1 ) => (( (_$$0.tag) == (1) ? Lib_Syntax_RPi(_$$0.h1.h2.h0, _$$0.h1.h2, _$$0.h1.h3, Lib_ProcessDecl_teleToPi(_$$0.h2, _$$1)) : _$$1 ));
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (Lib_Syntax_RPi(_$$8.h2, Lib_Types_BI(_$$8.h2, _$$8.h3.h2, 1, true), _$$8.h3.h3, _$$9));
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi_mkApp = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10 ) => (Lib_Syntax_RApp(_$$10.h2.h0, _$$9, Lib_Syntax_RVar(_$$10.h2.h0, _$$10.h2.h1), _$$10.h2.h2));
const Lib_ProcessDecl_getSigs = ( _$$0 ) => (bouncer(Lib_ProcessDecl_REC_getSigs, { tag: 1,  h0: _$$0 }));
const Lib_ProcessDecl_REC_getSigs = ( arg ) => (( (arg.h0.tag) == (1) ? ( (arg.h0.h1.tag) == (0) ? ( (arg.h0.h1.h1.tag) == (1) ? { tag: 0,  h0: Prelude__$3A$3A_(Prelude__$2C_(arg.h0.h1.h0, Prelude__$2C_(arg.h0.h1.h1.h1, arg.h0.h1.h2)), Lib_ProcessDecl_getSigs(arg.h0.h2)) } : { tag: 1,  h0: arg.h0.h2 } ) : { tag: 1,  h0: arg.h0.h2 } ) : { tag: 0,  h0: Prelude_Nil() } ));
const Lib_ProcessDecl_processInstance = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ((("Instance ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$2))), Prelude_Lin()))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const tyFC = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(), Prelude_Nil(), Prelude_Nil(), _$$1), _$$2, Lib_Types_VU(_$$1)), ( vty ) => { const sc$$13 = Lib_Util_splitTele(vty); const env = Lib_ProcessDecl_processInstance_getFields_tenv(_$$0, _$$1, _$$2, _$$3, null, null, Prelude_length(sc$$13.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _2 ) => ((("codomain ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$13.h2))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _3 ) => ((("tele is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Util_Prelude_Show$20Lib_Util_Binder$2Cshow(eta)), sc$$13.h3)))) + (""))), ( _3 ) => { const instname = Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$13.h2))), Prelude_Lin()); const sigDecl = Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(instname, Prelude_Nil()), _$$2); const sc$$23 = Lib_TopContext_lookupRaw(instname, top); return ( (sc$$23.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, sigDecl), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setFlag(Lib_Common_QN(_$$0, instname), _$$1, false), ( _5 ) => (Lib_TopContext_addHint(Lib_Common_QN(_$$0, instname)))))), ( _4 ) => { const sc$$24 = Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(( eta ) => (Lib_Elab_collectDecl(eta)), _$$3); if ((sc$$24.tag) == (0)) { const sc$$27 = Lib_Util_funArgs(sc$$13.h2); if ((sc$$27.h2.tag) == (1)) { const sc$$34 = Lib_TopContext_lookup(sc$$27.h2.h1, top); if ((sc$$34.tag) == (0)) { if ((sc$$34.h1.h3.tag) == (1)) { if ((sc$$34.h1.h3.h1.tag) == (1)) { if ((sc$$34.h1.h3.h1.h2.tag) == (0)) { const sc$$49 = Lib_TopContext_lookup(sc$$34.h1.h3.h1.h1, top); return ( (sc$$49.tag) == (0) ? ( (sc$$49.h1.h3.tag) == (2) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$49.h1.h2), ( $$sc ) => (( ($$sc.tag) == (5) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("dcty ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$49.h1.h2))), Prelude_Lin()))) + (""))), ( _5 ) => { const sc$$70 = Lib_Util_funArgs(sc$$13.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((("traverse ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Types_showTm, sc$$70.h3))))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(env, eta)), sc$$70.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _7 ) => ((("args' is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), args$27)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_$$0, _$$1, _$$2, _$$3, null, null, null, null, $$sc, args$27), ( appty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processInstance_getFields(_$$0, _$$1, _$$2, _$$3, null, appty, env, Prelude_Nil()), ( conTele ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, conTele, ( $$case ) => { switch ($$case.h2) { case 1: { const ty$27 = Prelude_foldr(( x ) => (( acc ) => (Lib_Types_Pi(x.h0, x.h1, x.h2, x.h3, x.h4, acc))), $$case.h4, sc$$13.h3); const nm$27 = (((("") + (instname)) + (",")) + ($$case.h1)) + (""); const sc$$89 = Prelude_find(( x ) => (( (x.tag) == (1) ? (x.h1) == ($$case.h1) : false )), sc$$24.h1); return ( (sc$$89.tag) == (0) ? ( (sc$$89.h1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm$27), sc$$89.h1.h0, ty$27, Lib_Types_Axiom, Prelude_Nil()), ( _8 ) => { const decl = Lib_Syntax_FunDef(sc$$89.h1.h0, nm$27, sc$$89.h1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _9 ) => ("***")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _10 ) => ((((("«") + (nm$27)) + ("» : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), ty$27))), Prelude_Lin()))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _11 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(decl)))))))); }) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))) ) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))) ); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); } }), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_mapMaybe(( _$$11 ) => (_$$11), defs), ( decl ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _8 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))), ( _8 ) => { const decl = Lib_Syntax_FunDef(_$$1, instname, Prelude__$3A$3A_(Prelude__$2C_(Lib_Syntax_RVar(_$$1, instname), Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS(_$$0, _$$1, _$$2, _$$3, null, null, null, instname, conTele, Lib_Syntax_RVar(_$$1, sc$$34.h1.h3.h1.h1.h1))), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _9 ) => ("SIGDECL")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _10 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(sigDecl))), Prelude_Lin()))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _11 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))))); }))))))))))))); }) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC($$sc), "dcty not Pi")), eta)))) ))) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))) ) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))) ); } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), sc$$34.h1.h3.h1)))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), sc$$34.h1.h3.h1)))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$13.h2))), Prelude_Lin()))) + (" doesn't appear to be a TCon application"))), eta)))); } } else { return Lib_Types_log(2, ( _5 ) => ((("Forward declaration ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(sigDecl))) + (""))); } }) : Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0), ( _4 ) => { const sc$$24 = Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(( eta ) => (Lib_Elab_collectDecl(eta)), _$$3); if ((sc$$24.tag) == (0)) { const sc$$27 = Lib_Util_funArgs(sc$$13.h2); if ((sc$$27.h2.tag) == (1)) { const sc$$34 = Lib_TopContext_lookup(sc$$27.h2.h1, top); if ((sc$$34.tag) == (0)) { if ((sc$$34.h1.h3.tag) == (1)) { if ((sc$$34.h1.h3.h1.tag) == (1)) { if ((sc$$34.h1.h3.h1.h2.tag) == (0)) { const sc$$49 = Lib_TopContext_lookup(sc$$34.h1.h3.h1.h1, top); return ( (sc$$49.tag) == (0) ? ( (sc$$49.h1.h3.tag) == (2) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude_Nil(), sc$$49.h1.h2), ( $$sc ) => (( ($$sc.tag) == (5) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _5 ) => ((("dcty ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$49.h1.h2))), Prelude_Lin()))) + (""))), ( _5 ) => { const sc$$70 = Lib_Util_funArgs(sc$$13.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _6 ) => ((("traverse ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(Lib_Types_showTm, sc$$70.h3))))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(env, eta)), sc$$70.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _7 ) => ((("args' is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(eta)), args$27)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_$$0, _$$1, _$$2, _$$3, null, null, null, null, $$sc, args$27), ( appty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processInstance_getFields(_$$0, _$$1, _$$2, _$$3, null, appty, env, Prelude_Nil()), ( conTele ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, conTele, ( $$case ) => { switch ($$case.h2) { case 1: { const ty$27 = Prelude_foldr(( x ) => (( acc ) => (Lib_Types_Pi(x.h0, x.h1, x.h2, x.h3, x.h4, acc))), $$case.h4, sc$$13.h3); const nm$27 = (((("") + (instname)) + (",")) + ($$case.h1)) + (""); const sc$$89 = Prelude_find(( x ) => (( (x.tag) == (1) ? (x.h1) == ($$case.h1) : false )), sc$$24.h1); return ( (sc$$89.tag) == (0) ? ( (sc$$89.h1.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm$27), sc$$89.h1.h0, ty$27, Lib_Types_Axiom, Prelude_Nil()), ( _8 ) => { const decl = Lib_Syntax_FunDef(sc$$89.h1.h0, nm$27, sc$$89.h1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _9 ) => ("***")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _10 ) => ((((("«") + (nm$27)) + ("» : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), ty$27))), Prelude_Lin()))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _11 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(decl)))))))); }) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))) ) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))) ); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); } }), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_mapMaybe(( _$$11 ) => (_$$11), defs), ( decl ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(2, ( _8 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _8 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))), ( _8 ) => { const decl = Lib_Syntax_FunDef(_$$1, instname, Prelude__$3A$3A_(Prelude__$2C_(Lib_Syntax_RVar(_$$1, instname), Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS(_$$0, _$$1, _$$2, _$$3, null, null, null, instname, conTele, Lib_Syntax_RVar(_$$1, sc$$34.h1.h3.h1.h1.h1))), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _9 ) => ("SIGDECL")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _10 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(sigDecl))), Prelude_Lin()))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _11 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))))); }))))))))))))); }) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Types_getValFC($$sc), "dcty not Pi")), eta)))) ))) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))) ) : Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))) ); } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), sc$$34.h1.h3.h1)))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(eta)), sc$$34.h1.h3.h1)))) + (""))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } } else { return Lib_Types_MkM(( _5 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(tyFC, (("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(), sc$$13.h2))), Prelude_Lin()))) + (" doesn't appear to be a TCon application"))), eta)))); } } else { return Lib_Types_log(2, ( _5 ) => ((("Forward declaration ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(sigDecl))) + (""))); } }) ); }))); }); }))))));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case 10: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Record", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta)), _$$0.h2)), Prelude__$3A$3A_(Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Prelude_Prelude_Show$20Prim_String, _$$0.h3), Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(eta)), _$$0.h4)), Prelude_Nil()))))))) + (")")); case 9: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Instance", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Prelude_Prelude_Show$20Prim_String, Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(eta)), _$$2))), _$$0.h2)), Prelude_Nil()))))) + (")")); case 8: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Class", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_("...", Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(eta)), _$$0.h3))), Prelude_Nil())))))) + (")")); case 7: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PMixFix", Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$0.h1)), Prelude__$3A$3A_(Prelude_showInt(_$$0.h2), Prelude__$3A$3A_(Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow(_$$0.h3), Prelude_Nil())))))) + (")")); case 6: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PFunc", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$0.h2)), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude__$3A$3A_(_$$0.h4, Prelude_Nil()))))))) + (")")); case 5: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("PType", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, _$$0.h2), Prelude_Nil()))))) + (")")); case 4: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("ShortData", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(eta)), _$$0.h2)), Prelude_Nil()))))) + (")")); case 3: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("Data", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(eta)), _$$0.h3)), Prelude_Nil())))))) + (")")); case 2: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("DCheck", Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")); case 1: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("FunDef", Prelude__$3A$3A_(_$$0.h1, Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta)), _$$0.h2)), Prelude_Nil()))))) + (")")); case 0: return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_("TypeSig", Prelude__$3A$3A_(Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Prelude_Prelude_Show$20Prim_String$2Cshow(eta)), _$$0.h1)), Prelude__$3A$3A_(Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil()))))) + (")")); } };
const Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo = Prelude_MkShow(( eta ) => (Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow(eta)));
const Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_ProcessDecl_REC_processInstance_getFields_tenv_mkRHS, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_ProcessDecl_REC_processInstance_getFields_tenv_mkRHS = ( arg ) => { if ((arg.h8.tag) == (1)) { switch (arg.h8.h1.h2) { case 1: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2,  h9: Lib_Syntax_RApp(arg.h8.h1.h0, arg.h9, Lib_Syntax_RVar(arg.h8.h1.h0, (((("") + (arg.h7)) + (",")) + (arg.h8.h1.h1)) + ("")), 1) }; default: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2,  h9: arg.h9 }; } } else { return { tag: 0,  h0: arg.h9 }; } };
const Lib_ProcessDecl_processInstance_getFields = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => { if ((_$$5.tag) == (5)) { switch (_$$5.h2) { case 1: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( eta ) => (Lib_Util_MkBinder(_$$5.h0, _$$5.h1, 1, _$$5.h3, eta)), Lib_Eval_quote(Prelude_length$27(_$$6), _$$5.h4)), ( bnd ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$5.h0, Prelude_length$27(_$$6), Prelude_Lin()), _$$5.h5.h0), _$$5.h5.h1), ( appsc ) => (Lib_ProcessDecl_processInstance_getFields(_, _1, _2, _3, _4, appsc, _$$6, Prelude__$3A$3A_(bnd, _$$7)))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(Lib_Types_VVar(_$$5.h0, Prelude_length$27(_$$6), Prelude_Lin()), _$$5.h5.h0), _$$5.h5.h1), ( appsc ) => (Lib_ProcessDecl_processInstance_getFields(_, _1, _2, _3, _4, appsc, _$$6, _$$7))); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_reverse()(_$$7)); } };
const Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (( (_$$9.tag) == (1) ? ( (_$$8.tag) == (5) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Eval_eval(Prelude__$3A$3A_(_$$9.h1, _$$8.h5.h0), _$$8.h5.h1), ( bx ) => (Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_, _1, _2, _3, _4, _5, _6, _7, bx, _$$9.h2))) : Lib_Types_MkM(( _8 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_1, (("expected pi type ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))) ) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(_$$8) ));
const Lib_Types_showTm = ( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(eta));
const Lib_TopContext_addHint = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const sc$$2 = Lib_TopContext_lookup(_$$0, top); if ((sc$$2.tag) == (1)) { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0); } else { const sc$$5 = Lib_TopContext_typeName(sc$$2.h1.h2); if ((sc$$5.tag) == (1)) { return Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(sc$$2.h1.h0, (("can't find tcon name for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (""))), eta)))); } else { const xs = Prelude_fromMaybe(Prelude_Nil(), Data_SortedMap_lookupMap$27(sc$$5.h1, top.h2)); const hints = Data_SortedMap_updateMap(sc$$5.h1, Prelude__$3A$3A_(Prelude__$2C_(_$$0, sc$$2.h1.h2), xs), top.h2); return Lib_Types_putTop(Lib_Types_MkTop(top.h0, top.h1, hints, top.h3, top.h4, top.h5, top.h6, top.h7, top.h8)); } } }));
const Lib_TopContext_typeName = ( _$$0 ) => (bouncer(Lib_TopContext_REC_typeName, { tag: 1,  h0: _$$0 }));
const Lib_TopContext_REC_typeName = ( arg ) => { switch (arg.h0.tag) { case 6: switch (arg.h0.h2) { case 1: return { tag: 0,  h0: Prelude_Nothing() }; default: return { tag: 1,  h0: arg.h0.h5 }; } break; case 4: return { tag: 1,  h0: arg.h0.h1 }; case 1: return { tag: 0,  h0: Prelude_Just(arg.h0.h1) }; default: return { tag: 0,  h0: Prelude_Nothing() }; } };
const Lib_Util_Prelude_Show$20Lib_Util_Binder$2Cshow = ( _$$0 ) => ((((((("[") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h2))) + (" : ...]"));
const Lib_ProcessDecl_processInstance_getFields_tenv = ( _, _1, _2, _3, _4, _5, _$$6 ) => { switch (_$$6) { case 0: return Prelude_Nil(); default: { const x = (_$$6) - (1); return Prelude__$3A$3A_(Lib_Types_VVar(Lib_Common_emptyFC, Prelude_natToInt(x), Prelude_Lin()), Lib_ProcessDecl_processInstance_getFields_tenv(_, _1, _2, _3, _4, _5, x)); break; } } };
const Lib_ProcessDecl_processRecord = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _1 ) => ("Record")), ( _1 ) => { const fields = Lib_ProcessDecl_getSigs(_$$5); const dcName = Prelude_fromMaybe((("Mk") + (_$$2)) + (""), _$$4); const tcType = Lib_ProcessDecl_teleToPi(_$$3, Lib_Syntax_RU(_$$1)); const tail = Prelude_foldl(( acc ) => (( bi ) => (Lib_Syntax_RApp(bi.h2.h0, acc, Lib_Syntax_RVar(bi.h2.h0, bi.h2.h1), bi.h2.h2))), Lib_Syntax_RVar(_$$1, _$$2), _$$3); const dcType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Prelude_foldr(( x ) => (( acc ) => (Lib_Syntax_RPi(x.h2, Lib_Types_BI(x.h2, x.h3.h2, 1, true), x.h3.h3, acc))), tail, fields)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _2 ) => ((("tcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(tcType))), Prelude_Lin()))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _3 ) => ((("dcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(dcType))), Prelude_Lin()))) + (""))), ( _3 ) => { const decl = Lib_Syntax_Data(_$$1, _$$2, tcType, Prelude__$3A$3A_(Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(dcName, Prelude_Nil()), dcType), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _4 ) => ("Decl:")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin()))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, decl), ( _6 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(( _$$31 ) => (0), Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, fields, ( $$case ) => { const funType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Lib_Syntax_RPi($$case.h2, Lib_Types_BI($$case.h2, "_", 1, true), tail, $$case.h3.h3)); const autoPat = Prelude_foldl(( acc ) => (( x ) => (Lib_Syntax_RApp(x.h2, acc, Lib_Syntax_RVar(x.h2, x.h3.h2), 1))), Lib_Syntax_RVar(_$$1, dcName), fields); const pname = (".") + ($$case.h3.h2); const lhs = Prelude_foldl(( acc ) => (( x ) => (Lib_Syntax_RApp(x.h2.h0, acc, Lib_Syntax_RVar(x.h2.h0, x.h2.h1), 0))), Lib_Syntax_RVar($$case.h2, pname), _$$3); const lhs1 = Lib_Syntax_RApp(_$$1, lhs, autoPat, 1); const pdecl = Lib_Syntax_FunDef($$case.h2, pname, Prelude__$3A$3A_(Prelude__$2C_(lhs1, Lib_Syntax_RVar($$case.h2, $$case.h3.h2)), Prelude_Nil())); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _7 ) => ((((("") + (pname)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(funType))), Prelude_Lin()))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_log(1, ( _8 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(pdecl))), Prelude_Lin()))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, Lib_Syntax_TypeSig($$case.h2, Prelude__$3A$3A_(pname, Prelude_Nil()), funType)), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_ProcessDecl_processDecl(_$$0, pdecl), ( _10 ) => (Lib_TopContext_setFlag(Lib_Common_QN(_$$0, pname), $$case.h2, true))))))))); })))))))); }))); }))));
const Main_importHints = ( _$$0 ) => (( (_$$0.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(Lib_Types_Prelude_Eq$20Lib_Types_EFlag, false, _$$0.h1.h4), ( _ ) => (Lib_TopContext_addHint(_$$0.h1.h1))), ( _ ) => (Main_importHints(_$$0.h2))) : Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) ));
const Main_parseDecls = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Main_REC_parseDecls, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Main_REC_parseDecls = ( arg ) => { if ((arg.h2.tag) == (1)) { const sc$$8 = Lib_Parser_Impl_partialParse(arg.h0, Lib_Parser_Impl_sameLevel(Lib_Parser_parseDecl), arg.h1, arg.h2); return ( (sc$$8.tag) == (1) ? { tag: 1,  h0: arg.h0,  h1: sc$$8.h2.h3.h2,  h2: sc$$8.h2.h3.h3,  h3: Prelude__$3A$3C_(arg.h3, sc$$8.h2.h2) } : { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn(Lib_Common_showError("", sc$$8.h2.h2))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_TopContext_addError(sc$$8.h2.h2), ( _1 ) => (Main_parseDecls(arg.h0, arg.h1, Main_parseDecls_recover(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, arg.h2.h2, null, sc$$8.h2.h3), arg.h3))))) } ); } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Prelude__$3C$3E$3E_(arg.h3, Prelude_Nil()), arg.h1)) }; } };
const Main_parseDecls_recover = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (bouncer(Main_REC_parseDecls_recover, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8 }));
const Main_REC_parseDecls_recover = ( arg ) => { if ((arg.h8.tag) == (1)) { const sc$$12 = ((arg.h8.h1.h2.h1) == (0)) && (Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_Bounds$2C_$3D$3D_(arg.h8.h1.h2, arg.h5.h2))); switch (sc$$12) { case true: return { tag: 0,  h0: Prelude__$3A$3A_(arg.h8.h1, arg.h8.h2) }; case false: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2 }; } } else { return { tag: 0,  h0: Prelude_Nil() }; } };
const Lib_Common_Prelude_Eq$20Lib_Common_Bounds$2C_$3D$3D_ = ( _$$0, _$$1 ) => (((_$$0.h0) == (_$$1.h0)) && (((_$$0.h1) == (_$$1.h1)) && (((_$$0.h2) == (_$$1.h2)) && ((_$$0.h3) == (_$$1.h3)))));
const Lib_Syntax_Record = ( h0, h1, h2, h3, h4 ) => ({ tag: 10,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(_$$1, last, toks, com, ops))))))));
const Lib_Parser_Impl_OK = ( h1, h2, h3, h4, h5 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Parser_Impl_P = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Lib_Parser_Impl_keyword$27 = ( _$$0 ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( _$$3 ) => (0), Lib_Parser_Impl_satisfy(( t ) => (((t.h1.h1) == (_$$0)) && (((Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0)) == (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(2))) || (((Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0)) == (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(8))) || ((Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0)) == (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(4)))))), (("Expected ") + (_$$0)) + (""))));
const Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow = ( _$$0 ) => { switch (_$$0) { case 20: return "EndInterp"; case 19: return "StartInterp"; case 18: return "EndQuote"; case 17: return "StartQuote"; case 16: return "EOI"; case 15: return "RBrace"; case 14: return "Semi"; case 13: return "LBrace"; case 12: return "Projection"; case 11: return "Pragma"; case 10: return "Comment"; case 9: return "Space"; case 8: return "Symbol"; case 7: return "JSLit"; case 6: return "String"; case 5: return "Character"; case 4: return "Number"; case 3: return "MixFix"; case 2: return "Keyword"; case 1: return "UIdent"; case 0: return "Ident"; } };
const Lib_Parser_Impl_satisfy = ( _$$0, _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { if ((toks.tag) == (1)) { const sc$$11 = _$$0(toks.h1); switch (sc$$11) { case true: return Lib_Parser_Impl_OK(toks.h1.h1.h1, toks.h1.h2, toks.h2, true, ops); case false: return Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(col.h0, toks, (((((("") + (_$$1)) + (" at ")) + (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(toks.h1.h1.h0))) + (":")) + (toks.h1.h1.h1)) + ("")), last, toks, com, ops); } } else { return Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(col.h0, toks, (("") + (_$$1)) + (" at EOF")), last, toks, com, ops); } }))))));
const Lib_Parser_Impl_perror = ( _$$0, _$$1, _$$2 ) => (( (_$$1.tag) == (1) ? Lib_Common_E(Lib_Common_MkFC(_$$0, _$$1.h1.h2), _$$2) : Lib_Common_E(Lib_Common_MkFC(_$$0, Lib_Common_MkBounds(0, 0, 0, 0)), _$$2) ));
const Lib_Parser_Impl_Fail = ( h1, h2, h3, h4, h5, h6 ) => ({ tag: 1,  h0: null,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5,  h6: h6 });
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap = ( _$$2, _$$3 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Result$2Cmap(_$$2, _$$3.h1(last)(toks)(com)(ops)(col)))))))));
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Result$2Cmap = ( _$$2, _$$3 ) => (( (_$$3.tag) == (1) ? Lib_Parser_Impl_Fail(_$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, _$$3.h5, _$$3.h6) : Lib_Parser_Impl_OK(_$$2(_$$3.h1), _$$3.h2, _$$3.h3, _$$3.h4, _$$3.h5) ));
const Lib_Parser_Impl_indented = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( indent ) => { if ((toks.tag) == (1)) { const sc$$13 = Prelude__$2C_(toks.h1.h2.h0, toks.h1.h2.h1); const sc$$18 = (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$13.h3, indent.h1.h1), 2)) || ((sc$$13.h2) == (indent.h1.h0)); switch (sc$$18) { case true: return _$$1.h1(last)(toks)(com)(ops)(indent); case false: return Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(indent.h0, toks, "unexpected outdent"), last, toks, com, ops); } } else { return _$$1.h1(last)(toks)(com)(ops)(indent); } }))))));
const Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_ = ( _$$1, _$$2 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$12 = _$$1.h1(last)(toks)(false)(ops)(col); if ((sc$$12.tag) == (1)) { switch (sc$$12.h1) { case true: return Lib_Parser_Impl_Fail(true, sc$$12.h2, sc$$12.h3, sc$$12.h4, sc$$12.h5, sc$$12.h6); default: switch (sc$$12.h5) { case true: return Lib_Parser_Impl_Fail(sc$$12.h1, sc$$12.h2, sc$$12.h3, sc$$12.h4, true, sc$$12.h6); case false: return _$$2.h1(last)(toks)(com)(sc$$12.h6)(col); } break; } } else { return Lib_Parser_Impl_OK(sc$$12.h1, sc$$12.h2, sc$$12.h3, com, sc$$12.h5); } }))))));
const Lib_Parser_arrow = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("->")), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("→")));
const Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_ = ( _$$2, _$$3 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$13 = _$$2.h1(last)(toks)(com)(ops)(col); if ((sc$$13.tag) == (1)) { return Lib_Parser_Impl_Fail(sc$$13.h1, sc$$13.h2, sc$$13.h3, sc$$13.h4, sc$$13.h5, sc$$13.h6); } else { const sc$$20 = _$$3.h1(sc$$13.h2)(sc$$13.h3)(sc$$13.h4)(sc$$13.h5)(col); return ( (sc$$20.tag) == (1) ? Lib_Parser_Impl_Fail(sc$$20.h1, sc$$20.h2, sc$$20.h3, sc$$20.h4, sc$$20.h5, sc$$20.h6) : Lib_Parser_Impl_OK(sc$$13.h1(sc$$20.h1), sc$$20.h2, sc$$20.h3, sc$$20.h4, sc$$20.h5) ); } }))))));
const Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser = Prelude_MkApplicative(( a ) => (( eta ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(eta))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(eta, eta1))))));
const Prelude_MkFunctor = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser = Prelude_MkFunctor(( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(eta, eta1))))));
const Prelude__$2A$3E_ = ( _$$3, _$$4, _$$5, _$$6 ) => (Prelude__$3C$2A$3E_(_$$4)(null)(null)(Prelude_map(_$$3)(null)(null)(( _$$31 ) => (( _$$1 ) => (_$$1)))(_$$5))(_$$6));
const Prelude_map = ( _$$1 ) => (( a ) => (( b ) => (_$$1.h1(null)(null))));
const Lib_Parser_optional = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (Prelude_Just(eta)), _$$1), Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_Nothing())));
const Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind = ( _$$2, _$$3 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$11 = _$$2.h1(last)(toks)(com)(ops)(col); return ( (sc$$11.tag) == (1) ? Lib_Parser_Impl_Fail(sc$$11.h1, sc$$11.h2, sc$$11.h3, sc$$11.h4, sc$$11.h5, sc$$11.h6) : Lib_Parser_Impl_runP(_$$3(sc$$11.h1))(sc$$11.h2)(sc$$11.h3)(sc$$11.h4)(sc$$11.h5)(col) ); }))))));
const Lib_Parser_Impl_runP = ( _$$1 ) => (_$$1.h1);
const Lib_Parser_term_apply = ( _, _$$1, _$$2 ) => { if ((_$$2.tag) == (1)) { const u = Lib_Parser_term_apply(_, _$$2.h1.h3, _$$2.h2); const _sc$$1 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(u); const _sc$$2 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1); return Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$2.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$2.h1, _sc$$1.h1)), _$$1, u, 1); } else { return _$$1; } };
const Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_ = ( _$$0, _$$1 ) => { let a$27; const sc$$2 = (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0.h0, _$$1.h0), 0)) || (((_$$0.h0) == (_$$1.h0)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0.h1, _$$1.h1), 0))); switch (sc$$2) { case true: { a$27 = _$$0; break; } case false: { a$27 = _$$1; break; } } let b$27; const sc$$3 = (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0.h2, _$$1.h2), 0)) || (((_$$0.h2) == (_$$1.h2)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0.h3, _$$1.h3), 0))); switch (sc$$3) { case true: { b$27 = _$$1; break; } case false: { b$27 = _$$0; break; } } return Lib_Common_MkBounds(a$27.h0, a$27.h1, b$27.h2, b$27.h3); };
const Lib_Parser_Impl_fail = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(col.h0, toks, _$$1), last, toks, com, ops))))))));
const Lib_Parser_pratt = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_pratt_projectHead_runProject_runRule_runPrefix(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, _$$2, _$$3, _$$4), ( $$sc ) => { const sc$$15 = Lib_Parser_pratt_projectHead(_$$0, _$$1, _$$2, _$$3, _$$4, null, $$sc.h2, $$sc.h3); const spine = Lib_Parser_pratt_projectHead_runProject(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, sc$$15.h3); if ((spine.tag) == (1)) { switch (spine.h1.h2) { case 1: { if ((spine.h1.h3.h3.tag) == (0)) { const sc$$35 = (spine.h1.h3.h3.h1) == (_$$2); switch (sc$$35) { case true: return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(sc$$15.h2, spine)); case false: { const sc$$36 = Data_SortedMap_lookupMap$27(spine.h1.h3.h3.h1, _$$0); if ((sc$$36.tag) == (1)) { const sc$$38 = Prelude_isPrefixOf(".", spine.h1.h3.h3.h1); switch (sc$$38) { case true: { const _sc$$10 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(spine.h1.h3.h3); const _sc$$11 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2); return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$11.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$11.h1, _sc$$10.h1)), spine.h1.h3.h3, sc$$15.h2, 1), spine.h2); break; } case false: { const _sc$$10 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(spine.h1.h3.h3); const _sc$$11 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2); return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$11.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$11.h1, _sc$$10.h1)), sc$$15.h2, spine.h1.h3.h3, 1), spine.h2); break; } } } else { switch (sc$$36.h1.h3) { case false: { const sc$$44 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$36.h1.h1, _$$1), 0); switch (sc$$44) { case true: return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(sc$$15.h2, spine)); case false: { const _sc$$22 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2); return Lib_Parser_pratt_projectHead_runProject_runRule(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, sc$$36.h1.h1, sc$$36.h1.h2, _$$2, sc$$36.h1.h4, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$22.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$22.h1, spine.h1.h3.h2.h1)), Lib_Syntax_RVar(spine.h1.h3.h2, sc$$36.h1.h0), sc$$15.h2, 1), spine.h2); break; } } break; } default: return Lib_Parser_Impl_fail("expected operator"); } } break; } } } else { const _sc$$10 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(spine.h1.h3.h3); const _sc$$11 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2); return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$11.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$11.h1, _sc$$10.h1)), sc$$15.h2, spine.h1.h3.h3, spine.h1.h2), spine.h2); } break; } default: { const _sc$$9 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(spine.h1.h3.h3); const _sc$$10 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2); return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$10.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$10.h1, _sc$$9.h1)), sc$$15.h2, spine.h1.h3.h3, spine.h1.h2), spine.h2); break; } } } else { return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(sc$$15.h2, Prelude_Nil())); } }));
const Lib_Parser_pratt_projectHead_runProject_runRule = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11, _$$12, _$$13 ) => { if ((_$$11.tag) == (1)) { switch (_$$11.h1) { case "": { if ((_$$11.h2.tag) == (0)) { let pr; switch (_$$9) { case 1: { pr = _$$8; break; } default: { pr = (_$$8) + (1); break; } } return ( (_$$13.tag) == (1) ? Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_pratt(_, pr, _$$10, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => { const _sc$$10 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC($$sc.h2); const _sc$$11 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12); return Lib_Parser_pratt(_, _1, _$$10, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$11.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$11.h1, _sc$$10.h1)), _$$12, $$sc.h2, 1), $$sc.h3); }) : Lib_Parser_Impl_fail("trailing operator") ); } else { return ( (_$$13.tag) == (1) ? Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_pratt(_, 0, _$$11.h1, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => { if (($$sc.h3.tag) == (1)) { if (($$sc.h3.h1.h3.h3.tag) == (0)) { const sc$$49 = ($$sc.h3.h1.h3.h3.h1) == (_$$11.h1); switch (sc$$49) { case true: { const _sc$$23 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC($$sc.h2); const _sc$$24 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12); return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11.h2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$24.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$24.h1, _sc$$23.h1)), _$$12, $$sc.h2, 1), $$sc.h3.h2); break; } case false: return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } } else { return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } } else { return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } }) : Lib_Parser_Impl_fail("short") ); } break; } default: return ( (_$$13.tag) == (1) ? Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_pratt(_, 0, _$$11.h1, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => { if (($$sc.h3.tag) == (1)) { if (($$sc.h3.h1.h3.h3.tag) == (0)) { const sc$$49 = ($$sc.h3.h1.h3.h3.h1) == (_$$11.h1); switch (sc$$49) { case true: { const _sc$$22 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC($$sc.h2); const _sc$$23 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12); return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11.h2, Lib_Syntax_RApp(Lib_Common_MkFC(_sc$$23.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(_sc$$23.h1, _sc$$22.h1)), _$$12, $$sc.h2, 1), $$sc.h3.h2); break; } case false: return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } } else { return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } } else { return Lib_Parser_Impl_fail((("expected ") + (_$$11.h1)) + ("")); } }) : Lib_Parser_Impl_fail("short") ); } } else { return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(_$$12, _$$13)); } };
const Prelude_True = true;
const Prelude_False = false;
const Prelude_isPrefixOf = (pfx, s) => s.startsWith(pfx) ? Prelude_True : Prelude_False;
const Lib_Parser_pratt_projectHead_runProject = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => (bouncer(Lib_Parser_REC_pratt_projectHead_runProject, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7 }));
const Lib_Parser_REC_pratt_projectHead_runProject = ( arg ) => { if ((arg.h7.tag) == (1)) { switch (arg.h7.h1.h2) { case 1: { if ((arg.h7.h2.tag) == (1)) { switch (arg.h7.h2.h1.h2) { case 1: { if ((arg.h7.h2.h1.h3.h3.tag) == (0)) { const sc$$32 = Prelude_isPrefixOf(".", arg.h7.h2.h1.h3.h3.h1); switch (sc$$32) { case true: { const _sc$$16 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h7.h1.h3.h3); return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: Prelude__$3A$3A_(Prelude__$2C_(1, Prelude__$2C_(arg.h7.h1.h3.h2, Lib_Syntax_RApp(Lib_Common_MkFC(arg.h7.h2.h1.h3.h3.h0.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(arg.h7.h2.h1.h3.h3.h0.h1, _sc$$16.h1)), Lib_Syntax_RVar(arg.h7.h2.h1.h3.h3.h0, arg.h7.h2.h1.h3.h3.h1), arg.h7.h1.h3.h3, 1))), arg.h7.h2.h2) }; break; } case false: return { tag: 0,  h0: Prelude__$3A$3A_(arg.h7.h1, Prelude__$3A$3A_(arg.h7.h2.h1, arg.h7.h2.h2)) }; } } else { return { tag: 0,  h0: arg.h7 }; } break; } default: return { tag: 0,  h0: arg.h7 }; } } else { return { tag: 0,  h0: arg.h7 }; } break; } default: return { tag: 0,  h0: arg.h7 }; } } else { return { tag: 0,  h0: arg.h7 }; } };
const Lib_Parser_pratt_projectHead = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_Parser_REC_pratt_projectHead, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_Parser_REC_pratt_projectHead = ( arg ) => { if ((arg.h7.tag) == (1)) { switch (arg.h7.h1.h2) { case 1: { if ((arg.h7.h1.h3.h3.tag) == (0)) { const sc$$21 = Prelude_isPrefixOf(".", arg.h7.h1.h3.h3.h1); switch (sc$$21) { case true: { const _sc$$5 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h6); return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: Lib_Syntax_RApp(Lib_Common_MkFC(arg.h7.h1.h3.h3.h0.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(arg.h7.h1.h3.h3.h0.h1, _sc$$5.h1)), Lib_Syntax_RVar(arg.h7.h1.h3.h3.h0, arg.h7.h1.h3.h3.h1), arg.h6, 1),  h7: arg.h7.h2 }; break; } case false: return { tag: 0,  h0: Prelude__$2C_(arg.h6, arg.h7) }; } } else { return { tag: 0,  h0: Prelude__$2C_(arg.h6, arg.h7) }; } break; } default: return { tag: 0,  h0: Prelude__$2C_(arg.h6, arg.h7) }; } } else { return { tag: 0,  h0: Prelude__$2C_(arg.h6, arg.h7) }; } };
const Lib_Parser_pratt_projectHead_runProject_runRule_runPrefix = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11 ) => { if ((_$$10.tag) == (0)) { const sc$$14 = Data_SortedMap_lookupMap$27(_$$10.h1, _); if ((sc$$14.tag) == (0)) { switch (sc$$14.h1.h3) { case true: return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, sc$$14.h1.h1, sc$$14.h1.h2, _$$9, sc$$14.h1.h4, Lib_Syntax_RVar(_$$10.h0, sc$$14.h1.h0), _$$11); default: return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(_3, _$$11)); } } else { return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(_3, _$$11)); } } else { return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(_$$10, _$$11)); } };
const Lib_Syntax_RUpdateRec = ( h0, h1, h2 ) => ({ tag: 15,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_ModifyField = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_AssignField = ( h0, h1, h2 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_dbraces = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("{{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(_$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("}}")), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(t))))))));
const Lib_Parser_braces = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(_$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("}")), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(t))))))));
const Lib_Parser_Impl_getPos = Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( indent ) => (( (toks.tag) == (1) ? Lib_Parser_Impl_OK(Lib_Common_MkFC(indent.h0, toks.h1.h2), last, toks, com, ops) : Lib_Parser_Impl_OK(Lib_Common_MkFC(indent.h0, last), last, toks, com, ops) )))))));
const Lib_Parser_Impl_many = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_some(_$$1), Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_Nil())));
const Lib_Parser_Impl_some = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(_$$1, ( x ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(_$$1), ( xs ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$3A$3A_(x, xs)))))));
const Lib_Parser_Impl_getOps = Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(ops, last, toks, com, ops)))))));
const Lib_Syntax_RIf = ( h0, h1, h2, h3 ) => ({ tag: 12,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_parseIfThen = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("if")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( a ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("then")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( b ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("else")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( c ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RIf(fc, a, b, c))))))))))))))));
const Lib_Syntax_DoExpr = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Syntax_DoArrow = ( h0, h1, h2, h3 ) => ({ tag: 2,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_caseAlt = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(0), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=>")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( t ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_MkAlt(pat, t))))))))));
const Lib_Parser_Impl_sameLevel = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( indent ) => { if ((toks.tag) == (1)) { const sc$$13 = Prelude__$2C_(toks.h1.h2.h0, toks.h1.h2.h1); const sc$$25 = (sc$$13.h3) == (indent.h1.h1); switch (sc$$25) { case true: return _$$1.h1(last)(toks)(com)(ops)(Lib_Common_MkFC(indent.h0, toks.h1.h2)); case false: { const sc$$26 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, indent.h1.h1, sc$$13.h3), 0); switch (sc$$26) { case true: return Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(indent.h0, toks, "unexpected indent"), last, toks, com, ops); case false: return Lib_Parser_Impl_Fail(false, Lib_Parser_Impl_perror(indent.h0, toks, "unexpected indent"), last, toks, com, ops); } break; } } } else { return _$$1.h1(last)(toks)(com)(ops)(indent); } }))))));
const Lib_Parser_Impl_startBlock = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( indent ) => { if ((toks.tag) == (1)) { const sc$$13 = Prelude__$2C_(toks.h1.h2.h0, toks.h1.h2.h1); return _$$1.h1(last)(toks)(com)(ops)(Lib_Common_MkFC(indent.h0, Prelude_ite(Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$13.h3, indent.h1.h1), 2)), Lib_Common_MkBounds(sc$$13.h2, (indent.h1.h1) + (1), 0, 0), toks.h1.h2))); } else { return _$$1.h1(last)(toks)(com)(ops)(indent); } }))))));
const Lib_Parser_doArrow = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( left ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("<-"))), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( right ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_DoArrow(fc, left, right, alts)))))) : Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_DoExpr(fc, left)) )))))));
const Lib_Syntax_DoLet = ( h0, h1, h2 ) => ({ tag: 1,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_Impl_token$27 = ( _$$0 ) => (Lib_Parser_Impl_satisfy(( t ) => ((Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0)) == (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(_$$0))), (("Expected a ") + (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(_$$0))) + (" token")));
const Lib_Parser_ident = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(0)), Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(3)));
const Lib_Parser_doLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( tm ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_DoLet(fc, nm, tm))))))))))));
const Lib_Syntax_RDo = ( h0, h1 ) => ({ tag: 11,  h0: h0,  h1: h1 });
const Lib_Parser_Impl_try = ( _$$1 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$9 = _$$1.h1(last)(toks)(com)(ops)(col); return ( (sc$$9.tag) == (1) ? Lib_Parser_Impl_Fail(sc$$9.h1, sc$$9.h2, sc$$9.h3, sc$$9.h4, false, sc$$9.h6) : sc$$9 ); }))))));
const Lib_Parser_doCaseLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_try(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("("))))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( bodyFC ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Lib_Syntax_RDo(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_some(Lib_Parser_Impl_sameLevel(Lib_Parser_doStmt))), ( body ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_DoExpr(fc, Lib_Syntax_RCase(fc, sc, Prelude__$3A$3A_(Lib_Syntax_MkAlt(pat, body), alts))))))))))))))))))))));
const Lib_Parser_doStmt = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_doCaseLet, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_doLet, Lib_Parser_doArrow));
const Prelude__$3C$2A_ = ( _$$3, _$$4, _$$5 ) => (Prelude__$3C$2A$3E_(_$$3)(null)(null)(Prelude__$3C$2A$3E_(_$$3)(null)(null)(Prelude_return(_$$3)(null)(( _$$2 ) => (( _$$31 ) => (_$$2))))(_$$4))(_$$5));
const Lib_Parser_doExpr = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Lib_Syntax_RDo(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("do"))), Lib_Parser_Impl_startBlock(Lib_Parser_Impl_some(Lib_Parser_Impl_sameLevel(Lib_Parser_doStmt))));
const Lib_Parser_lamExpr_mkLam = ( _, _$$1, _$$2 ) => (Lib_Syntax_RLam(_$$1.h2, Lib_Types_BI(_$$1.h2, _$$1.h3.h3.h2, _$$1.h3.h2, true), _$$2));
const Lib_Parser_uident = Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(1));
const Lib_Parser_pLamArg_impArg_autoArg_expArg = ( _, _1, _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_parenWrap(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), ( _3 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(1, Prelude__$2C_(nm, ty))))))));
const Lib_Parser_parenWrap = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("(")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(_$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(t))))))));
const Lib_Parser_pLamArg_impArg_autoArg = ( _, _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_dbraces(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), ( _2 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(2, Prelude__$2C_(nm, ty))))))));
const Lib_Parser_pLamArg_impArg = ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_braces(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(0, Prelude__$2C_(nm, ty))))))));
const Lib_Parser_pLamArg = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_pLamArg_impArg(null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_pLamArg_impArg_autoArg(null, null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_pLamArg_impArg_autoArg_expArg(null, null, null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( x ) => (Prelude__$2C_(1, Prelude__$2C_(x, Prelude_Nothing()))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_uident)), Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("_")), Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(1, Prelude__$2C_("_", Prelude_Nothing()))))))));
const Lib_Parser_addPos = ( _$$1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Prelude__$2C_(eta, eta1))), Lib_Parser_Impl_getPos), _$$1));
const Lib_Parser_lamExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( pos ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("\\")), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("λ"))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_some(Lib_Parser_addPos(Lib_Parser_pLamArg)), ( args ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=>")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_foldr(( eta ) => (( eta1 ) => (Lib_Parser_lamExpr_mkLam(null, eta, eta1))), scope, args))))))))))));
const Lib_Parser_caseLamExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_try(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("\\")), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("λ"))), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("case")))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_some(Lib_Parser_Impl_sameLevel(Lib_Parser_caseAlt))), ( alts ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RLam(fc, Lib_Types_BI(fc, "$case", 1, true), Lib_Syntax_RCase(fc, Lib_Syntax_RVar(fc, "$case"), alts)))))))));
const Lib_Parser_letExpr_mkLet = ( _, _$$1, _$$2 ) => (Lib_Syntax_RLet(_$$2.h3.h2, _$$2.h2, Prelude_fromMaybe(Lib_Syntax_RImplicit(_$$2.h3.h2), _$$2.h3.h3.h2), _$$2.h3.h3.h3, _$$1));
const Lib_Parser_letExpr_mkLet_letAssign = ( _, _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_ident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), Lib_Parser_typeExpr)), ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( t ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(name, Prelude__$2C_(fc, Prelude__$2C_(ty, t)))))))))))))));
const Lib_Parser_letExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_some(Lib_Parser_Impl_sameLevel(Lib_Parser_letExpr_mkLet_letAssign(null, null)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_keyword$27("in"), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Parser_letExpr_mkLet(null, eta, eta1))), scope, Prelude_reverse()(alts)))))))))));
const Lib_Parser_caseLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_try(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("("))))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("in")), ( _3 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( body ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RCase(fc, sc, Prelude__$3A$3A_(Lib_Syntax_MkAlt(pat, body), alts)))))))))))))))))))));
const Lib_Parser_caseExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("case")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("of")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_some(Lib_Parser_Impl_sameLevel(Lib_Parser_caseAlt))), ( alts ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RCase(fc, sc, alts))))))))))));
const Prelude__$3C$$_ = ( _$$3, _$$4, _$$5 ) => (Prelude_map(_$$3)(null)(null)(( _$$31 ) => (_$$4))(_$$5));
const Lib_Parser_updateClause = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, true, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":="))), Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, false, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("$=")))), ( op ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( tm ) => { switch (op) { case true: return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_AssignField(fc, nm, tm)); default: return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_ModifyField(fc, nm, tm)); } })))))));
const Lib_Parser_Impl_sepBy = ( _$$2, _$$3 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Prelude__$3A$3A_(eta, eta1))), _$$3), Lib_Parser_Impl_many(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, _$$2, _$$3))));
const Lib_Syntax_RHole = ( h0 ) => ({ tag: 10,  h0: h0 });
const Prelude_strIndex = (s, ix) => s[ix];
const Lib_Syntax_RLit = ( h0, h1 ) => ({ tag: 7,  h0: h0,  h1: h1 });
const Lib_Parser_charLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(5)), ( v ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RLit(fc, Lib_Types_LChar(Prelude_strIndex(v, 0))))))));
const Lib_Parser_stringLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(6)), ( t ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RLit(fc, Lib_Types_LString(t)))))));
const Lib_Parser_interpString_append = ( _, _$$1, _$$2 ) => { const fc = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1); const _sc$$0 = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$2); return Lib_Syntax_RApp(Lib_Common_MkFC(fc.h0, Lib_Common_Prelude_Add$20Lib_Common_Bounds$2C_$2B_(fc.h1, _sc$$0.h1)), Lib_Syntax_RApp(fc, Lib_Syntax_RVar(fc, "_++_"), _$$1, 1), _$$2, 1); };
const Lib_Parser_interp = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(19)), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( tm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(20)), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(tm)))))));
const Lib_Parser_interpString = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( _$$3 ) => (0), Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(17))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( part ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_stringLit, Lib_Parser_interp)), ( parts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( _$$3 ) => (0), Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(18))), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_foldl(( eta ) => (( eta1 ) => (Lib_Parser_interpString_append(null, eta, eta1))), part, parts))))))))));
const Prelude_stringToInt = (s) => {
  let rval = Number(s)
  if (isNaN(rval)) throw new Error(s + " is NaN")
  return rval
};
const Lib_Parser_intLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(4)), ( t ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RLit(fc, Lib_Types_LInt(Prelude_stringToInt(t))))))));
const Lib_Parser_lit = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_intLit, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_interpString, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_stringLit, Lib_Parser_charLit)));
const Lib_Syntax_RAs = ( h0, h1, h2 ) => ({ tag: 14,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_asAtom = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("@")), Lib_Parser_parenWrap(Lib_Parser_typeExpr))), ( asPat ) => (( (asPat.tag) == (1) ? Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RVar(fc, nm)) : Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RAs(fc, nm, asPat.h1)) )))))));
const Lib_Parser_recordUpdate = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("[")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_sepBy(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(";")), Lib_Parser_updateClause), ( clauses ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("]")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_atom), ( tm ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RUpdateRec(fc, clauses, tm))))))))))));
const Lib_Parser_atom = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(0), ( _ ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (Lib_Syntax_RU(eta)), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("U"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_asAtom, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Lib_Syntax_RVar(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_uident), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Lib_Syntax_RVar(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(12))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_lit, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (Lib_Syntax_RImplicit(eta)), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("_"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (Lib_Syntax_RHole(eta)), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("?"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parenWrap(Lib_Parser_typeExpr), Lib_Parser_recordUpdate))))))))));
const Lib_Parser_pArg = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( x ) => (Prelude__$2C_(0, Prelude__$2C_(fc, x))), Lib_Parser_braces(Lib_Parser_typeExpr)), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( x ) => (Prelude__$2C_(2, Prelude__$2C_(fc, x))), Lib_Parser_dbraces(Lib_Parser_typeExpr)), Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( x ) => (Prelude__$2C_(1, Prelude__$2C_(fc, x))), Lib_Parser_atom)))));
const Lib_Parser_parseOp = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getOps, ( ops ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_atom, ( hd ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_pArg), ( rest ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_pratt(ops, 0, "", hd, rest), ( $$sc ) => (( ($$sc.h3.tag) == (0) ? Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn($$sc.h2) : Lib_Parser_Impl_fail("extra stuff") )))))))))));
const Lib_Parser_term$27 = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_caseExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_caseLet, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_letExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_caseLamExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_lamExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_doExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseIfThen, Lib_Parser_parseOp)))))));
const Lib_Parser_term = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term$27, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (Prelude__$2C_(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("$"))), Lib_Parser_term$27)), ( rest ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Parser_term_apply(null, t, rest))))));
const Lib_Parser_forAll_mkPi = ( _, _$$1, _$$2 ) => (Lib_Syntax_RPi(_$$1.h2, Lib_Types_BI(_$$1.h2, _$$1.h3, 0, false), Lib_Syntax_RImplicit(_$$1.h2), _$$2));
const Lib_Parser_varname = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_uident, Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("_")), Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn("_"))));
const Lib_Parser_forAll = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("forall")), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("∀"))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_some(Lib_Parser_addPos(Lib_Parser_varname)), ( all ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(".")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_foldr(( eta ) => (( eta1 ) => (Lib_Parser_forAll_mkPi(null, eta, eta1))), scope, all))))))))));
const Lib_Parser_binders_mkBind = ( _, _$$1, _$$2 ) => (Lib_Syntax_RPi(_$$1.h2.h0, _$$1.h2, _$$1.h3, _$$2));
const Lib_Parser_ebind_makeBind = ( _, _$$1, _$$2, _$$3 ) => (Prelude__$2C_(Lib_Types_BI(_$$3.h2, _$$3.h3, 1, _$$1), _$$2));
const Lib_Parser_quantity = Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (Prelude_fromMaybe(true, eta)), Lib_Parser_optional(Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, false, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("0")))));
const Lib_Parser_ebind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("(")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_quantity, ( quant ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_try(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_some(Lib_Parser_addPos(Lib_Parser_varname)), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")))), ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Parser_ebind_makeBind(null, quant, ty, eta)), $$sc))))))))))));
const Lib_Parser_ibind_makeBind = ( _, _$$1, _$$2, _$$3 ) => (Prelude__$2C_(Lib_Types_BI(_$$3.h2, _$$3.h3, 0, _$$1), Prelude_fromMaybe(Lib_Syntax_RImplicit(_$$3.h2), _$$2)));
const Lib_Parser_ibind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_quantity, ( quant ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_some(Lib_Parser_addPos(Lib_Parser_varname)), ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), Lib_Parser_typeExpr)), ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("}")), ( _1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Parser_ibind_makeBind(null, quant, ty, eta)), $$sc))))))))))));
const Lib_Parser_abind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("{{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_try(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_addPos(Lib_Parser_varname), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":"))))), ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("}}")), ( _1 ) => (( (name.tag) == (1) ? Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(Lib_Types_BI(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), "_", 2, true), ty), Prelude_Nil())) : Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$3A$3A_(Prelude__$2C_(Lib_Types_BI(name.h1.h2, name.h1.h3, 2, true), ty), Prelude_Nil())) )))))))));
const Lib_Parser_binders = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_abind, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ibind, Lib_Parser_ebind))), ( binds ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_arrow, ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_foldr(( eta ) => (( eta1 ) => (Lib_Parser_binders_mkBind(null, eta, eta1))), scope, Prelude_Prelude_Monad$20Prelude_List$2Cbind(binds, ( _$$1 ) => (_$$1))))))))));
const Lib_Parser_typeExpr = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_binders, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_forAll, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_term, ( exp ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_arrow, Lib_Parser_typeExpr)), ( scope ) => (( (scope.tag) == (1) ? Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(exp) : Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_RPi(fc, Lib_Types_BI(fc, "_", 1, true), exp, scope.h1)) )))))))));
const Lib_Parser_parseSig = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Syntax_TypeSig(eta, eta1, eta2)))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_try(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_some(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_uident, Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(12))))), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":"))))), Lib_Parser_typeExpr);
const Lib_Parser_nakedBind_makeBind = ( _, _$$1 ) => (Prelude__$2C_(Lib_Types_BI(_$$1.h2, _$$1.h3, 1, true), Lib_Syntax_RImplicit(_$$1.h2)));
const Lib_Parser_nakedBind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_some(Lib_Parser_addPos(Lib_Parser_varname)), ( $$sc ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude_Prelude_Functor$20Prelude_List$2Cmap(( eta ) => (Lib_Parser_nakedBind_makeBind(null, eta)), $$sc))));
const Lib_Parser_parseRecord = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("record")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ebind, Lib_Parser_nakedBind)), ( teles ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("constructor")), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_uident, Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(3))))), ( cname ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_Record(fc, name, Prelude_Prelude_Monad$20Prelude_List$2Cbind(teles, ( _$$1 ) => (_$$1)), cname, decls))))))))))))))));
const Lib_Syntax_Instance = ( h0, h1, h2 ) => ({ tag: 9,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_RWhere = ( h0, h1, h2 ) => ({ tag: 13,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_getName = ( _$$0 ) => (bouncer(Lib_Parser_REC_getName, { tag: 1,  h0: _$$0 }));
const Lib_Parser_REC_getName = ( arg ) => { switch (arg.h0.tag) { case 2: return { tag: 1,  h0: arg.h0.h1 }; case 0: return { tag: 0,  h0: Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(arg.h0.h1) }; default: return { tag: 0,  h0: Lib_Parser_Impl_fail("bad LHS") }; } };
const Lib_Parser_parseDef = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_getName(t), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( body ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( wfc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseSig, Lib_Parser_parseDef))))))), ( w ) => { const body1 = Prelude_maybe(body, ( decls ) => (Lib_Syntax_RWhere(wfc, decls, body)), w); return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_FunDef(fc, nm, Prelude__$3A$3A_(Prelude__$2C_(t, body1), Prelude_Nil()))); })))))))))))));
const Lib_Parser_parseInstance = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("instance")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("where"))), ( $$sc ) => (( ($$sc.tag) == (0) ? Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_parseDef))), ( decls ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_Instance(fc, ty, Prelude_Just(decls))))) : Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_Instance(fc, ty, Prelude_Nothing())) )))))))));
const Lib_Syntax_Class = ( h0, h1, h2, h3 ) => ({ tag: 8,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_parseClass = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("class")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ebind, Lib_Parser_nakedBind)), ( teles ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_Class(fc, name, Prelude_Prelude_Monad$20Prelude_List$2Cbind(teles, ( _$$1 ) => (_$$1)), decls))))))))))))));
const Lib_Syntax_ShortData = ( h0, h1, h2 ) => ({ tag: 4,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parseShortData = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("data")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( lhs ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("=")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_sepBy(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("|")), Lib_Parser_typeExpr), ( sigs ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_ShortData(fc, lhs, sigs))))))))))));
const Lib_Parser_parseData = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_try(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Prelude__$2A$3E_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("data")), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_uident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(3))))), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")))), ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("where")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_startBlock(Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_Data(fc, name, ty, decls))))))))))));
const Lib_Syntax_DCheck = ( h0, h1, h2 ) => ({ tag: 2,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parseNorm = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(Prelude__$3C$2A_(Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Syntax_DCheck(eta, eta1, eta2)))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("#check"))), Lib_Parser_typeExpr), Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":"))), Lib_Parser_typeExpr);
const Lib_Syntax_PFunc = ( h0, h1, h2, h3, h4 ) => ({ tag: 6,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Parser_parsePFunc = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("pfunc")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("uses")), ( _1 ) => (Lib_Parser_parenWrap(Lib_Parser_Impl_many(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_uident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_ident, Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(3))))))))), ( used ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(7)), ( src ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_PFunc(fc, nm, Prelude_fromMaybe(Prelude_Nil(), used), ty, src))))))))))))))))));
const Lib_Syntax_PType = ( h0, h1, h2 ) => ({ tag: 5,  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parsePType = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("ptype")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_uident, ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_optional(Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_PType(fc, $$sc, ty))))))))));
const Lib_Syntax_PMixFix = ( h0, h1, h2, h3 ) => ({ tag: 7,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_Impl_addOp = ( _$$0, _$$1, _$$2 ) => (Lib_Parser_Impl_P(( last ) => (( toks ) => (( com ) => (( ops ) => (( col ) => { const parts = Prelude_split(_$$0, "_"); if ((parts.tag) == (1)) { switch (parts.h1) { case "": return ( (parts.h2.tag) == (1) ? Lib_Parser_Impl_OK(0, last, toks, com, Data_SortedMap_updateMap(parts.h2.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, false, parts.h2.h2), ops)) : Lib_Parser_Impl_OK(0, last, toks, com, Data_SortedMap_updateMap(parts.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, true, parts.h2), ops)) ); default: return Lib_Parser_Impl_OK(0, last, toks, com, Data_SortedMap_updateMap(parts.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, true, parts.h2), ops)); } } else { return Lib_Parser_Impl_Fail(true, Lib_Parser_Impl_perror(col.h0, toks, "Internal error parsing mixfix"), last, toks, com, ops); } }))))));
const Lib_Common_MkOp = ( h0, h1, h2, h3, h4 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Prelude_split = (s, by) => {
  let parts = s.split(by)
  let rval = Prelude_Nil()
  parts.reverse()
  parts.forEach(p => { rval = Prelude__$3A$3A_(p, rval) })
  return rval
};
const Lib_Parser_parseMixfix = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, 0, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("infixl"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, 1, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("infixr"))), Prelude__$3C$$_(Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, 2, Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("infix"))))), ( fix ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(4)), ( prec ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_some(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(3))), ( ops ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Prelude_for(Prelude_Prelude_Traversable$20Prelude_List, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, ops, ( op ) => (Lib_Parser_Impl_addOp(op, Prelude_stringToInt(prec), fix))), ( _ ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_PMixFix(fc, ops, Prelude_stringToInt(prec), fix))))))))))));
const Lib_Parser_parseDecl = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseMixfix, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parsePType, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parsePFunc, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseNorm, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseData, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseShortData, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseSig, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseDef, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseClass, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(Lib_Parser_parseInstance, Lib_Parser_parseRecord))))))))));
const Lib_Parser_Impl_partialParse = ( _$$1, _$$2, _$$3, _$$4 ) => { const sc$$5 = Lib_Parser_Impl_runP(_$$2)(Lib_Common_emptyBounds)(_$$4)(false)(_$$3)(Lib_Common_MkFC(_$$1, Lib_Common_MkBounds(0, 0, 0, 0))); return ( (sc$$5.tag) == (1) ? Prelude_Left(Prelude__$2C_(sc$$5.h2, sc$$5.h4)) : Prelude_Right(Prelude__$2C_(sc$$5.h1, Prelude__$2C_(sc$$5.h5, sc$$5.h3))) ); };
const Lib_Common_emptyBounds = Lib_Common_MkBounds(0, 0, 0, 0);
const Serialize_loadModule = ( _$$0, _$$1 ) => { const fn = (("build/") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (".newtmod"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Serialize_readModFile(fn)), ( $$sc ) => { if (($$sc.tag) == (0)) { const ops = Data_SortedMap_mapFromList(Prelude_Prelude_Ord$20Prim_String, $$sc.h1.h3.h3.h2); const defs = Data_SortedMap_mapFromList(Lib_Common_Prelude_Ord$20Lib_Common_QName, Prelude_Prelude_Functor$20Prelude_List$2Cmap(( entry ) => (Prelude__$2C_(entry.h1, entry)), $$sc.h1.h3.h2)); const mctx = Lib_Types_MC(Data_SortedMap_mapFromList(Lib_Common_Prelude_Ord$20Lib_Common_QName, $$sc.h1.h3.h3.h3), Prelude_Nil(), 0, 2); const sc$$22 = ($$sc.h1.h2) == (_$$1); switch (sc$$22) { case true: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Just(Lib_Types_MkModCtx($$sc.h1.h2, defs, mctx, ops))); case false: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); } } else { return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude_Nothing()); } }); };
const Data_SortedMap_mapFromList = ( _$$2, _$$3 ) => (Prelude_foldl(( eta ) => (( eta1 ) => (Data_SortedMap_mapFromList_go(null, null, _$$2, _$$3, null, eta, eta1))), Data_SortedMap_EmptyMap(_$$2.h1), _$$3));
const Data_SortedMap_mapFromList_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (Data_SortedMap_updateMap(_$$6.h2, _$$6.h3, _$$5));
const Serialize_readModFile = (fn) => (w) => {
  let fs = require('fs')
  try {
    let {DecFile} = require('./serializer')
    let data = fs.readFileSync(fn)
    let dec = DecFile.decode(data)
    return Prelude_MkIORes(Prelude_Just(dec), w)
  } catch (e) {
    return Prelude_MkIORes(Prelude_Nothing(), w)
  }
};
const Main_moduleHash = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Serialize_checksum(_$$0)), ( srcHash ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( top ) => { const mods = Prelude_mapMaybe(( x ) => (Data_SortedMap_lookupMap$27(x, top.h0)), _$$1); const modHashes = Prelude_Prelude_Functor$20Prelude_List$2Cmap(( x ) => (x.h0), mods); return Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Serialize_checksum(Prelude_fastConcat(Prelude__$3A$3A_(srcHash, modHashes)))); }))));
const Serialize_checksum = (a) => (w) => {
  const arr = new TextEncoder().encode(a);
  // djb2 hash
  let val = 5381
  for (let i = 0; i < arr.length; i++) {
    val = ((val * 33) + arr[i]) | 0
  }
  return Prelude_MkIORes(""+val, w);
};
const Data_List1_split1 = ( _$$0, _$$1 ) => { const sc$$2 = Prelude_split(_$$0, _$$1); return ( (sc$$2.tag) == (1) ? Data_List1__$3A$3A$3A_(sc$$2.h1, sc$$2.h2) : Data_List1__$3A$3A$3A_(_$$0, Prelude_Nil()) ); };
const Data_List1__$3A$3A$3A_ = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Data_List1_unsnoc = ( _$$1 ) => (Data_List1_unsnoc_go(null, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$1.h1, _$$1.h2));
const Data_List1_unsnoc_go = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { if ((_$$7.tag) == (1)) { const sc$$11 = Data_List1_unsnoc_go(_, _1, _2, _3, _4, _5, _$$7.h1, _$$7.h2); return Prelude__$2C_(Prelude__$3A$3A_(_$$6, sc$$11.h2), sc$$11.h3); } else { return Prelude__$2C_(Prelude_Nil(), _$$6); } };
const Lib_Syntax_MkImport = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Parser_parseImport = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("import")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_uident, ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(12))), ( rest ) => { const name = Prelude_joinBy("", Prelude__$3A$3A_($$sc, rest)); return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Lib_Syntax_MkImport(fc, name)); })))))));
const Lib_Parser_parseImports = Lib_Parser_Impl_many(Lib_Parser_Impl_sameLevel(Lib_Parser_parseImport));
const Lib_Parser_parseModHeader = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_sameLevel(Lib_Parser_Impl_indented(Lib_Parser_Impl_keyword$27("module"))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(Lib_Parser_Impl_many(Lib_Parser_Impl_indented(Lib_Parser_Impl_token$27(12))), ( rest ) => { const name1 = Prelude_joinBy("", Prelude__$3A$3A_(name, rest)); return Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2Creturn(Prelude__$2C_(fc, name1)); })))))));
const Lib_Tokenizer_tokenise = ( _$$0, _$$1 ) => { const sc$$2 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(0, 0, Prelude_Lin(), Prelude_unpack(_$$1))); return ( (sc$$2.tag) == (1) ? ( (sc$$2.h2.h3.tag) == (0) ? Prelude_Right(Prelude__$3C$3E$3E_(sc$$2.h2.h2, Prelude_Nil())) : Prelude_Left(Lib_Common_E(Lib_Common_MkFC(_$$0, Lib_Common_MkBounds(sc$$2.h2.h0, sc$$2.h2.h1, sc$$2.h2.h0, sc$$2.h2.h1)), "Extra toks")) ) : ( (sc$$2.h2.tag) == (0) ? Prelude_Left(Lib_Common_E(Lib_Common_MkFC(_$$0, sc$$2.h2.h0.h1), sc$$2.h2.h1)) : Prelude_Left(sc$$2.h2) ) ); };
const Lib_Tokenizer_TS = ( h0, h1, h2, h3 ) => ({ tag: 0,  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Tokenizer_rawTokenise = ( _$$0 ) => (bouncer(Lib_Tokenizer_REC_rawTokenise, { tag: 1,  h0: _$$0 }));
const Lib_Tokenizer_REC_rawTokenise = ( arg ) => { switch (arg.tag) { case 1: { if ((arg.h0.h3.tag) == (1)) { switch (arg.h0.h3.h1) { case " ": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2) }; case "\n": return { tag: 1,  h0: Lib_Tokenizer_TS((arg.h0.h0) + (1), 0, arg.h0.h2, arg.h0.h3.h2) }; case "\"": { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (1), 17, "\""); const sc$$18 = Lib_Tokenizer_quoteTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(arg.h0.h2, tok), arg.h0.h3.h2), arg.h0.h0, (arg.h0.h1) + (1), Prelude_Lin()); if ((sc$$18.tag) == (1)) { if ((sc$$18.h2.h3.tag) == (1)) { switch (sc$$18.h2.h3.h1) { case "\"": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, sc$$18.h2.h0, (sc$$18.h2.h1) + (1), 18, "\""); return { tag: 1,  h0: Lib_Tokenizer_TS(sc$$18.h2.h0, (sc$$18.h2.h1) + (1), Prelude__$3A$3C_(sc$$18.h2.h2, tok1), sc$$18.h2.h3.h2) }; break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$18.h2.h0, sc$$18.h2.h1, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '\"'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$18.h2.h0, sc$$18.h2.h1, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '\"'")) }; } } else { return { tag: 0,  h0: Prelude_Left(sc$$18.h2) }; } break; } case "}": return { tag: 0,  h0: Prelude_Right(arg.h0) }; case "{": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case "{": { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (2), 2, "{{"); const sc$$21 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), Prelude__$3A$3C_(arg.h0.h2, tok), arg.h0.h3.h2.h2)); if ((sc$$21.tag) == (1)) { if ((sc$$21.h2.h3.tag) == (1)) { switch (sc$$21.h2.h3.h1) { case "}": { if ((sc$$21.h2.h3.h2.tag) == (1)) { switch (sc$$21.h2.h3.h2.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, sc$$21.h2.h0, (sc$$21.h2.h1) + (2), 2, "}}"); return { tag: 1,  h0: Lib_Tokenizer_TS(sc$$21.h2.h0, (sc$$21.h2.h1) + (2), Prelude__$3A$3C_(sc$$21.h2.h2, tok1), sc$$21.h2.h3.h2.h2) }; break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(sc$$21.h2) }; } break; } default: { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (1), 8, "{"); const sc$$21 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(arg.h0.h2, tok), arg.h0.h3.h2)); if ((sc$$21.tag) == (1)) { if ((sc$$21.h2.h3.tag) == (1)) { switch (sc$$21.h2.h3.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, sc$$21.h2.h0, (sc$$21.h2.h1) + (1), 8, "}"); return { tag: 1,  h0: Lib_Tokenizer_TS(sc$$21.h2.h0, (sc$$21.h2.h1) + (1), Prelude__$3A$3C_(sc$$21.h2.h2, tok1), sc$$21.h2.h3.h2) }; break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$21.h2.h0, sc$$21.h2.h1, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(sc$$21.h2) }; } break; } } } else { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (1), 8, "{"); const sc$$18 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(arg.h0.h2, tok), arg.h0.h3.h2)); if ((sc$$18.tag) == (1)) { if ((sc$$18.h2.h3.tag) == (1)) { switch (sc$$18.h2.h3.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, sc$$18.h2.h0, (sc$$18.h2.h1) + (1), 8, "}"); return { tag: 1,  h0: Lib_Tokenizer_TS(sc$$18.h2.h0, (sc$$18.h2.h1) + (1), Prelude__$3A$3C_(sc$$18.h2.h2, tok1), sc$$18.h2.h3.h2) }; break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$18.h2.h0, sc$$18.h2.h1, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$18.h2.h0, sc$$18.h2.h1, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '}'")) }; } } else { return { tag: 0,  h0: Prelude_Left(sc$$18.h2) }; } } break; } case ",": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (1), 0, ",")), arg.h0.h3.h2) }; case "_": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case ",": { if ((arg.h0.h3.h2.h2.tag) == (1)) { switch (arg.h0.h3.h2.h2.h1) { case "_": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (3), 3, "_,_")), arg.h0.h3.h2.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } case ".": { if ((arg.h0.h3.h2.h2.tag) == (1)) { switch (arg.h0.h3.h2.h2.h1) { case "_": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (3), 3, "_._")), arg.h0.h3.h2.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } case "'": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case "\\": { if ((arg.h0.h3.h2.h2.tag) == (1)) { if ((arg.h0.h3.h2.h2.h2.tag) == (1)) { switch (arg.h0.h3.h2.h2.h2.h1) { case "'": { const ch = Prelude_ite((arg.h0.h3.h2.h2.h1) == ("n"), "\n", arg.h0.h3.h2.h2.h1); return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (4), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (4), 5, Prelude_pack(Prelude__$3A$3A_(ch, Prelude_Nil())))), arg.h0.h3.h2.h2.h2.h2) }; break; } default: switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (3), 5, Prelude_pack(Prelude__$3A$3A_(arg.h0.h3.h2.h1, Prelude_Nil())))), arg.h0.h3.h2.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } } else { switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (3), 5, Prelude_pack(Prelude__$3A$3A_(arg.h0.h3.h2.h1, Prelude_Nil())))), arg.h0.h3.h2.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } default: { if ((arg.h0.h3.h2.h2.tag) == (1)) { switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, false, arg.h0.h0, (arg.h0.h1) + (3), 5, Prelude_pack(Prelude__$3A$3A_(arg.h0.h3.h2.h1, Prelude_Nil())))), arg.h0.h3.h2.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } case "#": return { tag: 3,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h13: 11,  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(Prelude_Lin(), "#") }; case "/": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case "-": return { tag: 4,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2) }; default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } case "`": return { tag: 5,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h9: Prelude_Lin() }; case ".": return { tag: 3,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h13: 12,  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(Prelude_Lin(), ".") }; case "-": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case "-": return { tag: 6,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2) }; default: { const sc$$20 = Prelude_isDigit(arg.h0.h3.h2.h1); switch (sc$$20) { case true: return { tag: 3,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h13: 4,  h14: ( eta ) => (Prelude_isDigit(eta)),  h15: Prelude__$3A$3C_(Prelude__$3A$3C_(Prelude_Lin(), "-"), arg.h0.h3.h2.h1) }; case false: return { tag: 3,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, Prelude__$3A$3A_(arg.h0.h3.h2.h1, arg.h0.h3.h2.h2)),  h13: 0,  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(Prelude_Lin(), "-") }; } break; } } } else { return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } default: return { tag: 2,  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } } else { return { tag: 0,  h0: Prelude_Right(arg.h0) }; } break; } case 2: { const sc$$15 = Prelude_elem(Prelude_Prelude_Eq$20Prim_Char, arg.h13, Lib_Tokenizer_standalone); switch (sc$$15) { case true: return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h1, (arg.h2) + (1), Prelude__$3A$3C_(arg.h3, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, true, arg.h1, (arg.h2) + (1), 8, Prelude_pack(Prelude__$3A$3A_(arg.h13, Prelude_Nil())))), arg.h14) }; case false: { let kind; const sc$$16 = Prelude_isDigit(arg.h13); switch (sc$$16) { case true: { kind = 4; break; } case false: { const sc$$17 = Prelude_isUpper(arg.h13); switch (sc$$17) { case true: { kind = 1; break; } case false: { kind = 0; break; } } break; } } return { tag: 3,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: Lib_Tokenizer_TS(arg.h1, arg.h2, arg.h3, Prelude__$3A$3A_(arg.h13, arg.h14)),  h13: kind,  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, eta)),  h15: Prelude_Lin() }; break; } } break; } case 3: { if ((arg.h12.h3.tag) == (1)) { const sc$$23 = arg.h14(arg.h12.h3.h1); switch (sc$$23) { case true: return { tag: 3,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: Lib_Tokenizer_TS(arg.h12.h0, (arg.h12.h1) + (1), arg.h12.h2, arg.h12.h3.h2),  h13: arg.h13,  h14: arg.h14,  h15: Prelude__$3A$3C_(arg.h15, arg.h12.h3.h1) }; case false: { let kind; const sc$$24 = Data_SnocList_snocelem(Prelude_Prelude_Eq$20Prim_Char, "_", arg.h15); switch (sc$$24) { case true: { kind = 3; break; } case false: { kind = arg.h13; break; } } return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h12.h0, arg.h12.h1, Prelude__$3A$3C_(arg.h12.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, true, arg.h12.h0, (arg.h12.h1) - (1), kind, Prelude_pack(Prelude__$3C$3E$3E_(arg.h15, Prelude_Nil())))), Prelude__$3A$3A_(arg.h12.h3.h1, arg.h12.h3.h2)) }; break; } } } else { return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h12.h0, arg.h12.h1, Prelude__$3A$3C_(arg.h12.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, true, arg.h12.h0, arg.h12.h1, arg.h13, Prelude_pack(Prelude__$3C$3E$3E_(arg.h15, Prelude_Nil())))), Prelude_Nil()) }; } break; } case 4: { if ((arg.h11.h3.tag) == (1)) { switch (arg.h11.h3.h1) { case "-": { if ((arg.h11.h3.h2.tag) == (1)) { switch (arg.h11.h3.h2.h1) { case "/": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (2), arg.h11.h2, arg.h11.h3.h2.h2) }; default: return { tag: 4,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } } else { return { tag: 4,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } break; } case "\n": return { tag: 4,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS((arg.h11.h0) + (1), 0, arg.h11.h2, arg.h11.h3.h2) }; default: return { tag: 4,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(arg.h11.h0, arg.h11.h1, arg.h11.h0, arg.h11.h1)), "EOF in block comment")) }; } break; } case 5: { if ((arg.h8.h3.tag) == (1)) { switch (arg.h8.h3.h1) { case "`": { const tok = Lib_Common_MkBounded(Lib_Token_Tok(7, Prelude_pack(Prelude__$3C$3E$3E_(arg.h9, Prelude_Nil()))), Lib_Common_MkBounds(arg.h1, arg.h2, arg.h8.h0, arg.h8.h1)); return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h8.h0, (arg.h8.h1) + (1), Prelude__$3A$3C_(arg.h8.h2, tok), arg.h8.h3.h2) }; break; } case "\n": return { tag: 5,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Lib_Tokenizer_TS((arg.h8.h0) + (1), 0, arg.h8.h2, arg.h8.h3.h2),  h9: Prelude__$3A$3C_(arg.h9, "\n") }; default: return { tag: 5,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Lib_Tokenizer_TS(arg.h8.h0, (arg.h8.h1) + (1), arg.h8.h2, arg.h8.h3.h2),  h9: Prelude__$3A$3C_(arg.h9, arg.h8.h3.h1) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(arg.h8.h0, arg.h8.h1, arg.h8.h0, arg.h8.h1)), "EOF in backtick string")) }; } break; } case 6: { if ((arg.h10.h3.tag) == (1)) { switch (arg.h10.h3.h1) { case "\n": return { tag: 1,  h0: Lib_Tokenizer_TS((arg.h10.h0) + (1), 0, arg.h10.h2, arg.h10.h3.h2) }; default: return { tag: 6,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: Lib_Tokenizer_TS(arg.h10.h0, (arg.h10.h1) + (1), arg.h10.h2, arg.h10.h3.h2) }; } } else { return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h10.h0, arg.h10.h1, arg.h10.h2, Prelude_Nil()) }; } break; } } };
const Lib_Token_Tok = ( h0, h1 ) => ({ tag: 0,  h0: h0,  h1: h1 });
const Lib_Common_MkBounded = ( h1, h2 ) => ({ tag: 0,  h0: null,  h1: h1,  h2: h2 });
const Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11, _$$12, _$$13 ) => { let kind; const sc$$14 = (_$$9) && (Prelude_elem(Prelude_Prelude_Eq$20Prim_String, _$$13, Lib_Tokenizer_keywords)); switch (sc$$14) { case true: { kind = 2; break; } case false: { kind = _$$12; break; } } return Lib_Common_MkBounded(Lib_Token_Tok(kind, _$$13), Lib_Common_MkBounds(_1, _2, _$$10, _$$11)); };
const Lib_Tokenizer_keywords = Prelude__$3A$3A_("let", Prelude__$3A$3A_("in", Prelude__$3A$3A_("where", Prelude__$3A$3A_("case", Prelude__$3A$3A_("of", Prelude__$3A$3A_("data", Prelude__$3A$3A_("U", Prelude__$3A$3A_("do", Prelude__$3A$3A_("ptype", Prelude__$3A$3A_("pfunc", Prelude__$3A$3A_("module", Prelude__$3A$3A_("infixl", Prelude__$3A$3A_("infixr", Prelude__$3A$3A_("infix", Prelude__$3A$3A_("∀", Prelude__$3A$3A_("forall", Prelude__$3A$3A_("import", Prelude__$3A$3A_("uses", Prelude__$3A$3A_("class", Prelude__$3A$3A_("instance", Prelude__$3A$3A_("record", Prelude__$3A$3A_("constructor", Prelude__$3A$3A_("if", Prelude__$3A$3A_("then", Prelude__$3A$3A_("else", Prelude__$3A$3A_("$", Prelude__$3A$3A_("λ", Prelude__$3A$3A_("?", Prelude__$3A$3A_("@", Prelude__$3A$3A_(".", Prelude__$3A$3A_("->", Prelude__$3A$3A_("→", Prelude__$3A$3A_(":", Prelude__$3A$3A_("=>", Prelude__$3A$3A_(":=", Prelude__$3A$3A_("$=", Prelude__$3A$3A_("=", Prelude__$3A$3A_("<-", Prelude__$3A$3A_("\\", Prelude__$3A$3A_("_", Prelude__$3A$3A_("|", Prelude_Nil())))))))))))))))))))))))))))))))))))))))));
const Prelude_Prelude_Eq$20Prim_Char$2C_$3D$3D_ = ( _$$0, _$$1 ) => ((_$$0) == (_$$1));
const Prelude_Prelude_Eq$20Prim_Char = Prelude_MkEq(( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_Char$2C_$3D$3D_(eta, eta1))));
const Data_SnocList_snocelem = ( _$$1, _$$2, _$$3 ) => (bouncer(Data_SnocList_REC_snocelem, { tag: 1,  h0: null,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Data_SnocList_REC_snocelem = ( arg ) => { if ((arg.h3.tag) == (1)) { const sc$$7 = Prelude__$3D$3D_(arg.h1)(arg.h2)(arg.h3.h2); switch (sc$$7) { case true: return { tag: 0,  h0: true }; case false: return { tag: 1,  h0: null,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1 }; } } else { return { tag: 0,  h0: false }; } };
const Lib_Tokenizer_rawTokenise_isIdent = ( _, _1, _2, _3, _4, _5, _$$6 ) => (Prelude_not((Prelude_isSpace(_$$6)) || (Prelude_elem(Prelude_Prelude_Eq$20Prim_Char, _$$6, Lib_Tokenizer_standalone))));
const Lib_Tokenizer_standalone = Prelude_unpack("()\\{}[],.@;");
const Prelude_isSpace = ( _$$0 ) => { switch (_$$0) { case " ": return true; case "\n": return true; default: return false; } };
const Prelude_isUpper = ( _$$0 ) => { const o = Prelude_ord(_$$0); return (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 64, o), 0)) && (Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 91), 0)); };
const Prelude_isDigit = ( _$$0 ) => { switch (_$$0) { case "0": return true; case "1": return true; case "2": return true; case "3": return true; case "4": return true; case "5": return true; case "6": return true; case "7": return true; case "8": return true; case "9": return true; default: return false; } };
const Lib_Tokenizer_quoteTokenise = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Tokenizer_REC_quoteTokenise, { tag: 1,  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Tokenizer_REC_quoteTokenise = ( arg ) => { if ((arg.h0.h3.tag) == (1)) { switch (arg.h0.h3.h1) { case "\"": return { tag: 0,  h0: Prelude_Right(Lib_Tokenizer_TS(arg.h0.h0, arg.h0.h1, Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_quoteTokenise_stok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null)), arg.h0.h3)) }; case "\n": return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(arg.h0.h0, arg.h0.h1, arg.h0.h0, arg.h0.h1)), "Newline in string")) }; case "\\": { if ((arg.h0.h3.h2.tag) == (1)) { switch (arg.h0.h3.h2.h1) { case "{": { const tok = Lib_Common_MkBounded(Lib_Token_Tok(19, "\\{"), Lib_Common_MkBounds(arg.h0.h0, arg.h0.h1, arg.h0.h0, (arg.h0.h1) + (2))); const sc$$17 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), Prelude__$3A$3C_(Prelude__$3A$3C_(arg.h0.h2, Lib_Tokenizer_quoteTokenise_stok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null)), tok), arg.h0.h3.h2.h2)); if ((sc$$17.tag) == (1)) { if ((sc$$17.h2.h3.tag) == (1)) { switch (sc$$17.h2.h3.h1) { case "}": { const tok1 = Lib_Common_MkBounded(Lib_Token_Tok(20, "}"), Lib_Common_MkBounds(sc$$17.h2.h0, sc$$17.h2.h1, sc$$17.h2.h0, (sc$$17.h2.h1) + (1))); return { tag: 1,  h0: Lib_Tokenizer_TS(sc$$17.h2.h0, (sc$$17.h2.h1) + (1), Prelude__$3A$3C_(sc$$17.h2.h2, tok1), sc$$17.h2.h3.h2),  h1: sc$$17.h2.h0,  h2: (sc$$17.h2.h1) + (1),  h3: Prelude_Lin() }; break; } default: return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$17.h2.h0, sc$$17.h2.h1, sc$$17.h2.h0, sc$$17.h2.h1)), "Expected '{'")) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(sc$$17.h2.h0, sc$$17.h2.h1, sc$$17.h2.h0, sc$$17.h2.h1)), "Expected '{'")) }; } } else { return { tag: 0,  h0: Prelude_Left(sc$$17.h2) }; } break; } case "n": return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(arg.h3, "\n") }; default: return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(arg.h3, arg.h0.h3.h2.h1) }; } } else { return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(arg.h3, arg.h0.h3.h1) }; } break; } default: return { tag: 1,  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(arg.h3, arg.h0.h3.h1) }; } } else { return { tag: 0,  h0: Prelude_Left(Lib_Common_E(Lib_Common_MkFC("", Lib_Common_MkBounds(arg.h0.h0, arg.h0.h1, arg.h0.h0, arg.h0.h1)), "Expected '\"' at EOF")) }; } };
const Lib_Tokenizer_quoteTokenise_stok = ( _, _1, _2, _3, _4, _5, _6, _7, _8 ) => (Lib_Common_MkBounded(Lib_Token_Tok(6, Prelude_pack(Prelude__$3C$3E$3E_(_3, Prelude_Nil()))), Lib_Common_MkBounds(_1, _2, _4, _5)));
const Node_readFile = (fn) => (w) => {
  let fs = require('fs')
  let result
  try {
    let content = fs.readFileSync(fn, 'utf8')
    result = Prelude_Right(content)
  } catch (e) {
    result = Prelude_Left(e+'')
  }
  return Prelude_MkIORes(result, w)
};
const Lib_Types_emptyModCtx = ( _$$0 ) => (Lib_Types_MkModCtx(_$$0, Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Lib_Types_MC(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), 0, 2), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))))));
const Lib_Util_getBaseDir = ( _$$0, _$$1, _$$2 ) => { const sc$$4 = Data_List1_unsnoc(Data_List1_split1(_$$2, ".")); const parts = Data_List1_split1(_$$0, "/"); const sc$$10 = Data_List1_unsnoc(parts); const sc$$15 = Data_List1_splitFileName(sc$$10.h3); const parts1 = Data_List1_split1(_$$0, "/"); const sc$$21 = Data_List1_unsnoc(parts1); const sc$$26 = Data_List1_unsnoc(Data_List1_split1(_$$2, ".")); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not((sc$$26.h3) == (sc$$15.h2)), ( _ ) => (Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, (((("module name ") + (sc$$26.h3)) + (" doesn't match ")) + (sc$$15.h2)) + (""))), eta)))))), ( _ ) => { const sc$$32 = Lib_Util_getBaseDir_baseDir(_$$0, _$$1, _$$2, null, Prelude__$3C$3E$3C_(Prelude_Lin(), sc$$21.h2), Prelude__$3C$3E$3C_(Prelude_Lin(), sc$$26.h2)); if ((sc$$32.tag) == (1)) { let base; const sc$$36 = (sc$$32.h2) == (""); switch (sc$$36) { case true: { base = "."; break; } case false: { base = sc$$32.h2; break; } } return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(base, Lib_Common_QN(sc$$26.h2, sc$$26.h3))); } else { return Lib_Types_MkM(( _1 ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(_$$1, sc$$32.h2)), eta)))); } }); };
const Lib_Util_getBaseDir_baseDir = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Lib_Util_REC_getBaseDir_baseDir, { tag: 1,  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Lib_Util_REC_getBaseDir_baseDir = ( arg ) => { if ((arg.h5.tag) == (1)) { if ((arg.h4.tag) == (1)) { const sc$$12 = (arg.h4.h2) == (arg.h5.h2); switch (sc$$12) { case true: return { tag: 1,  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h1,  h5: arg.h5.h1 }; case false: return { tag: 0,  h0: Prelude_Left("module path doesn't match directory") }; } } else { return { tag: 0,  h0: Prelude_Left("module path doesn't match directory") }; } } else { return { tag: 0,  h0: Prelude_Right(Prelude_joinBy("/", Prelude__$3C$3E$3E_(arg.h4, Prelude_Nil()))) }; } };
const Data_List1_splitFileName = ( _$$0 ) => { const sc$$1 = Data_List1_split1(_$$0, "."); return ( (sc$$1.h2.tag) == (0) ? Prelude__$2C_(sc$$1.h1, "") : Prelude_mapFst(Prelude_Prelude_Bifunctor$20Prelude__$D7_, ( eta ) => (Prelude_joinBy(".", eta)), Data_List1_unsnoc(sc$$1)) ); };
const Prelude_MkBifunctor = ( h1 ) => ({ tag: 0,  h0: null,  h1: h1 });
const Prelude_Prelude_Bifunctor$20Prelude__$D7_ = Prelude_MkBifunctor(( a ) => (( b ) => (( c ) => (( d ) => (( eta ) => (( eta1 ) => (( eta2 ) => (Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap(eta, eta1, eta2)))))))));
const Prelude_mapFst = ( _$$4, _$$5, _$$6 ) => (Prelude_bimap(_$$4)(null)(null)(null)(null)(_$$5)(( _$$1 ) => (_$$1))(_$$6));
const Prelude_bimap = ( _$$1 ) => (( a ) => (( b ) => (( c ) => (( d ) => (_$$1.h1(null)(null)(null)(null))))));
const Main_cmdLine = ( _$$0 ) => (bouncer(Main_REC_cmdLine, { tag: 1,  h0: _$$0 }));
const Main_REC_cmdLine = ( arg ) => { if ((arg.h0.tag) == (1)) { switch (arg.h0.h1) { case "--top": return { tag: 1,  h0: arg.h0.h2 }; case "-v": return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, (1) + (tc.h6), tc.h7, tc.h8)))), ( _ ) => (Main_cmdLine(arg.h0.h2))) }; case "-o": { if ((arg.h0.h2.tag) == (1)) { return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_cmdLine(arg.h0.h2.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_($$sc.h2, Prelude_Just(arg.h0.h2.h1)), $$sc.h3)))) }; } else { const sc$$4 = Prelude_isSuffixOf(".newt", arg.h0.h1); switch (sc$$4) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_cmdLine(arg.h0.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_($$sc.h2, Prelude__$3A$3A_(arg.h0.h1, $$sc.h3))))) }; default: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("Bad argument ") + (arg.h0.h1)) + (""))), eta)))) }; } } break; } default: { const sc$$4 = Prelude_isSuffixOf(".newt", arg.h0.h1); switch (sc$$4) { case true: return { tag: 0,  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_cmdLine(arg.h0.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_($$sc.h2, Prelude__$3A$3A_(arg.h0.h1, $$sc.h3))))) }; default: return { tag: 0,  h0: Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, (("Bad argument ") + (arg.h0.h1)) + (""))), eta)))) }; } break; } } } else { return { tag: 0,  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(Prelude__$2C_(Prelude_Nothing(), Prelude_Nil())) }; } };
const Prelude_isSuffixOf = (pfx, s) => s.endsWith(pfx) ? Prelude_True : Prelude_False;
const Node_getArgs = (w) => Prelude_MkIORes( Prelude_arrayToList(null, process.argv.slice(1)), w);
const Main_main$27 = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Node_getArgs), ( $$sc ) => (( ($$sc.tag) == (1) ? Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_cmdLine($$sc.h2), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Main_processFile(eta)), $$sc1.h3), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Prelude_when(Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(Prelude_Prelude_Eq$20Prim_String, "--top", $$sc.h2), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(Main_jsonTopContext, ( json ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(Prelude_primPutStrLn((("TOP:") + (Lib_Common_renderJson(json))) + (""))))))), ( _1 ) => (( ($$sc1.h2.tag) == (1) ? Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(0) : Main_writeSource($$sc1.h2.h1) ))))))) : Lib_Types_MkM(( _ ) => (( eta ) => (Prelude_MkIORes(Prelude_Left(Lib_Common_E(Lib_Common_emptyFC, "error reading args")), eta)))) )));
const Lib_TopContext_emptyTop = ((  ) => { const mcctx = Lib_Types_MC(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), 0, 0); return ( io ) => (( _ ) => (( _1 ) => (Prelude_bind(_)(null)(null)(Prelude_liftIO(_1)(null)(Data_IORef_primNewIORef(null, Prelude_Nil())))(( errs ) => (Prelude_pure(_)(null)(Lib_Types_MkTop(Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare(Prelude_Prelude_Ord$20Prim_String, eta, eta1)))), Prelude_Nil(), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(), Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), mcctx, 0, errs, Data_SortedMap_EmptyMap(( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))))))))))); })();
const Main_main = ( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(Lib_TopContext_emptyTop(null)(Prelude_Prelude_Monad$20Prelude_IO)(Prelude_Prelude_HasIO$20Prelude_IO), ( ctx ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(Lib_Types__runM(Main_main$27)(ctx), ( $$sc ) => (( ($$sc.tag) == (1) ? Prelude_primPutStrLn("done") : Node_exitFailure(null, (((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(Lib_Types_Lib_Common_HasFC$20Lib_Common_Error$2CgetFC($$sc.h2)))) + (": ")) + (Lib_Types_errorMsg($$sc.h2))) + ("")) )), eta))), eta));
Main_main();