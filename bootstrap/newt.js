"use strict";
const bouncer = (f,ini) => { let obj = ini; while (obj.tag !== 'return') obj = f(obj); return obj.h0 };
const Lib_Types_errorMsg = ( _$$0 ) => { switch (_$$0.tag) { case "Postpone": return _$$0.h2; case "E": return _$$0.h1; } };
const Lib_Types_Lib_Common_HasFC$20Lib_Common_Error$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case "Postpone": return _$$0.h0; case "E": return _$$0.h0; } };
const Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow = ( _$$0 ) => ((((((("") + (_$$0.h0)) + (":(")) + (Prelude_showInt((_$$0.h1.h2) + (1)))) + (", ")) + (Prelude_showInt((_$$0.h1.h3) + (1)))) + (")"));
const Prelude_showInt = (i) => String(i);
const Node_exitFailure = (_, msg) => {
  console.log(msg);
  process.exit(1);
};
const Prelude_MkIORes = ( h0, h1, h2 ) => ({ tag: "MkIORes",  h0: h0,  h1: h1,  h2: h2 });
const Prelude_MkUnit = "MkUnit";
const Prelude_primPutStrLn = (s) => (w) => {
  console.log(s)
  return Prelude_MkIORes(null,Prelude_MkUnit,w)
};
const Prelude__$2C_ = ( h0, h1, h2, h3 ) => ({ tag: "_,_",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Common_MkFC = ( h0, h1 ) => ({ tag: "MkFC",  h0: h0,  h1: h1 });
const Lib_Common_emptyFC = Lib_Common_MkFC("", Prelude__$2C_(null, null, 0, 0));
const Lib_Common_E = ( h0, h1 ) => ({ tag: "E",  h0: h0,  h1: h1 });
const Prelude_Left = ( h0, h1, h2 ) => ({ tag: "Left",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_MkM = ( h0, h1 ) => ({ tag: "MkM",  h0: h0,  h1: h1 });
const Main_writeSource = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Compile_compile, ( docs ) => { const src = Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude__$3A$3A_(null, "\"use strict\";", Prelude__$3A$3A_(null, "const bouncer = (f,ini) => { let obj = ini; while (obj.tag !== 'return') obj = f(obj); return obj.h0 };", Prelude_Nil(null))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Prettier_noAlt(_$$5))), Prelude_Lin(null))), docs))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Node_writeFile(_$$0, src)), ( $$sc ) => { switch ($$sc.tag) { case "Right": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "Left": return Node_exitFailure(null, $$sc.h2); } }); }));
const Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn = ( a$$0, _$$1 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, tc, _$$1)), eta)))));
const Prelude_Right = ( h0, h1, h2 ) => ({ tag: "Right",  h0: h0,  h1: h1,  h2: h2 });
const Node_writeFile = (fn, content) => (w) => {
  let fs = require('fs')
  let result
  try {
    fs.writeFileSync(fn, content, 'utf8')
    result = Prelude_Right(null, null, Prelude_MkUnit)
  } catch (e) {
      let err = ""+e
      result = Prelude_Left(null, null, e)
  }
  return Prelude_MkIORes(null, result, w)
};
const Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO = ( a$$0, _$$1 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$1, ( result ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, tc, result)), eta))), eta)))));
const Prelude_Prelude_Monad$20Prelude_IO$2Cbind = ( a$$0, b$$1, _$$2, _$$3, w ) => { const sc$$5 = _$$2(w); return _$$3(sc$$5.h1)(sc$$5.h2); };
const Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$2.h1(tc), ( $$sc ) => { switch ($$sc.tag) { case "Right": return Lib_Types__runM(null, _$$3($$sc.h2.h3))($$sc.h2.h2); case "Left": return ( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, $$sc.h2), eta)); } }, eta)))));
const Lib_Types__runM = ( a$$0, _$$1 ) => (_$$1.h1);
const Prelude_Lin = ( h0 ) => ({ tag: "Lin",  h0: h0 });
const Lib_Prettier_noAlt = ( _$$0 ) => (bouncer(Lib_Prettier_REC_noAlt, { tag: "Lib.Prettier.noAlt",  h0: _$$0 }));
const Lib_Prettier_REC_noAlt = ( arg ) => { switch (arg.h0.tag) { case "Alt": return { tag: "Lib.Prettier.noAlt",  h0: arg.h0.h0 }; case "Seq": return { tag: "return",  h0: Lib_Prettier_Seq(Lib_Prettier_noAlt(arg.h0.h0), Lib_Prettier_noAlt(arg.h0.h1)) }; case "Nest": return { tag: "Lib.Prettier.noAlt",  h0: arg.h0.h1 }; case "Text": return { tag: "return",  h0: Lib_Prettier_Text(arg.h0.h0) }; case "Line": return { tag: "return",  h0: Lib_Prettier_Line }; case "Empty": return { tag: "return",  h0: Lib_Prettier_Empty }; } };
const Lib_Prettier_Empty = { tag: "Empty" };
const Lib_Prettier_Line = { tag: "Line" };
const Lib_Prettier_Text = ( h0 ) => ({ tag: "Text",  h0: h0 });
const Lib_Prettier_Seq = ( h0, h1 ) => ({ tag: "Seq",  h0: h0,  h1: h1 });
const Lib_Prettier_best = ( _$$0, _$$1, _$$2 ) => (Prelude_fromMaybe(null, Prelude_Nil(null), Lib_Prettier_be("False", Prelude_Lin(null), _$$0, _$$1, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, 0, _$$2), Prelude_Nil(null)))));
const Prelude_Nil = ( h0 ) => ({ tag: "Nil",  h0: h0 });
const Prelude__$3A$3A_ = ( h0, h1, h2 ) => ({ tag: "_::_",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Prettier_be = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (bouncer(Lib_Prettier_REC_be, { tag: "Lib.Prettier.be",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Lib_Prettier_REC_be = ( arg ) => { switch (arg.h4.tag) { case "_::_": switch (arg.h4.h1.h3.tag) { case "Alt": return { tag: "return",  h0: Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, ( eta ) => (Prelude__$3C$3E$3E_(null, arg.h1, eta)), Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_(null, Lib_Prettier_be("True", Prelude_Lin(null), arg.h2, arg.h3, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4.h1.h2, arg.h4.h1.h3.h0), arg.h4.h2)), Lib_Prettier_be(arg.h0, Prelude_Lin(null), arg.h2, arg.h3, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4.h1.h2, arg.h4.h1.h3.h1), arg.h4.h2)))) }; case "Seq": return { tag: "Lib.Prettier.be",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4.h1.h2, arg.h4.h1.h3.h0), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4.h1.h2, arg.h4.h1.h3.h1), arg.h4.h2)) }; case "Nest": return { tag: "Lib.Prettier.be",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, (arg.h4.h1.h2) + (arg.h4.h1.h3.h0), arg.h4.h1.h3.h1), arg.h4.h2) }; case "Text": { const sc$$13 = Prelude__$7C$7C_(Prelude_not(arg.h0), Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h3) + (Prelude_slen(arg.h4.h1.h3.h0)), arg.h2), "LT")); switch (sc$$13) { case "False": return { tag: "return",  h0: Prelude_Nothing(null) }; case "True": return { tag: "Lib.Prettier.be",  h0: arg.h0,  h1: Prelude__$3A$3C_(null, arg.h1, Lib_Prettier_TEXT(arg.h4.h1.h3.h0)),  h2: arg.h2,  h3: (arg.h3) + (Prelude_slen(arg.h4.h1.h3.h0)),  h4: arg.h4.h2 }; } break; } case "Line": return { tag: "Lib.Prettier.be",  h0: "False",  h1: Prelude__$3A$3C_(null, arg.h1, Lib_Prettier_LINE(arg.h4.h1.h2)),  h2: arg.h2,  h3: arg.h4.h1.h2,  h4: arg.h4.h2 }; case "Empty": return { tag: "Lib.Prettier.be",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2 }; } break; case "Nil": return { tag: "return",  h0: Prelude_Just(null, Prelude__$3C$3E$3E_(null, arg.h1, Prelude_Nil(null))) }; } };
const Prelude__$3C$3E$3E_ = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC__$3C$3E$3E_, { tag: "Prelude._<>>_",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC__$3C$3E$3E_ = ( arg ) => { switch (arg.h1.tag) { case "_:<_": return { tag: "Prelude._<>>_",  h0: null,  h1: arg.h1.h1,  h2: Prelude__$3A$3A_(null, arg.h1.h2, arg.h2) }; case "Lin": return { tag: "return",  h0: arg.h2 }; } };
const Prelude_Just = ( h0, h1 ) => ({ tag: "Just",  h0: h0,  h1: h1 });
const Lib_Prettier_LINE = ( h0 ) => ({ tag: "LINE",  h0: h0 });
const Prelude__$3A$3C_ = ( h0, h1, h2 ) => ({ tag: "_:<_",  h0: h0,  h1: h1,  h2: h2 });
const Prelude_slen = s => s.length;
const Lib_Prettier_TEXT = ( h0 ) => ({ tag: "TEXT",  h0: h0 });
const Prelude_Nothing = ( h0 ) => ({ tag: "Nothing",  h0: h0 });
const Prelude_jsCompare = (_, a, b) => a == b ? "EQ" : a < b ? "LT" : "GT";
const Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case "GT": switch (_$$0) { case "GT": return "True"; default: return "False"; } break; case "EQ": switch (_$$0) { case "EQ": return "True"; default: return "False"; } break; case "LT": switch (_$$0) { case "LT": return "True"; default: return "False"; } break; } };
const Prelude_not = ( _$$0 ) => { switch (_$$0) { case "False": return "True"; case "True": return "False"; } };
const Prelude__$7C$7C_ = ( _$$0, _$$1 ) => { switch (_$$0) { case "False": return _$$1; case "True": return "True"; } };
const Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_ = ( a$$0, _$$1, _$$2 ) => { switch (_$$1.tag) { case "Nothing": return _$$2; case "Just": return Prelude_Just(null, _$$1.h1); } };
const Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "Nothing": return Prelude_Nothing(null); case "Just": return Prelude_Just(null, _$$2(_$$3.h1)); } };
const Prelude_fromMaybe = ( a$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "Nothing": return _$$1; case "Just": return _$$2.h1; } };
const Lib_Prettier_layout = ( _$$0, _$$1 ) => (bouncer(Lib_Prettier_REC_layout, { tag: "Lib.Prettier.layout",  h0: _$$0,  h1: _$$1 }));
const Lib_Prettier_REC_layout = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1.tag) { case "LINE": return { tag: "Lib.Prettier.layout",  h0: arg.h0.h2,  h1: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h1, "\n"), Prelude_replicate(Prelude_intToNat(arg.h0.h1.h0), " ")) }; case "TEXT": return { tag: "Lib.Prettier.layout",  h0: arg.h0.h2,  h1: Prelude__$3A$3C_(null, arg.h1, arg.h0.h1.h0) }; } break; case "Nil": return { tag: "return",  h0: Prelude_fastConcat(Prelude__$3C$3E$3E_(null, arg.h1, Prelude_Nil(null))) }; } };
const Prelude_listToArray = 
(a, l) => {
  let rval = []
  while (l.tag !== 'Nil') {
    rval.push(l.h1)
    l = l.h2
  }
  return rval
}
;
const Prelude_fastConcat = (xs) => Prelude_listToArray(null, xs).join('');
const Prelude_intToNat = (n) => n>0?n:0;
const Prelude_natToInt = (n) => n;
const Prelude_replicate = (n,c) => c.repeat(Prelude_natToInt(n));
const Prelude_Prelude_Functor$20Prelude_List$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap_go(a$$0, b$$1, _$$2, _$$3, null, null, null, _$$2, _$$3, Prelude_Nil(null)));
const Prelude_Prelude_Functor$20Prelude_List$2Cmap_go = ( _, _1, _2, _3, _4, a$$5, b$$6, _$$7, _$$8, _$$9 ) => (bouncer(Prelude_REC_Prelude_Functor$20Prelude_List$2Cmap_go, { tag: "Prelude.Prelude.Functor Prelude.List,map.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: a$$5,  h6: b$$6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Prelude_REC_Prelude_Functor$20Prelude_List$2Cmap_go = ( arg ) => { switch (arg.h8.tag) { case "_::_": return { tag: "Prelude.Prelude.Functor Prelude.List,map.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: null,  h6: null,  h7: arg.h7,  h8: arg.h8.h2,  h9: Prelude__$3A$3A_(null, arg.h7(arg.h8.h1), arg.h9) }; case "Nil": return { tag: "return",  h0: Prelude_reverse(null)(arg.h9) }; } };
const Prelude_reverse = ( a$$0 ) => (( eta ) => (Prelude_reverse_go(a$$0, null, Prelude_Nil(null), eta)));
const Prelude_reverse_go = ( _, _1, _$$2, _$$3 ) => (bouncer(Prelude_REC_reverse_go, { tag: "Prelude.reverse.go",  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_reverse_go = ( arg ) => { switch (arg.h3.tag) { case "_::_": return { tag: "Prelude.reverse.go",  h0: arg.h0,  h1: arg.h1,  h2: Prelude__$3A$3A_(null, arg.h3.h1, arg.h2),  h3: arg.h3.h2 }; case "Nil": return { tag: "return",  h0: arg.h2 }; } };
const Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_ = ( a$$0, _$$1, _$$2 ) => { switch (_$$1.tag) { case "_::_": return Prelude__$3A$3A_(null, _$$1.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, _$$1.h2, _$$2)); case "Nil": return _$$2; } };
const Prelude_joinBy = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_joinBy, { tag: "Prelude.joinBy",  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_joinBy = ( arg ) => { switch (arg.h1.tag) { case "_::_": switch (arg.h1.h2.tag) { case "_::_": return { tag: "Prelude.joinBy",  h0: arg.h0,  h1: Prelude__$3A$3A_(null, (arg.h1.h1) + ((arg.h0) + (arg.h1.h2.h1)), arg.h1.h2.h2) }; case "Nil": return { tag: "return",  h0: arg.h1.h1 }; } break; case "Nil": return { tag: "return",  h0: "" }; } };
const Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow = ( _$$0 ) => { switch (_$$0.h0.tag) { case "Nil": return _$$0.h1; default: return (Prelude_joinBy(".", _$$0.h0)) + ((".") + (_$$0.h1)); } };
const Lib_Compile_Var = ( h0 ) => ({ tag: "Var",  h0: h0 });
const Lib_Compile_Apply = ( h0, h1 ) => ({ tag: "Apply",  h0: h0,  h1: h1 });
const Lib_Compile_JPlain = ( h0 ) => ({ tag: "JPlain",  h0: h0 });
const Lib_Compile_stmtToDoc = ( e$$0, _$$1 ) => { switch (_$$1.tag) { case "JError": return Lib_Prettier_Seq(Lib_Prettier_Text("throw new Error("), Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_quoteString(_$$1.h1)), Lib_Prettier_Text(");"))); case "JCase": return Lib_Prettier_Seq(Lib_Prettier_Text("switch ("), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h1), Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_altToDoc, _$$1.h2)), "}"))))); case "JAssign": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Compile_jsIdent(_$$1.h0), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$1.h1))), Lib_Prettier_Text(";")); case "JLet": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_jsIdent(_$$1.h0))), Lib_Prettier_Text(";")), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(null, _$$1.h1))); case "JReturn": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("return"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$1.h0))), Lib_Prettier_Text(";")); case "JConst": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("const"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_jsIdent(_$$1.h0))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("="), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h1), Lib_Prettier_Text(";"))))))); case "JPlain": return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$1.h0), Lib_Prettier_Text(";")); case "JSnoc": return Lib_Prettier_Seq(Lib_Compile_stmtToDoc(null, _$$1.h1), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(null, _$$1.h2))); } };
const Lib_Prettier_line = Lib_Prettier_Line;
const Lib_Compile_expToDoc = ( _$$0 ) => { switch (_$$0.tag) { case "Raw": return Lib_Prettier_Text(_$$0.h0); case "Dot": return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("."), Lib_Compile_jsIdent(_$$0.h1))); case "Index": return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("["), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h1), Lib_Prettier_Text("]")))); case "JUndefined": return Lib_Prettier_Text("null"); case "JPrimOp": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Types_parens(0, 1, Lib_Compile_expToDoc(_$$0.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h0))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_parens(0, 1, Lib_Compile_expToDoc(_$$0.h2)))); case "JLam": switch (_$$0.h1.tag) { case "JReturn": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_jsIdent, _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(") =>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("("))), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h1.h0), Lib_Prettier_Text(")"))); default: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_jsIdent, _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(") =>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_bracket("{", Lib_Compile_stmtToDoc(null, _$$0.h1), "}"))); } break; case "Var": return Lib_Compile_jsIdent(_$$0.h0); case "Apply": switch (_$$0.h0.tag) { case "JLam": return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_expToDoc, _$$0.h1))), Lib_Prettier_Text(")")))))); default: return Lib_Prettier_Seq(Lib_Compile_expToDoc(_$$0.h0), Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_expToDoc, _$$0.h1))), Lib_Prettier_Text(")")))); } break; case "LitInt": return Lib_Prettier_Text(Prelude_showInt(_$$0.h0)); case "LitString": return Lib_Prettier_Text(Lib_Common_quoteString(_$$0.h0)); case "LitObject": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( e ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(", ")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), e)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_expToDoc_entry(_$$0, _$$0.h0, null, eta)), _$$0.h0)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))); case "LitArray": return Prelude_fatalError(null, "TODO - LitArray to doc"); } };
const Prelude_fatalError = (_, msg) => { throw new Error(msg) };
const Lib_Compile_expToDoc_entry = ( _, _1, _2, _$$3 ) => (Lib_Prettier_Seq(Lib_Compile_jsIdent(_$$3.h2), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$3.h3)))));
const Lib_Compile_jsIdent = ( _$$0 ) => { const sc$$2 = Prelude_elem(null, Prelude_Prelude_Eq$20Prim_String, _$$0, Lib_Compile_jsKeywords); switch (sc$$2) { case "False": return Lib_Prettier_Text(Prelude_pack(Lib_Compile_jsIdent_fix(_$$0, null, Prelude_unpack(_$$0)))); case "True": return Lib_Prettier_Text(("$") + (_$$0)); } };
const Prelude_unpack = (s) => {
    let acc = Prelude_Nil(null)
    for (let i = s.length - 1; 0 <= i; i--) acc = Prelude__$3A$3A_(null, s[i], acc)
    return acc
};
const Lib_Compile_jsIdent_fix = ( _, _1, _$$2 ) => { switch (_$$2.tag) { case "_::_": { const sc$$6 = Prelude__$7C$7C_(Prelude_isAlphaNum(_$$2.h1), Prelude_jsEq(null, _$$2.h1, "_")); switch (sc$$6) { case "False": { const sc$$7 = Prelude_jsEq(null, _$$2.h1, "."); switch (sc$$7) { case "False": { const sc$$8 = Prelude_jsEq(null, _$$2.h1, "$"); switch (sc$$8) { case "False": return Prelude__$3A$3A_(null, "$", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Lib_Common_toHex(Prelude_ord(_$$2.h1)), Lib_Compile_jsIdent_fix(_, _1, _$$2.h2))); case "True": return Prelude__$3A$3A_(null, "$", Prelude__$3A$3A_(null, "$", Lib_Compile_jsIdent_fix(_, _1, _$$2.h2))); } break; } case "True": return Prelude__$3A$3A_(null, "_", Lib_Compile_jsIdent_fix(_, _1, _$$2.h2)); } break; } case "True": return Prelude__$3A$3A_(null, _$$2.h1, Lib_Compile_jsIdent_fix(_, _1, _$$2.h2)); } break; } case "Nil": return Prelude_Nil(null); } };
const Prelude_ord = (c) => c.charCodeAt(0);
const Lib_Common_toHex = ( _$$0 ) => { switch (_$$0) { case 0: return Prelude_Nil(null); default: return Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Lib_Common_toHex(((_$$0) / (16)) | (0)), Prelude__$3A$3A_(null, Prelude_fromMaybe(null, " ", Prelude_getAt(null, Prelude_intToNat(Prelude_mod(_$$0, 16)), Lib_Common_hexChars)), Prelude_Nil(null))); } };
const Lib_Common_hexChars = Prelude_unpack("0123456789ABCDEF");
const Prelude_mod = (a,b) => a % b;
const Prelude_getAt = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC_getAt, { tag: "Prelude.getAt",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_getAt = ( arg ) => { switch (arg.h2.tag) { case "_::_": switch (arg.h1) { case 0: return { tag: "return",  h0: Prelude_Just(null, arg.h2.h1) }; default: { const x = (arg.h1) - (1); return { tag: "Prelude.getAt",  h0: null,  h1: x,  h2: arg.h2.h2 }; break; } } break; case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Prelude_True = "True";
const Prelude_False = "False";
const Prelude_jsEq = (_, a, b) => a == b ? Prelude_True : Prelude_False;
const Prelude_isAlphaNum = ( _$$0 ) => { const o = Prelude_ord(_$$0); return Prelude__$7C$7C_(Prelude__$26$26_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 64, o), "LT"), Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 91), "LT")), Prelude__$7C$7C_(Prelude__$26$26_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 47, o), "LT"), Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 58), "LT")), Prelude__$26$26_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 96, o), "LT"), Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 123), "LT")))); };
const Prelude__$26$26_ = ( _$$0, _$$1 ) => { switch (_$$0) { case "False": return "False"; case "True": return _$$1; } };
const Prelude_pack = (cs) => {
  let rval = ''
  while (cs.tag === '_::_') {
    rval += cs.h1
    cs = cs.h2
  }
  return rval
}
;
const Lib_Compile_jsKeywords = Prelude__$3A$3A_(null, "break", Prelude__$3A$3A_(null, "case", Prelude__$3A$3A_(null, "catch", Prelude__$3A$3A_(null, "continue", Prelude__$3A$3A_(null, "debugger", Prelude__$3A$3A_(null, "default", Prelude__$3A$3A_(null, "delete", Prelude__$3A$3A_(null, "do", Prelude__$3A$3A_(null, "else", Prelude__$3A$3A_(null, "finally", Prelude__$3A$3A_(null, "for", Prelude__$3A$3A_(null, "function", Prelude__$3A$3A_(null, "if", Prelude__$3A$3A_(null, "in", Prelude__$3A$3A_(null, "instanceof", Prelude__$3A$3A_(null, "new", Prelude__$3A$3A_(null, "return", Prelude__$3A$3A_(null, "switch", Prelude__$3A$3A_(null, "this", Prelude__$3A$3A_(null, "throw", Prelude__$3A$3A_(null, "try", Prelude__$3A$3A_(null, "typeof", Prelude__$3A$3A_(null, "var", Prelude__$3A$3A_(null, "void", Prelude__$3A$3A_(null, "while", Prelude__$3A$3A_(null, "with", Prelude__$3A$3A_(null, "class", Prelude__$3A$3A_(null, "const", Prelude__$3A$3A_(null, "enum", Prelude__$3A$3A_(null, "export", Prelude__$3A$3A_(null, "extends", Prelude__$3A$3A_(null, "import", Prelude__$3A$3A_(null, "super", Prelude__$3A$3A_(null, "implements", Prelude__$3A$3A_(null, "class", Prelude__$3A$3A_(null, "let", Prelude__$3A$3A_(null, "package", Prelude__$3A$3A_(null, "private", Prelude__$3A$3A_(null, "protected", Prelude__$3A$3A_(null, "public", Prelude__$3A$3A_(null, "static", Prelude__$3A$3A_(null, "yield", Prelude__$3A$3A_(null, "null", Prelude__$3A$3A_(null, "true", Prelude__$3A$3A_(null, "false", Prelude__$3A$3A_(null, "String", Prelude__$3A$3A_(null, "Number", Prelude__$3A$3A_(null, "Array", Prelude__$3A$3A_(null, "BigInt", Prelude_Nil(null))))))))))))))))))))))))))))))))))))))))))))))))));
const Prelude_Prelude_Eq$20Prim_String$2C_$3D$3D_ = ( _$$0, _$$1 ) => (Prelude_jsEq(null, _$$0, _$$1));
const Prelude_MkEq = ( h0, h1 ) => ({ tag: "MkEq",  h0: h0,  h1: h1 });
const Prelude_Prelude_Eq$20Prim_String = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_String$2C_$3D$3D_(eta, eta1))));
const Prelude_elem = ( a$$0, _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_elem, { tag: "Prelude.elem",  h0: a$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_elem = ( arg ) => { switch (arg.h3.tag) { case "_::_": { const sc$$7 = Prelude__$3D$3D_(null, arg.h1)(arg.h2)(arg.h3.h1); switch (sc$$7) { case "False": return { tag: "Prelude.elem",  h0: null,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 }; case "True": return { tag: "return",  h0: "True" }; } break; } case "Nil": return { tag: "return",  h0: "False" }; } };
const Prelude__$3D$3D_ = ( a$$0, _$$1 ) => (_$$1.h1);
const Lib_Prettier_Alt = ( h0, h1 ) => ({ tag: "Alt",  h0: h0,  h1: h1 });
const Lib_Prettier_folddoc = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "_::_": switch (_$$1.h2.tag) { case "Nil": return _$$1.h1; default: return _$$0(_$$1.h1)(Lib_Prettier_folddoc(_$$0, _$$1.h2)); } break; case "Nil": return Lib_Prettier_Empty; } };
const Lib_Common_quoteString = ( _$$0 ) => (Prelude_pack(Lib_Common_quoteString_encode(_$$0, null, Prelude_unpack(_$$0), Prelude__$3A$3C_(null, Prelude_Lin(null), "\""))));
const Lib_Common_quoteString_encode = ( _, _1, _$$2, _$$3 ) => (bouncer(Lib_Common_REC_quoteString_encode, { tag: "Lib.Common.quoteString.encode",  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Lib_Common_REC_quoteString_encode = ( arg ) => { switch (arg.h2.tag) { case "_::_": switch (arg.h2.h1) { case "\"": return { tag: "Lib.Common.quoteString.encode",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h3, "\\"), "\"") }; case "\n": return { tag: "Lib.Common.quoteString.encode",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h3, "\\"), "n") }; case "\\": return { tag: "Lib.Common.quoteString.encode",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h3, "\\"), "\\") }; default: { const v = Prelude_ord(arg.h2.h1); const sc$$8 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, v, 32), "LT"); switch (sc$$8) { case "False": return { tag: "Lib.Common.quoteString.encode",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(null, arg.h3, arg.h2.h1) }; case "True": return { tag: "Lib.Common.quoteString.encode",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2,  h3: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h3, "\\"), "u"), Prelude_fromMaybe(null, " ", Prelude_getAt(null, Prelude_intToNat(Prelude_mod(((v) / (4096)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(null, " ", Prelude_getAt(null, Prelude_intToNat(Prelude_mod(((v) / (256)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(null, " ", Prelude_getAt(null, Prelude_intToNat(Prelude_mod(((v) / (16)) | (0), 16)), Lib_Common_hexChars))), Prelude_fromMaybe(null, " ", Prelude_getAt(null, Prelude_intToNat(Prelude_mod(v, 16)), Lib_Common_hexChars))) }; } break; } } break; case "Nil": return { tag: "return",  h0: Prelude__$3C$3E$3E_(null, arg.h3, Prelude__$3A$3A_(null, "\"", Prelude_Nil(null))) }; } };
const Lib_Prettier_Nest = ( h0, h1 ) => ({ tag: "Nest",  h0: h0,  h1: h1 });
const Lib_Prettier_bracket = ( _$$0, _$$1, _$$2 ) => (Lib_Prettier_Alt(Lib_Prettier_flatten(Lib_Prettier_Seq(Lib_Prettier_Text(_$$0), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text(_$$2))))), Lib_Prettier_Seq(Lib_Prettier_Text(_$$0), Lib_Prettier_Seq(Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text(_$$2))))));
const Lib_Prettier_flatten = ( _$$0 ) => (bouncer(Lib_Prettier_REC_flatten, { tag: "Lib.Prettier.flatten",  h0: _$$0 }));
const Lib_Prettier_REC_flatten = ( arg ) => { switch (arg.h0.tag) { case "Alt": return { tag: "Lib.Prettier.flatten",  h0: arg.h0.h0 }; case "Seq": return { tag: "return",  h0: Lib_Prettier_Seq(Lib_Prettier_flatten(arg.h0.h0), Lib_Prettier_flatten(arg.h0.h1)) }; case "Nest": return { tag: "Lib.Prettier.flatten",  h0: arg.h0.h1 }; case "Text": return { tag: "return",  h0: Lib_Prettier_Text(arg.h0.h0) }; case "Line": return { tag: "return",  h0: Lib_Prettier_Text(" ") }; case "Empty": return { tag: "return",  h0: Lib_Prettier_Empty }; } };
const Lib_Types_parens = ( _$$0, _$$1, _$$2 ) => { const sc$$3 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, _$$1), "LT"); switch (sc$$3) { case "False": return _$$2; case "True": return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$2, Lib_Prettier_Text(")"))); } };
const Lib_Compile_altToDoc = ( _$$0 ) => { switch (_$$0.tag) { case "JLitAlt": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Compile_expToDoc(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(null, _$$0.h2))); case "JDefAlt": return Lib_Prettier_Seq(Lib_Prettier_Text("default"), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(null, _$$0.h1))); case "JConAlt": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(Lib_Common_quoteString(_$$0.h1)))), Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Compile_caseBody(null, _$$0.h2))); } };
const Lib_Compile_caseBody = ( e$$0, _$$1 ) => { switch (_$$1.tag) { case "JCase": return Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(null, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("break;")))); case "JReturn": return Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(null, _$$1))); default: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_line, Lib_Compile_stmtToDoc(null, _$$1)), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("break;")))))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Text("}"))); } };
const Lib_Prettier__$3C$2F$3E_ = ( _$$0, _$$1 ) => (Lib_Prettier_Seq(_$$0, Lib_Prettier_Seq(Lib_Prettier_line, _$$1)));
const Lib_Compile_process = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Compile_getEntries(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), _$$0), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primNewIORef(null, entries)), ( ref ) => { const foo = Lib_Ref2_MkRef(null, null, ref); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Compile_eraseEntries(Lib_Ref2_MkRef(null, null, ref)), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhere(Lib_Ref2_MkRef(null, null, ref)), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, ref)), ( entries1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_mapM(null, Lib_Types_Prelude_Monad$20Lib_Types_M, null, null, ( eta ) => (Lib_CompileExp_defToCExp(Lib_Ref2_MkRef(null, null, ref), eta)), Data_SortedMap_toList(null, null, entries1)), ( exprs ) => { const cexpMap = Data_SortedMap_foldMap(null, null, ( _$$2 ) => (( _$$3 ) => (_$$2)), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), exprs); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TCO_tailCallOpt(cexpMap), ( cexpMap1 ) => { const names = Lib_Compile_sortedNames(cexpMap1, _$$0); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Compile_cexpToDoc, Prelude_mapMaybe(null, null, ( x ) => (Data_SortedMap_lookupMap(null, null, x, cexpMap1)), names))); }); }))))))); }))))));
const Data_SortedMap_lookupMap = ( k$$0, v$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "MapOf": return Data_SortedMap_lookupT23(null, null, null, _$$3.h3, _$$2, _$$3.h4); default: return Prelude_Nothing(null); } };
const Data_SortedMap_lookupT23 = ( h$$0, k$$1, v$$2, _$$3, _$$4, _$$5 ) => (bouncer(Data_SortedMap_REC_lookupT23, { tag: "Data.SortedMap.lookupT23",  h0: h$$0,  h1: k$$1,  h2: v$$2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Data_SortedMap_REC_lookupT23 = ( arg ) => { switch (arg.h5.tag) { case "Node3": { const sc$$14 = arg.h3(arg.h4)(arg.h5.h4); switch (sc$$14) { case "GT": { const sc$$15 = arg.h3(arg.h4)(arg.h5.h6); switch (sc$$15) { case "GT": return { tag: "Data.SortedMap.lookupT23",  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h7 }; default: return { tag: "Data.SortedMap.lookupT23",  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h5 }; } break; } default: return { tag: "Data.SortedMap.lookupT23",  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h3 }; } break; } case "Node2": { const sc$$12 = arg.h3(arg.h4)(arg.h5.h4); switch (sc$$12) { case "GT": return { tag: "Data.SortedMap.lookupT23",  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h5 }; default: return { tag: "Data.SortedMap.lookupT23",  h0: null,  h1: null,  h2: null,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h3 }; } break; } case "Leaf": { const sc$$10 = arg.h3(arg.h5.h2)(arg.h4); switch (sc$$10) { case "EQ": return { tag: "return",  h0: Prelude_Just(null, Prelude__$2C_(null, null, arg.h5.h2, arg.h5.h3)) }; default: return { tag: "return",  h0: Prelude_Nothing(null) }; } break; } } };
const Prelude_mapMaybe = ( a$$0, b$$1, _$$2, _$$3 ) => (Prelude_mapMaybe_go(a$$0, b$$1, _$$2, _$$3, null, Prelude_Lin(null), _$$3));
const Prelude_mapMaybe_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Prelude_REC_mapMaybe_go, { tag: "Prelude.mapMaybe.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Prelude_REC_mapMaybe_go = ( arg ) => { switch (arg.h6.tag) { case "_::_": { const sc$$10 = arg.h2(arg.h6.h1); switch (sc$$10.tag) { case "Nothing": return { tag: "Prelude.mapMaybe.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h2 }; case "Just": return { tag: "Prelude.mapMaybe.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Prelude__$3A$3C_(null, arg.h5, sc$$10.h1),  h6: arg.h6.h2 }; } break; } case "Nil": return { tag: "return",  h0: Prelude__$3C$3E$3E_(null, arg.h5, Prelude_Nil(null)) }; } };
const Lib_Compile_cexpToDoc = ( _$$0 ) => { const exp = Lib_Compile_maybeWrap(Lib_Compile_termToJS(null, Lib_Compile_emptyJSEnv, _$$0.h3, Lib_Compile_JReturn)); return Lib_Compile_stmtToDoc(null, Lib_Compile_JConst(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h2), exp)); };
const Lib_Compile_JConst = ( h0, h1 ) => ({ tag: "JConst",  h0: h0,  h1: h1 });
const Lib_Compile_JReturn = ( h0 ) => ({ tag: "JReturn",  h0: h0 });
const Lib_Compile_MkEnv = ( h0, h1 ) => ({ tag: "MkEnv",  h0: h0,  h1: h1 });
const Lib_Compile_emptyJSEnv = Lib_Compile_MkEnv(Prelude_Nil(null), 0);
const Lib_Compile_termToJS = ( e$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Compile_REC_termToJS, { tag: "Lib.Compile.termToJS",  h0: e$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Compile_REC_termToJS = ( arg ) => { switch (arg.tag) { case "Lib.Compile.termToJS": switch (arg.h2.tag) { case "CPrimOp": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: arg.h1,  h2: arg.h2.h1,  h3: ( t ) => (Lib_Compile_termToJS(null, arg.h1, arg.h2.h2, ( u ) => (arg.h3(Lib_Compile_JPrimOp(arg.h2.h0, t, u))))) }; case "CRaw": return { tag: "return",  h0: arg.h3(Lib_Compile_Raw(arg.h2.h0)) }; case "CConstr": return { tag: "Lib.Compile.termToJS.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h2.h0,  h5: arg.h2.h1,  h6: null,  h7: null,  h8: arg.h2.h1,  h9: 0,  h10: ( args ) => (arg.h3(Lib_Compile_LitObject(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "tag", Lib_Compile_LitString(arg.h2.h0)), args)))) }; case "CErased": return { tag: "return",  h0: arg.h3(Lib_Compile_JUndefined) }; case "CLetRec": switch (arg.h2.h1.tag) { case "CErased": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_JUndefined, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 }; default: { const nm$27 = Lib_Compile_freshName(arg.h2.h0, arg.h1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Var(nm$27), arg.h1.h0), arg.h1.h1); const sc$$9 = Lib_Compile_termToJS(null, env$27, arg.h2.h1, ( eta ) => (Lib_Compile_JAssign(nm$27, eta))); switch (sc$$9.tag) { case "JAssign": return { tag: "return",  h0: Lib_Compile_JSnoc(null, Lib_Compile_JConst(nm$27, sc$$9.h1), Lib_Compile_termToJS(null, env$27, arg.h2.h2, arg.h3)) }; default: return { tag: "return",  h0: Lib_Compile_JSnoc(null, Lib_Compile_JLet(nm$27, sc$$9), Lib_Compile_termToJS(null, env$27, arg.h2.h2, arg.h3)) }; } break; } } break; case "CLet": switch (arg.h2.h1.tag) { case "CBnd": { const sc$$8 = Prelude_getAt(null, Prelude_intToNat(arg.h2.h1.h0), arg.h1.h0); switch (sc$$8.tag) { case "Nothing": return { tag: "return",  h0: Prelude_fatalError(null, "bad bounds") }; case "Just": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(null, sc$$8.h1, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 }; } break; } default: { const nm$27 = Lib_Compile_freshName(arg.h2.h0, arg.h1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Var(nm$27), arg.h1.h0), arg.h1.h1); const sc$$9 = Lib_Compile_termToJS(null, arg.h1, arg.h2.h1, ( eta ) => (Lib_Compile_JAssign(nm$27, eta))); switch (sc$$9.tag) { case "JAssign": { const sc$$12 = Lib_Compile_simpleJSExp(sc$$9.h1); switch (sc$$12) { case "False": return { tag: "return",  h0: Lib_Compile_JSnoc(null, Lib_Compile_JConst(nm$27, sc$$9.h1), Lib_Compile_termToJS(null, env$27, arg.h2.h2, arg.h3)) }; case "True": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: Lib_Compile_MkEnv(Prelude__$3A$3A_(null, sc$$9.h1, arg.h1.h0), arg.h1.h1),  h2: arg.h2.h2,  h3: arg.h3 }; } break; } default: return { tag: "return",  h0: Lib_Compile_JSnoc(null, Lib_Compile_JLet(nm$27, sc$$9), Lib_Compile_termToJS(null, env$27, arg.h2.h2, arg.h3)) }; } break; } } break; case "CLit": return { tag: "return",  h0: arg.h3(Lib_Compile_litToJS(arg.h2.h0)) }; case "CMeta": return { tag: "return",  h0: arg.h3(Lib_Compile_LitString((("META ") + (Prelude_showInt(arg.h2.h0))) + (""))) }; case "CRef": return { tag: "return",  h0: arg.h3(Lib_Compile_Var(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h2.h0))) }; case "CCase": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: arg.h1,  h2: arg.h2.h0,  h3: ( $$case ) => { switch ($$case.tag) { case "Var": return Lib_Compile_termToJS_termToJSAlt_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, arg.h1, Lib_Compile_Var($$case.h0), arg.h2.h1); default: { const nm = (("_sc$") + (Prelude_showInt(arg.h1.h1))) + (""); const env$27 = Lib_Compile_MkEnv(arg.h1.h0, (1) + (arg.h1.h1)); const sc$$12 = Lib_Compile_simpleJSExp($$case); switch (sc$$12) { case "False": return Lib_Compile_JSnoc(null, Lib_Compile_JConst(nm, $$case), Lib_Compile_termToJS_termToJSAlt_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, env$27, Lib_Compile_Var(nm), arg.h2.h1)); case "True": return Lib_Compile_termToJS_termToJSAlt_maybeCaseStmt(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, null, null, env$27, $$case, arg.h2.h1); } break; } } } }; case "CApp": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: arg.h1,  h2: arg.h2.h0,  h3: ( t$27 ) => (Lib_Compile_termToJS(null, arg.h1, arg.h2.h1, ( arg$27 ) => (arg.h3(Lib_Compile_Apply(t$27, Prelude__$3A$3A_(null, arg$27, Prelude_Nil(null))))))) }; case "CAppRef": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: arg.h1,  h2: Lib_CompileExp_CRef(arg.h2.h0),  h3: ( t$27 ) => (Lib_Compile_termToJS_etaExpand_argsToJS(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, arg.h2.h2, null, null, null, arg.h1, t$27, arg.h2.h1, Prelude_Lin(null), arg.h3)) }; case "CFun": { const sc$$6 = Lib_Compile_freshNames(arg.h2.h0, arg.h1); return { tag: "return",  h0: arg.h3(Lib_Compile_JLam(sc$$6.h2, Lib_Compile_termToJS(null, sc$$6.h3, arg.h2.h1, Lib_Compile_JReturn))) }; break; } case "CLam": { const sc$$6 = Lib_Compile_freshName$27(arg.h2.h0, arg.h1); return { tag: "return",  h0: arg.h3(Lib_Compile_JLam(Prelude__$3A$3A_(null, sc$$6.h2, Prelude_Nil(null)), Lib_Compile_termToJS(null, sc$$6.h3, arg.h2.h1, Lib_Compile_JReturn))) }; break; } case "CBnd": { const sc$$5 = Prelude_getAt(null, Prelude_intToNat(arg.h2.h0), arg.h1.h0); switch (sc$$5.tag) { case "Nothing": return { tag: "return",  h0: Prelude_fatalError(null, "Bad bounds") }; case "Just": return { tag: "return",  h0: arg.h3(sc$$5.h1) }; } break; } } break; case "Lib.Compile.termToJS.go": switch (arg.h8.tag) { case "_::_": return { tag: "Lib.Compile.termToJS",  h0: null,  h1: arg.h1,  h2: arg.h8.h1,  h3: ( t$27 ) => (Lib_Compile_termToJS_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, null, arg.h8.h2, (arg.h9) + (1), ( args ) => (arg.h10(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, (("h") + (Prelude_showInt(arg.h9))) + (""), t$27), args))))) }; case "Nil": return { tag: "return",  h0: arg.h10(Prelude_Nil(null)) }; } break; } };
const Lib_Compile_termToJS_go = ( _, _1, _2, _3, _4, _5, _6, e$$7, _$$8, _$$9, _$$10 ) => (bouncer(Lib_Compile_REC_termToJS, { tag: "Lib.Compile.termToJS.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: e$$7,  h8: _$$8,  h9: _$$9,  h10: _$$10 }));
const Lib_Compile_JLam = ( h0, h1 ) => ({ tag: "JLam",  h0: h0,  h1: h1 });
const Lib_Compile_freshName$27 = ( _$$0, _$$1 ) => { const nm$27 = Lib_Compile_freshName(_$$0, _$$1); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Var(nm$27), _$$1.h0), _$$1.h1); return Prelude__$2C_(null, null, nm$27, env$27); };
const Lib_Compile_freshName = ( _$$0, _$$1 ) => { const sc$$4 = Lib_Compile_freshName_free(_$$0, _$$1, null, _$$1.h0, _$$0); switch (sc$$4) { case "False": return Lib_Compile_freshName_free_go(_$$0, _$$1, null, null, _$$0, 1); case "True": return _$$0; } };
const Lib_Compile_freshName_free_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Lib_Compile_REC_freshName_free_go, { tag: "Lib.Compile.freshName.free.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Lib_Compile_REC_freshName_free_go = ( arg ) => { const nm$27 = (((("") + (arg.h4)) + ("")) + (Prelude_showInt(arg.h5))) + (""); const sc$$7 = Lib_Compile_freshName_free(arg.h0, arg.h1, arg.h2, arg.h1.h0, nm$27); switch (sc$$7) { case "False": return { tag: "Lib.Compile.freshName.free.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (1) + (arg.h5) }; case "True": return { tag: "return",  h0: nm$27 }; } };
const Lib_Compile_freshName_free = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Compile_REC_freshName_free, { tag: "Lib.Compile.freshName.free",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Compile_REC_freshName_free = ( arg ) => { switch (arg.h3.tag) { case "_::_": switch (arg.h3.h1.tag) { case "Var": { const sc$$9 = Prelude_jsEq(null, arg.h3.h1.h0, arg.h4); switch (sc$$9) { case "False": return { tag: "Lib.Compile.freshName.free",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: arg.h4 }; case "True": return { tag: "return",  h0: "False" }; } break; } default: return { tag: "Lib.Compile.freshName.free",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: arg.h4 }; } break; case "Nil": return { tag: "return",  h0: "True" }; } };
const Lib_Compile_freshNames = ( _$$0, _$$1 ) => (Lib_Compile_freshNames_go(_$$0, _$$1, null, _$$0, _$$1, Prelude_Lin(null)));
const Lib_Compile_freshNames_go = ( _, _1, _2, _$$3, _$$4, _$$5 ) => (bouncer(Lib_Compile_REC_freshNames_go, { tag: "Lib.Compile.freshNames.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Lib_Compile_REC_freshNames_go = ( arg ) => { switch (arg.h3.tag) { case "_::_": { const sc$$9 = Lib_Compile_freshName$27(arg.h3.h1, arg.h4); return { tag: "Lib.Compile.freshNames.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2,  h4: sc$$9.h3,  h5: Prelude__$3A$3C_(null, arg.h5, sc$$9.h2) }; break; } case "Nil": return { tag: "return",  h0: Prelude__$2C_(null, null, Prelude__$3C$3E$3E_(null, arg.h5, Prelude_Nil(null)), arg.h4) }; } };
const Lib_Compile_termToJS_etaExpand_argsToJS = ( _, _1, _2, _3, _4, _5, _6, _7, _8, e$$9, _$$10, _$$11, _$$12, _$$13, _$$14 ) => { switch (_$$12.tag) { case "_::_": return Lib_Compile_termToJS(null, _$$10, _$$12.h1, ( x$27 ) => (Lib_Compile_termToJS_etaExpand_argsToJS(_, _1, _2, _3, _4, _5, _6, _7, _8, null, Lib_Compile_MkEnv(_$$10.h0, (1) + (_$$10.h1)), _$$11, _$$12.h2, Prelude__$3A$3C_(null, _$$13, x$27), _$$14))); case "Nil": return _$$14(Lib_Compile_termToJS_etaExpand(_, _1, _2, _3, _4, _5, _6, _7, _$$10, Prelude_intToNat(_6), _$$13, _$$11)); } };
const Lib_Compile_termToJS_etaExpand = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11 ) => { switch (_$$9) { case 0: return Lib_Compile_Apply(_$$11, Prelude__$3C$3E$3E_(null, _$$10, Prelude_Nil(null))); default: { const x = (_$$9) - (1); const nm$27 = Lib_Compile_freshName("eta", _$$8); const env$27 = Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Var(nm$27), _$$8.h0), _$$8.h1); return Lib_Compile_JLam(Prelude__$3A$3A_(null, nm$27, Prelude_Nil(null)), Lib_Compile_JReturn(Lib_Compile_termToJS_etaExpand(_, _1, _2, _3, _4, _5, _6, _7, Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Var(nm$27), _$$8.h0), _$$8.h1), x, Prelude__$3A$3C_(null, _$$10, Lib_Compile_Var(nm$27)), _$$11))); break; } } };
const Lib_CompileExp_CRef = ( h0 ) => ({ tag: "CRef",  h0: h0 });
const Lib_Compile_termToJS_termToJSAlt_maybeCaseStmt = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10 ) => { switch (_$$10.tag) { case "_::_": switch (_$$10.h1.tag) { case "CLitAlt": return Lib_Compile_JCase(null, _$$9, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_termToJS_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9, eta)), _$$10)); case "CConAlt": switch (_$$10.h2.tag) { case "Nil": return Lib_Compile_termToJS(null, Lib_Compile_mkEnv(_$$9, 0, _$$8, _$$10.h1.h2), _$$10.h1.h3, _3); default: return Lib_Compile_JCase(null, Lib_Compile_Dot(_$$9, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_termToJS_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9, eta)), _$$10)); } break; default: return Lib_Compile_JCase(null, Lib_Compile_Dot(_$$9, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_termToJS_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9, eta)), _$$10)); } break; default: return Lib_Compile_JCase(null, Lib_Compile_Dot(_$$9, "tag"), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_termToJS_termToJSAlt(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9, eta)), _$$10)); } };
const Lib_Compile_termToJS_termToJSAlt = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => { switch (_$$9.tag) { case "CLitAlt": return Lib_Compile_JLitAlt(null, Lib_Compile_litToJS(_$$9.h0), Lib_Compile_termToJS(null, _$$7, _$$9.h1, _3)); case "CDefAlt": return Lib_Compile_JDefAlt(null, Lib_Compile_termToJS(null, _$$7, _$$9.h0, _3)); case "CConAlt": return Lib_Compile_JConAlt(null, _$$9.h0, Lib_Compile_termToJS(null, Lib_Compile_mkEnv(_$$8, 0, _$$7, _$$9.h2), _$$9.h3, _3)); } };
const Lib_Compile_mkEnv = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Compile_REC_mkEnv, { tag: "Lib.Compile.mkEnv",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Compile_REC_mkEnv = ( arg ) => { switch (arg.h3.tag) { case "_::_": return { tag: "Lib.Compile.mkEnv",  h0: arg.h0,  h1: (1) + (arg.h1),  h2: Lib_Compile_MkEnv(Prelude__$3A$3A_(null, Lib_Compile_Dot(arg.h0, (("h") + (Prelude_showInt(arg.h1))) + ("")), arg.h2.h0), arg.h2.h1),  h3: arg.h3.h2 }; case "Nil": return { tag: "return",  h0: arg.h2 }; } };
const Lib_Compile_Dot = ( h0, h1 ) => ({ tag: "Dot",  h0: h0,  h1: h1 });
const Lib_Compile_JConAlt = ( h0, h1, h2 ) => ({ tag: "JConAlt",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_JDefAlt = ( h0, h1 ) => ({ tag: "JDefAlt",  h0: h0,  h1: h1 });
const Lib_Compile_litToJS = ( _$$0 ) => { switch (_$$0.tag) { case "LChar": return Lib_Compile_LitString(Prelude_pack(Prelude__$3A$3A_(null, _$$0.h0, Prelude_Nil(null)))); case "LInt": return Lib_Compile_LitInt(_$$0.h0); case "LString": return Lib_Compile_LitString(_$$0.h0); } };
const Lib_Compile_LitString = ( h0 ) => ({ tag: "LitString",  h0: h0 });
const Lib_Compile_LitInt = ( h0 ) => ({ tag: "LitInt",  h0: h0 });
const Lib_Compile_JLitAlt = ( h0, h1, h2 ) => ({ tag: "JLitAlt",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_JCase = ( h0, h1, h2 ) => ({ tag: "JCase",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_JSnoc = ( h0, h1, h2 ) => ({ tag: "JSnoc",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_simpleJSExp = ( _$$0 ) => (bouncer(Lib_Compile_REC_simpleJSExp, { tag: "Lib.Compile.simpleJSExp",  h0: _$$0 }));
const Lib_Compile_REC_simpleJSExp = ( arg ) => { switch (arg.h0.tag) { case "Dot": return { tag: "Lib.Compile.simpleJSExp",  h0: arg.h0.h0 }; case "Index": { const sc$$3 = Lib_Compile_simpleJSExp(arg.h0.h0); switch (sc$$3) { case "False": return { tag: "return",  h0: "False" }; case "True": return { tag: "Lib.Compile.simpleJSExp",  h0: arg.h0.h1 }; } break; } case "JUndefined": return { tag: "return",  h0: "True" }; case "Var": return { tag: "return",  h0: "True" }; case "LitInt": return { tag: "return",  h0: "True" }; case "LitString": return { tag: "return",  h0: "True" }; default: return { tag: "return",  h0: "False" }; } };
const Lib_Compile_JLet = ( h0, h1 ) => ({ tag: "JLet",  h0: h0,  h1: h1 });
const Lib_Compile_JAssign = ( h0, h1 ) => ({ tag: "JAssign",  h0: h0,  h1: h1 });
const Lib_Compile_JUndefined = { tag: "JUndefined" };
const Lib_Compile_LitObject = ( h0 ) => ({ tag: "LitObject",  h0: h0 });
const Lib_Compile_Raw = ( h0 ) => ({ tag: "Raw",  h0: h0 });
const Lib_Compile_JPrimOp = ( h0, h1, h2 ) => ({ tag: "JPrimOp",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Compile_maybeWrap = ( _$$0 ) => { switch (_$$0.tag) { case "JReturn": return _$$0.h0; default: return Lib_Compile_Apply(Lib_Compile_JLam(Prelude_Nil(null), _$$0), Prelude_Nil(null)); } };
const Lib_Compile_sortedNames = ( _$$0, _$$1 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h3), Prelude_filter(null, ( _$$5 ) => (Prelude_not(_$$5.h2)), Lib_Compile_sortedNames_getBody_getNames_go(_$$0, _$$1, null, null, null, Prelude_Nil(null), Prelude_Nil(null), Prelude__$2C_(null, null, "True", _$$1)))));
const Lib_Compile_sortedNames_getBody_getNames_go = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => { let acc; const sc$$12 = Prelude__$26$26_(_$$7.h2, Prelude__$26$26_(Prelude_not(Prelude_elem(null, Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(null, null, Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), Prelude__$2C_(null, null, "False", _$$7.h3), _$$6)), Prelude_not(Prelude_elem(null, Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(null, null, Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), Prelude__$2C_(null, null, "False", _$$7.h3), _$$5)))); switch (sc$$12) { case "False": { acc = _$$6; break; } case "True": { acc = Lib_Compile_sortedNames_getBody_getNames_go(_, _1, _2, _3, _4, _$$5, _$$6, Prelude__$2C_(null, null, "False", _$$7.h3)); break; } } const sc$$13 = Prelude_elem(null, Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(null, null, Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), _$$7, _$$5); switch (sc$$13) { case "False": { const sc$$14 = Prelude_elem(null, Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29(null, null, Prelude_Prelude_Eq$20Prelude_Bool, Lib_Common_Prelude_Eq$20Lib_Common_QName), _$$7, acc); switch (sc$$14) { case "False": { const sc$$15 = Data_SortedMap_lookupMap$27(null, null, _$$7.h3, _); switch (sc$$15.tag) { case "Nothing": return acc; case "Just": return Prelude__$3A$3A_(null, _$$7, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames_go(_, _1, _2, _3, _4, Prelude__$3A$3A_(null, _$$7, _$$5), eta, eta1))), acc, Lib_Compile_sortedNames_getBody_getNames(_, _1, _2, _3, _$$7.h2, Prelude_Nil(null), sc$$15.h1))); } break; } case "True": return acc; } break; } case "True": return acc; } };
const Lib_Compile_sortedNames_getBody_getNames = ( _, _1, _2, _3, deep$$4, _$$5, _$$6 ) => (bouncer(Lib_Compile_REC_sortedNames_getBody_getNames, { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: deep$$4,  h5: _$$5,  h6: _$$6 }));
const Lib_Compile_REC_sortedNames_getBody_getNames = ( arg ) => { switch (arg.h6.tag) { case "CPrimOp": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case "CRaw": return { tag: "return",  h0: Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude__$2C_(null, null, arg.h4, eta)), arg.h6.h1), arg.h5) }; case "CConstr": return { tag: "return",  h0: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), arg.h5, arg.h6.h1) }; case "CErased": return { tag: "return",  h0: arg.h5 }; case "CLetRec": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case "CLet": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case "CLit": return { tag: "return",  h0: arg.h5 }; case "CMeta": return { tag: "return",  h0: arg.h5 }; case "CRef": return { tag: "return",  h0: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4, arg.h6.h0), arg.h5) }; case "CCase": return { tag: "return",  h0: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), arg.h5, Prelude__$3A$3A_(null, arg.h6.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Compile_sortedNames_getBody(arg.h0, arg.h1, arg.h2, eta)), arg.h6.h1))) }; case "CApp": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: "True",  h5: Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6.h1),  h6: arg.h6.h0 }; case "CAppRef": switch (arg.h6.h1.tag) { case "Nil": switch (arg.h6.h2) { case 0: return { tag: "return",  h0: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "True", arg.h6.h0), arg.h5) }; default: return { tag: "return",  h0: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4, arg.h6.h0), arg.h5), arg.h6.h1) }; } break; default: switch (arg.h6.h2) { case 0: return { tag: "return",  h0: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, "True", eta, eta1))), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "True", arg.h6.h0), arg.h5), arg.h6.h1) }; default: return { tag: "return",  h0: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_sortedNames_getBody_getNames(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, eta, eta1))), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h4, arg.h6.h0), arg.h5), arg.h6.h1) }; } break; } break; case "CFun": switch (arg.h4) { case "False": return { tag: "return",  h0: arg.h5 }; case "True": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; } break; case "CLam": return { tag: "Lib.Compile.sortedNames.getBody.getNames",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; case "CBnd": return { tag: "return",  h0: arg.h5 }; } };
const Prelude_foldl = ( A$$0, B$$1, _$$2, _$$3, _$$4 ) => (bouncer(Prelude_REC_foldl, { tag: "Prelude.foldl",  h0: A$$0,  h1: B$$1,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Prelude_REC_foldl = ( arg ) => { switch (arg.h4.tag) { case "_::_": return { tag: "Prelude.foldl",  h0: null,  h1: null,  h2: arg.h2,  h3: arg.h2(arg.h3)(arg.h4.h1),  h4: arg.h4.h2 }; case "Nil": return { tag: "return",  h0: arg.h3 }; } };
const Lib_Compile_sortedNames_getBody = ( _, _1, _2, _$$3 ) => { switch (_$$3.tag) { case "CLitAlt": return _$$3.h1; case "CDefAlt": return _$$3.h0; case "CConAlt": return _$$3.h3; } };
const Data_SortedMap_lookupMap$27 = ( k$$0, v$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "MapOf": return Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, ( _$$21 ) => (_$$21.h3), Data_SortedMap_lookupT23(null, null, null, _$$3.h3, _$$2, _$$3.h4)); default: return Prelude_Nothing(null); } };
const Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_ = ( _$$0, _$$1 ) => { const sc$$6 = Prelude_jsEq(null, _$$0.h1, _$$1.h1); switch (sc$$6) { case "False": return "False"; case "True": return Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(null, Prelude_Prelude_Eq$20Prim_String, _$$0.h0, _$$1.h0); } };
const Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_ = ( a$$0, _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_, { tag: "Prelude.Prelude.Eq (Prelude.List BND:1),_==_",  h0: a$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_ = ( arg ) => { switch (arg.h3.tag) { case "_::_": switch (arg.h2.tag) { case "_::_": { const sc$$10 = Prelude__$3D$3D_(null, arg.h1)(arg.h2.h1)(arg.h3.h1); switch (sc$$10) { case "False": return { tag: "return",  h0: "False" }; case "True": return { tag: "Prelude.Prelude.Eq (Prelude.List BND:1),_==_",  h0: null,  h1: arg.h1,  h2: arg.h2.h2,  h3: arg.h3.h2 }; } break; } default: return { tag: "return",  h0: "False" }; } break; case "Nil": switch (arg.h2.tag) { case "Nil": return { tag: "return",  h0: "True" }; default: return { tag: "return",  h0: "False" }; } break; } };
const Lib_Common_Prelude_Eq$20Lib_Common_QName = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(eta, eta1))));
const Prelude_Prelude_Eq$20Prelude_Bool$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$0) { case "False": switch (_$$1) { case "False": return "True"; default: return "False"; } break; case "True": return _$$1; } };
const Prelude_Prelude_Eq$20Prelude_Bool = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prelude_Bool$2C_$3D$3D_(eta, eta1))));
const Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29 = ( a, b, _, _1 ) => (Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2C_$3D$3D_(null, null, _, _1, eta, eta1)))));
const Prelude_Prelude_Eq$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2C_$3D$3D_ = ( a$$0, b$$1, _$$2, _$$3, _$$4, _$$5 ) => (Prelude__$26$26_(Prelude__$3D$3D_(null, _$$2)(_$$4.h2)(_$$5.h2), Prelude__$3D$3D_(null, _$$3)(_$$4.h3)(_$$5.h3)));
const Prelude_filter = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC_filter, { tag: "Prelude.filter",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_filter = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$6 = arg.h1(arg.h2.h1); switch (sc$$6) { case "False": return { tag: "Prelude.filter",  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; case "True": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h2.h1, Prelude_filter(null, arg.h1, arg.h2.h2)) }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_TCO_tailCallOpt = ( _$$0 ) => { const graph = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap(null, null, null, null, ( _$$1 ) => (_$$1), Lib_TCO_tailNames, eta)), Data_SortedMap_toList(null, null, _$$0)); const groups = Data_Graph_tarjan(null, Lib_Common_Prelude_Eq$20Lib_Common_QName, Lib_Common_Prelude_Ord$20Lib_Common_QName, graph); return Prelude_foldlM(null, null, null, Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_TCO_tailCallOpt_doUpdate_processGroup(_$$0, null, null, eta, eta1))), _$$0, groups); };
const Lib_TCO_tailCallOpt_doUpdate_processGroup = ( _, _1, _2, _$$3, _$$4 ) => { const pairs = Prelude_mapMaybe(null, null, ( _$$5 ) => (Data_SortedMap_lookupMap(null, null, _$$5, _$$3)), _$$4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TCO_doOptimize(pairs), ( updates ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_TCO_tailCallOpt_doUpdate(_, _1, eta, eta1))), _$$3, updates)))); };
const Lib_TCO_tailCallOpt_doUpdate = ( _, _1, _$$2, _$$3 ) => (Data_SortedMap_updateMap(null, null, _$$3.h2, _$$3.h3, _$$2));
const Data_SortedMap_updateMap = ( k$$0, v$$1, _$$2, _$$3, _$$4 ) => { switch (_$$4.tag) { case "MapOf": { const sc$$10 = Data_SortedMap_insertT23(null, null, null, _$$4.h3, _$$2, _$$3, _$$4.h4); switch (sc$$10.tag) { case "Right": return Data_SortedMap_MapOf(null, null, (1) + (_$$4.h2), _$$4.h3, Data_SortedMap_Node2(null, null, null, sc$$10.h2.h2, sc$$10.h2.h3.h2, sc$$10.h2.h3.h3)); case "Left": return Data_SortedMap_MapOf(null, null, _$$4.h2, _$$4.h3, sc$$10.h2); } break; } case "EmptyMap": return Data_SortedMap_MapOf(null, null, 0, _$$4.h2, Data_SortedMap_Leaf(null, null, _$$2, _$$3)); } };
const Data_SortedMap_Leaf = ( h0, h1, h2, h3 ) => ({ tag: "Leaf",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Data_SortedMap_MapOf = ( h0, h1, h2, h3, h4 ) => ({ tag: "MapOf",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Data_SortedMap_Node2 = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "Node2",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Data_SortedMap_insertT23 = ( h$$0, k$$1, v$$2, _$$3, _$$4, _$$5, _$$6 ) => { switch (_$$6.tag) { case "Node3": { const sc$$15 = _$$3(_$$4)(_$$6.h4); switch (sc$$15) { case "GT": { const sc$$16 = _$$3(_$$4)(_$$6.h6); switch (sc$$16) { case "GT": { const sc$$17 = Data_SortedMap_insertT23(null, null, null, _$$3, _$$4, _$$5, _$$6.h7); switch (sc$$17.tag) { case "Right": return Prelude_Right(null, null, Prelude__$2C_(null, null, Data_SortedMap_Node2(null, null, null, _$$6.h3, _$$6.h4, _$$6.h5), Prelude__$2C_(null, null, _$$6.h6, Data_SortedMap_Node2(null, null, null, sc$$17.h2.h2, sc$$17.h2.h3.h2, sc$$17.h2.h3.h3)))); case "Left": return Prelude_Left(null, null, Data_SortedMap_Node3(null, null, null, _$$6.h3, _$$6.h4, _$$6.h5, _$$6.h6, sc$$17.h2)); } break; } default: { const sc$$17 = Data_SortedMap_insertT23(null, null, null, _$$3, _$$4, _$$5, _$$6.h5); switch (sc$$17.tag) { case "Right": return Prelude_Right(null, null, Prelude__$2C_(null, null, Data_SortedMap_Node2(null, null, null, _$$6.h3, _$$6.h4, sc$$17.h2.h2), Prelude__$2C_(null, null, sc$$17.h2.h3.h2, Data_SortedMap_Node2(null, null, null, sc$$17.h2.h3.h3, _$$6.h6, _$$6.h7)))); case "Left": return Prelude_Left(null, null, Data_SortedMap_Node3(null, null, null, _$$6.h3, _$$6.h4, sc$$17.h2, _$$6.h6, _$$6.h7)); } break; } } break; } default: { const sc$$16 = Data_SortedMap_insertT23(null, null, null, _$$3, _$$4, _$$5, _$$6.h3); switch (sc$$16.tag) { case "Right": return Prelude_Right(null, null, Prelude__$2C_(null, null, Data_SortedMap_Node2(null, null, null, sc$$16.h2.h2, sc$$16.h2.h3.h2, sc$$16.h2.h3.h3), Prelude__$2C_(null, null, _$$6.h4, Data_SortedMap_Node2(null, null, null, _$$6.h5, _$$6.h6, _$$6.h7)))); case "Left": return Prelude_Left(null, null, Data_SortedMap_Node3(null, null, null, sc$$16.h2, _$$6.h4, _$$6.h5, _$$6.h6, _$$6.h7)); } break; } } break; } case "Node2": { const sc$$13 = _$$3(_$$4)(_$$6.h4); switch (sc$$13) { case "GT": { const sc$$14 = Data_SortedMap_insertT23(null, null, null, _$$3, _$$4, _$$5, _$$6.h5); switch (sc$$14.tag) { case "Right": return Prelude_Left(null, null, Data_SortedMap_Node3(null, null, null, _$$6.h3, _$$6.h4, sc$$14.h2.h2, sc$$14.h2.h3.h2, sc$$14.h2.h3.h3)); case "Left": return Prelude_Left(null, null, Data_SortedMap_Node2(null, null, null, _$$6.h3, _$$6.h4, sc$$14.h2)); } break; } default: { const sc$$14 = Data_SortedMap_insertT23(null, null, null, _$$3, _$$4, _$$5, _$$6.h3); switch (sc$$14.tag) { case "Right": return Prelude_Left(null, null, Data_SortedMap_Node3(null, null, null, sc$$14.h2.h2, sc$$14.h2.h3.h2, sc$$14.h2.h3.h3, _$$6.h4, _$$6.h5)); case "Left": return Prelude_Left(null, null, Data_SortedMap_Node2(null, null, null, sc$$14.h2, _$$6.h4, _$$6.h5)); } break; } } break; } case "Leaf": { const sc$$11 = _$$3(_$$4)(_$$6.h2); switch (sc$$11) { case "GT": return Prelude_Right(null, null, Prelude__$2C_(null, null, Data_SortedMap_Leaf(null, null, _$$6.h2, _$$6.h3), Prelude__$2C_(null, null, _$$6.h2, Data_SortedMap_Leaf(null, null, _$$4, _$$5)))); case "EQ": return Prelude_Left(null, null, Data_SortedMap_Leaf(null, null, _$$4, _$$5)); case "LT": return Prelude_Right(null, null, Prelude__$2C_(null, null, Data_SortedMap_Leaf(null, null, _$$4, _$$5), Prelude__$2C_(null, null, _$$4, Data_SortedMap_Leaf(null, null, _$$6.h2, _$$6.h3)))); } break; } } };
const Data_SortedMap_Node3 = ( h0, h1, h2, h3, h4, h5, h6, h7 ) => ({ tag: "Node3",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5,  h6: h6,  h7: h7 });
const Lib_TCO_doOptimize = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt_splitFun(_$$0, null, null, null, null, eta)), _$$0), ( splitFuns ) => { const nms = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0); const alts = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt(_$$0, null, null, null, nms, eta)), splitFuns); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TCO_doOptimize_mkWrap_mkRecName(_$$0, null, null, nms), ( recName ) => { const recfun = Lib_CompileExp_CFun(Prelude__$3A$3A_(null, "arg", Prelude_Nil(null)), Lib_CompileExp_CCase(Lib_CompileExp_CBnd(0), alts)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_TCO_doOptimize_mkWrap(_$$0, null, recName, eta)), _$$0), ( wrapped ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, recName, recfun), wrapped)))); }); }));
const Lib_TCO_doOptimize_mkWrap = ( _, _1, _$$2, _$$3 ) => { switch (_$$3.h3.tag) { case "CFun": { const arglen = Prelude_length$27(null, _$$3.h3.h0); const arg = Lib_CompileExp_CConstr(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h2), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( k ) => (Lib_CompileExp_CBnd(((arglen) - (k)) - (1))), Lib_Common_range(0, arglen))); const body = Lib_CompileExp_CAppRef(Lib_TCO_bouncer, Prelude__$3A$3A_(null, Lib_CompileExp_CRef(_$$2), Prelude__$3A$3A_(null, arg, Prelude_Nil(null))), 0); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$3.h2, Lib_CompileExp_CFun(_$$3.h3.h0, body))); break; } default: return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("error in mkWrap: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h2))) + (" not a CFun"))), eta)))); } };
const Lib_CompileExp_CFun = ( h0, h1 ) => ({ tag: "CFun",  h0: h0,  h1: h1 });
const Lib_Common_QN = ( h0, h1 ) => ({ tag: "QN",  h0: h0,  h1: h1 });
const Lib_TCO_bouncer = Lib_Common_QN(Prelude_Nil(null), "bouncer");
const Lib_CompileExp_CAppRef = ( h0, h1, h2 ) => ({ tag: "CAppRef",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Common_range = ( _$$0, _$$1 ) => { const sc$$2 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, _$$1), "LT"); switch (sc$$2) { case "False": return Prelude_Nil(null); case "True": return Prelude__$3A$3A_(null, _$$0, Lib_Common_range((_$$0) + (1), _$$1)); } };
const Lib_CompileExp_CBnd = ( h0 ) => ({ tag: "CBnd",  h0: h0 });
const Lib_CompileExp_CConstr = ( h0, h1 ) => ({ tag: "CConstr",  h0: h0,  h1: h1 });
const Prelude_length$27 = ( a$$0, _$$1 ) => (Prelude_length$27_go(a$$0, _$$1, null, null, _$$1, 0));
const Prelude_length$27_go = ( _, _1, _2, a$$3, _$$4, _$$5 ) => (bouncer(Prelude_REC_length$27_go, { tag: "Prelude.length'.go",  h0: _,  h1: _1,  h2: _2,  h3: a$$3,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_length$27_go = ( arg ) => { switch (arg.h4.tag) { case "_::_": return { tag: "Prelude.length'.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: null,  h4: arg.h4.h2,  h5: (arg.h5) + (1) }; case "Nil": return { tag: "return",  h0: arg.h5 }; } };
const Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_ = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$2.h1(tc), ( $$sc ) => { switch ($$sc.tag) { case "Right": return ( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$3.h1($$sc.h2.h2), ( $$sc1 ) => { switch ($$sc1.tag) { case "Right": return ( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, $$sc1.h2.h2, $$sc.h2.h3($$sc1.h2.h3))), eta)); case "Left": return ( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, $$sc1.h2), eta)); } }, eta)); case "Left": return ( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, $$sc.h2), eta)); } }, eta)))));
const Prelude_MkApplicative = ( h0, h1, h2 ) => ({ tag: "MkApplicative",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_Prelude_Applicative$20Lib_Types_M = Prelude_MkApplicative(null, ( a ) => (( eta ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, eta))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, eta, eta1))))));
const Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse = ( f$$0, a$$1, b$$2, _$$3, _$$4, _$$5 ) => { switch (_$$5.tag) { case "_::_": return Prelude__$3C$2A$3E_(null, _$$3)(null)(null)(Prelude__$3C$2A$3E_(null, _$$3)(null)(null)(Prelude_return(null, _$$3)(null)(( eta ) => (( eta1 ) => (Prelude__$3A$3A_(null, eta, eta1)))))(_$$4(_$$5.h1)))(Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, _$$3, _$$4, _$$5.h2)); case "Nil": return Prelude_return(null, _$$3)(null)(Prelude_Nil(null)); } };
const Prelude_return = ( f$$0, _$$1 ) => (( a ) => (_$$1.h1(null)));
const Prelude__$3C$2A$3E_ = ( f$$0, _$$1 ) => (( a ) => (( b ) => (_$$1.h2(null)(null))));
const Lib_CompileExp_CCase = ( h0, h1 ) => ({ tag: "CCase",  h0: h0,  h1: h1 });
const Lib_TCO_doOptimize_mkWrap_mkRecName = ( _, _1, _2, _$$3 ) => { switch (_$$3.tag) { case "_::_": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Common_QN(_$$3.h1.h0, (("REC_") + (_$$3.h1.h1)) + (""))); case "Nil": return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "INTERNAL ERROR: Empty List in doOptimize")), eta)))); } };
const Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt = ( _, _1, _2, _3, _$$4, _$$5 ) => (Lib_CompileExp_CConAlt(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h2), "NormalCon", _$$5.h3.h2, Lib_TCO_rewriteTailCalls(_$$4, _$$5.h3.h3)));
const Lib_TCO_rewriteTailCalls = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "CLetRec": return Lib_CompileExp_CLetRec(_$$1.h0, _$$1.h1, Lib_TCO_rewriteTailCalls(_$$0, _$$1.h2)); case "CLet": return Lib_CompileExp_CLet(_$$1.h0, _$$1.h1, Lib_TCO_rewriteTailCalls(_$$0, _$$1.h2)); case "CCase": return Lib_CompileExp_CCase(_$$1.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_TCO_rewriteTailCalls_rewriteAlt(_$$0, _$$1, null, eta)), _$$1.h1)); case "CAppRef": switch (_$$1.h2) { case 0: { const sc$$7 = Prelude_elem(null, Lib_Common_Prelude_Eq$20Lib_Common_QName, _$$1.h0, _$$0); switch (sc$$7) { case "False": return Lib_CompileExp_CConstr("return", Prelude__$3A$3A_(null, _$$1, Prelude_Nil(null))); case "True": return Lib_CompileExp_CConstr(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h0), _$$1.h1); } break; } default: return Lib_CompileExp_CConstr("return", Prelude__$3A$3A_(null, _$$1, Prelude_Nil(null))); } break; default: return Lib_CompileExp_CConstr("return", Prelude__$3A$3A_(null, _$$1, Prelude_Nil(null))); } };
const Lib_TCO_rewriteTailCalls_rewriteAlt = ( _, _1, _2, _$$3 ) => { switch (_$$3.tag) { case "CLitAlt": return Lib_CompileExp_CLitAlt(_$$3.h0, Lib_TCO_rewriteTailCalls(_, _$$3.h1)); case "CDefAlt": return Lib_CompileExp_CDefAlt(Lib_TCO_rewriteTailCalls(_, _$$3.h0)); case "CConAlt": return Lib_CompileExp_CConAlt(_$$3.h0, _$$3.h1, _$$3.h2, Lib_TCO_rewriteTailCalls(_, _$$3.h3)); } };
const Lib_CompileExp_CConAlt = ( h0, h1, h2, h3 ) => ({ tag: "CConAlt",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_CompileExp_CDefAlt = ( h0 ) => ({ tag: "CDefAlt",  h0: h0 });
const Lib_CompileExp_CLitAlt = ( h0, h1 ) => ({ tag: "CLitAlt",  h0: h0,  h1: h1 });
const Lib_CompileExp_CLet = ( h0, h1, h2 ) => ({ tag: "CLet",  h0: h0,  h1: h1,  h2: h2 });
const Lib_CompileExp_CLetRec = ( h0, h1, h2 ) => ({ tag: "CLetRec",  h0: h0,  h1: h1,  h2: h2 });
const Lib_TCO_doOptimize_mkWrap_mkRecName_mkAlt_splitFun = ( _, _1, _2, _3, _4, _$$5 ) => { switch (_$$5.h3.tag) { case "CFun": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$5.h2, Prelude__$2C_(null, null, _$$5.h3.h0, _$$5.h3.h1))); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("TCO error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h2))) + (" not a function"))), eta)))); } };
const Prelude_MkMonad = ( h0, h1, h2 ) => ({ tag: "MkMonad",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_Prelude_Monad$20Lib_Types_M = Prelude_MkMonad(null, ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, eta, eta1))))), ( a ) => (( eta ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, eta))));
const Prelude_foldlM = ( m$$0, a$$1, e$$2, _$$3, _$$4, _$$5, _$$6 ) => (Prelude_foldl(null, null, ( ma ) => (( b ) => (Prelude_bind(null, _$$3)(null)(null)(ma)(( _$$51 ) => (_$$4(_$$51)(b))))), Prelude_pure(null, _$$3)(null)(_$$5), _$$6));
const Prelude_pure = ( m$$0, _$$1 ) => (( a ) => (_$$1.h2(null)));
const Prelude_bind = ( m$$0, _$$1 ) => (( a ) => (( b ) => (_$$1.h1(null)(null))));
const Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare = ( _$$0, _$$1 ) => { const sc$$6 = Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(null, Prelude_Prelude_Eq$20Prim_String, _$$0.h0, _$$1.h0); switch (sc$$6) { case "False": return Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare(null, Prelude_Prelude_Ord$20Prim_String, _$$0.h0, _$$1.h0); case "True": return Prelude_jsCompare(null, _$$0.h1, _$$1.h1); } };
const Prelude_Prelude_Ord$20Prim_String$2Ccompare = ( _$$0, _$$1 ) => (Prelude_jsCompare(null, _$$0, _$$1));
const Prelude_MkOrd = ( h0, h1 ) => ({ tag: "MkOrd",  h0: h0,  h1: h1 });
const Prelude_Prelude_Ord$20Prim_String = Prelude_MkOrd(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))));
const Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare = ( a$$0, _$$1, _$$2, _$$3 ) => (bouncer(Prelude_REC_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare, { tag: "Prelude.Prelude.Ord (Prelude.List BND:1),compare",  h0: a$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Prelude_REC_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare = ( arg ) => { switch (arg.h3.tag) { case "_::_": switch (arg.h2.tag) { case "_::_": { const sc$$10 = Prelude_compare(null, arg.h1)(arg.h2.h1)(arg.h3.h1); switch (sc$$10) { case "EQ": return { tag: "Prelude.Prelude.Ord (Prelude.List BND:1),compare",  h0: null,  h1: arg.h1,  h2: arg.h2.h2,  h3: arg.h3.h2 }; default: return { tag: "return",  h0: sc$$10 }; } break; } case "Nil": return { tag: "return",  h0: "LT" }; } break; case "Nil": switch (arg.h2.tag) { case "Nil": return { tag: "return",  h0: "EQ" }; default: return { tag: "return",  h0: "GT" }; } break; } };
const Prelude_compare = ( a$$0, _$$1 ) => (_$$1.h1);
const Lib_Common_Prelude_Ord$20Lib_Common_QName = Prelude_MkOrd(null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1))));
const Data_Graph_tarjan = ( k$$0, _$$1, _$$2, _$$3 ) => { const g = Data_SortedMap_foldMap(null, null, ( _$$21 ) => (( _$$31 ) => (_$$21)), Data_SortedMap_EmptyMap(null, null, _$$2.h1), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Data_Graph_tarjan_mkVertex(k$$0, _$$1, _$$2, _$$3, null, eta)), _$$3)); const _sc$$0 = Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Data_Graph_tarjan_mkVertex_checkVertex(k$$0, _$$1, _$$2, _$$3, null, null, eta, eta1))), Data_Graph_MkTState(null, 0, Prelude_Nil(null), Prelude_Nil(null), g), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$3)); return _sc$$0.h3; };
const Data_Graph_MkTState = ( h0, h1, h2, h3, h4 ) => ({ tag: "MkTState",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Data_Graph_tarjan_mkVertex_checkVertex = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { const sc$$8 = Data_SortedMap_lookupMap$27(null, null, _$$7, _$$6.h4); switch (sc$$8.tag) { case "Just": { const sc$$11 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$8.h1.h3, 0), "GT"); switch (sc$$11) { case "False": return Data_Graph_strongConnect(null, _1, _2, _$$6, sc$$8.h1); case "True": return _$$6; } break; } default: return _$$6; } };
const Data_Graph_strongConnect = ( k$$0, _$$1, _$$2, _$$3, _$$4 ) => { const index$27 = (_$$3.h1) + (1); const vtx$27 = Data_Graph_MkTV(null, _$$4.h1, _$$4.h2, index$27, index$27, "True"); const stack$27 = Prelude__$3A$3A_(null, _$$4.h1, _$$3.h2); const graph$27 = Data_SortedMap_updateMap(null, null, vtx$27.h1, vtx$27, _$$3.h4); const st$27 = Data_Graph_MkTState(null, index$27, stack$27, _$$3.h3, graph$27); return Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge_checkRoot(k$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, null, null, null, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge(k$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, null, null, eta, eta1))), st$27, _$$4.h2)); };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$11, _$$12 ) => { const sc$$13 = Data_SortedMap_lookupMap$27(null, null, _$$12, _$$11.h4); switch (sc$$13.tag) { case "Just": switch (sc$$13.h1.h5) { case "False": { const sc$$17 = Prelude_jsEq(null, sc$$13.h1.h3, 0); switch (sc$$17) { case "False": return _$$11; case "True": { const st$27 = Data_Graph_strongConnect(null, _1, _2, _$$11, sc$$13.h1); const sc$$19 = Data_SortedMap_lookupMap$27(null, null, _$$12, st$27.h4); switch (sc$$19.tag) { case "Just": return Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink(_, _1, _2, _3, _4, _5, _6, _7, _8, st$27, _4.h1, sc$$19.h1.h4); default: return st$27; } break; } } break; } case "True": return Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$11, _4.h1, sc$$13.h1.h3); } break; default: return _$$11; } };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11 ) => (Data_Graph_strongConnect_min_splitComp_updateNode(_, _1, _2, _3, _4, _5, _6, _7, _$$9, _$$10, ( vt ) => (Data_Graph_MkTV(null, vt.h1, vt.h2, vt.h3, Data_Graph_strongConnect_min(_, _1, _2, _3, _4, _5, vt.h4, _$$11), vt.h5))));
const Data_Graph_strongConnect_min = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { const sc$$8 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$6, _$$7), "LT"); switch (sc$$8) { case "False": return _$$7; case "True": return _$$6; } };
const Data_Graph_MkTV = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "MkTV",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Data_Graph_strongConnect_min_splitComp_updateNode = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10 ) => { const sc$$16 = Data_SortedMap_lookupMap$27(null, null, _$$9, _$$8.h4); switch (sc$$16.tag) { case "Nothing": return _$$8; case "Just": return Data_Graph_MkTState(null, _$$8.h1, _$$8.h2, _$$8.h3, Data_SortedMap_updateMap(null, null, _$$9, _$$10(sc$$16.h1), _$$8.h4)); } };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack_doEdge_checkRoot = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { const sc$$13 = Data_SortedMap_lookupMap$27(null, null, _4.h1, _$$12.h4); switch (sc$$13.tag) { case "Just": { const sc$$16 = Prelude_jsEq(null, sc$$13.h1.h4, sc$$13.h1.h3); switch (sc$$16) { case "False": return _$$12; case "True": { const sc$$17 = Data_Graph_strongConnect_min_splitComp(_, _1, _2, _3, _4, _5, _6, Prelude_Nil(null), _$$12.h2); const st = Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, eta, eta1))), _$$12, sc$$17.h2); const sc$$23 = Prelude__$7C$7C_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, Prelude_length$27(null, sc$$17.h2), 1), "GT"), Prelude_elem(null, _1, sc$$13.h1.h1, sc$$13.h1.h2)); switch (sc$$23) { case "False": return Data_Graph_MkTState(null, st.h1, sc$$17.h3, st.h3, st.h4); case "True": return Data_Graph_MkTState(null, st.h1, sc$$17.h3, Prelude__$3A$3A_(null, sc$$17.h2, st.h3), st.h4); } break; } } break; } default: return _$$12; } };
const Data_Graph_strongConnect_min_splitComp_updateNode_updateLowLink_offStack = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => (Data_Graph_strongConnect_min_splitComp_updateNode(_, _1, _2, _3, _4, _5, _6, _7, _$$10, _$$11, ( vt ) => (Data_Graph_MkTV(null, vt.h1, vt.h2, vt.h3, vt.h4, "False"))));
const Data_Graph_strongConnect_min_splitComp = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (bouncer(Data_Graph_REC_strongConnect_min_splitComp, { tag: "Data.Graph.strongConnect.min.splitComp",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8 }));
const Data_Graph_REC_strongConnect_min_splitComp = ( arg ) => { switch (arg.h8.tag) { case "_::_": { const sc$$12 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_compare(null, arg.h2)(arg.h8.h1)(arg.h4.h1), "EQ"); switch (sc$$12) { case "False": return { tag: "Data.Graph.strongConnect.min.splitComp",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: Prelude__$3A$3A_(null, arg.h8.h1, arg.h7),  h8: arg.h8.h2 }; case "True": return { tag: "return",  h0: Prelude__$2C_(null, null, Prelude__$3A$3A_(null, arg.h8.h1, arg.h7), arg.h8.h2) }; } break; } case "Nil": return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h7, Prelude_Nil(null)) }; } };
const Data_Graph_tarjan_mkVertex = ( _, _1, _2, _3, _4, _$$5 ) => (Prelude__$2C_(null, null, _$$5.h2, Data_Graph_MkTV(null, _$$5.h2, _$$5.h3, 0, 0, "False")));
const Data_SortedMap_EmptyMap = ( h0, h1, h2 ) => ({ tag: "EmptyMap",  h0: h0,  h1: h1,  h2: h2 });
const Data_SortedMap_foldMap = ( a$$0, b$$1, _$$2, _$$3, _$$4 ) => (bouncer(Data_SortedMap_REC_foldMap, { tag: "Data.SortedMap.foldMap",  h0: a$$0,  h1: b$$1,  h2: _$$2,  h3: _$$3,  h4: _$$4 }));
const Data_SortedMap_REC_foldMap = ( arg ) => { switch (arg.h4.tag) { case "_::_": { const sc$$12 = Data_SortedMap_lookupMap(null, null, arg.h4.h1.h2, arg.h3); switch (sc$$12.tag) { case "Nothing": return { tag: "Data.SortedMap.foldMap",  h0: null,  h1: null,  h2: arg.h2,  h3: Data_SortedMap_updateMap(null, null, arg.h4.h1.h2, arg.h4.h1.h3, arg.h3),  h4: arg.h4.h2 }; case "Just": return { tag: "Data.SortedMap.foldMap",  h0: null,  h1: null,  h2: arg.h2,  h3: Data_SortedMap_updateMap(null, null, arg.h4.h1.h2, arg.h2(sc$$12.h1.h3)(arg.h4.h1.h3), arg.h3),  h4: arg.h4.h2 }; } break; } case "Nil": return { tag: "return",  h0: arg.h3 }; } };
const Data_SortedMap_toList = ( k$$0, v$$1, _$$2 ) => { switch (_$$2.tag) { case "MapOf": return Prelude_reverse(null)(Data_SortedMap_toList_go(k$$0, v$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, _$$2.h3, _$$2.h4, null, null, _$$2.h4, Prelude_Nil(null))); default: return Prelude_Nil(null); } };
const Data_SortedMap_toList_go = ( _, _1, _2, _3, _4, _5, _6, _7, _8, h$$9, _$$10, _$$11 ) => (bouncer(Data_SortedMap_REC_toList_go, { tag: "Data.SortedMap.toList.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: h$$9,  h10: _$$10,  h11: _$$11 }));
const Data_SortedMap_REC_toList_go = ( arg ) => { switch (arg.h10.tag) { case "Node3": return { tag: "Data.SortedMap.toList.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: null,  h10: arg.h10.h7,  h11: Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, null, arg.h10.h5, Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, null, arg.h10.h3, arg.h11)) }; case "Node2": return { tag: "Data.SortedMap.toList.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: null,  h10: arg.h10.h5,  h11: Data_SortedMap_toList_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, null, arg.h10.h3, arg.h11) }; case "Leaf": return { tag: "return",  h0: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h10.h2, arg.h10.h3), arg.h11) }; } };
const Lib_TCO_tailNames = ( _$$0 ) => (bouncer(Lib_TCO_REC_tailNames, { tag: "Lib.TCO.tailNames",  h0: _$$0 }));
const Lib_TCO_REC_tailNames = ( arg ) => { switch (arg.h0.tag) { case "CPrimOp": return { tag: "return",  h0: Prelude_Nil(null) }; case "CRaw": return { tag: "return",  h0: Prelude_Nil(null) }; case "CConstr": return { tag: "return",  h0: Prelude_Nil(null) }; case "CErased": return { tag: "return",  h0: Prelude_Nil(null) }; case "CLetRec": return { tag: "Lib.TCO.tailNames",  h0: arg.h0.h2 }; case "CLet": return { tag: "Lib.TCO.tailNames",  h0: arg.h0.h2 }; case "CLit": return { tag: "return",  h0: Prelude_Nil(null) }; case "CMeta": return { tag: "return",  h0: Prelude_Nil(null) }; case "CRef": return { tag: "return",  h0: Prelude_Nil(null) }; case "CCase": return { tag: "return",  h0: Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_TCO_tailNames_altTailNames(arg.h0, arg.h0.h0, arg.h0.h1, null, eta)), arg.h0.h1), ( _$$1 ) => (_$$1)) }; case "CApp": return { tag: "return",  h0: Prelude_Nil(null) }; case "CAppRef": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h0.h0, Prelude_Nil(null)) }; case "CFun": return { tag: "Lib.TCO.tailNames",  h0: arg.h0.h1 }; case "CLam": return { tag: "return",  h0: Prelude_Nil(null) }; case "CBnd": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_TCO_tailNames_altTailNames = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.tag) { case "CLitAlt": return Lib_TCO_tailNames(_$$4.h1); case "CDefAlt": return Lib_TCO_tailNames(_$$4.h0); case "CConAlt": return Lib_TCO_tailNames(_$$4.h3); } };
const Prelude_Prelude_Monad$20Prelude_List$2Cbind = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$2.tag) { case "_::_": return Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, _$$3(_$$2.h1), Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, _$$2.h2, _$$3)); case "Nil": return Prelude_Nil(null); } };
const Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap = ( a$$0, b$$1, c$$2, d$$3, _$$4, _$$5, _$$6 ) => (Prelude__$2C_(null, null, _$$4(_$$6.h2), _$$5(_$$6.h3)));
const Lib_Ref2_MkRef = ( h0, h1, h2 ) => ({ tag: "MkRef",  h0: h0,  h1: h1,  h2: h2 });
const Lib_CompileExp_defToCExp = ( _$$0, _$$1 ) => { switch (_$$1.h3.tag) { case "PrimFn": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1.h2, Lib_CompileExp_CRaw(_$$1.h3.h0, _$$1.h3.h2))); case "PrimTCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1.h2, Lib_CompileExp_compileDCon(_$$1.h2, "NormalCon", _$$1.h3.h0))); case "Fn": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$2C_(null, null, _$$1.h2, eta)), Lib_CompileExp_compileFun(_$$0, _$$1.h3.h0)); case "DCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1.h2, Lib_CompileExp_compileDCon(_$$1.h2, _$$1.h3.h0, _$$1.h3.h1))); case "TCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1.h2, Lib_CompileExp_compileDCon(_$$1.h2, "NormalCon", _$$1.h3.h0))); case "Axiom": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1.h2, Lib_CompileExp_CErased)); } };
const Lib_CompileExp_CErased = { tag: "CErased" };
const Lib_CompileExp_compileDCon = ( _$$0, _$$1, _$$2 ) => { switch (_$$2) { case 0: switch (_$$1) { case "EnumCon": return Lib_CompileExp_CLit(Lib_Types_LString(_$$0.h1)); default: return Lib_CompileExp_CConstr(_$$0.h1, Prelude_Nil(null)); } break; default: { const args = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( k ) => ((("h") + (Prelude_showInt(k))) + ("")), Lib_Common_range(0, _$$2)); return Lib_CompileExp_CFun(args, Lib_CompileExp_CConstr(_$$0.h1, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( k ) => (Lib_CompileExp_CBnd(((_$$2) - (k)) - (1))), Lib_Common_range(0, _$$2)))); break; } } };
const Lib_Types_LString = ( h0 ) => ({ tag: "LString",  h0: h0 });
const Lib_CompileExp_CLit = ( h0 ) => ({ tag: "CLit",  h0: h0 });
const Lib_CompileExp_compileFun = ( _$$0, _$$1 ) => (Lib_CompileExp_compileFun_go(_$$0, _$$1, null, _$$1, Prelude_Lin(null)));
const Lib_CompileExp_compileFun_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_CompileExp_REC_compileFun_go, { tag: "Lib.CompileExp.compileFun.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_CompileExp_REC_compileFun_go = ( arg ) => { switch (arg.h3.tag) { case "Lam": return { tag: "Lib.CompileExp.compileFun.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h4,  h4: Prelude__$3A$3C_(null, arg.h4, arg.h3.h1) }; default: switch (arg.h4.tag) { case "Lin": return { tag: "return",  h0: Lib_CompileExp_compileTerm(arg.h0, arg.h3) }; default: return { tag: "return",  h0: Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_CompileExp_CFun(Prelude__$3C$3E$3E_(null, arg.h4, Prelude_Nil(null)), eta)), Lib_CompileExp_compileTerm(arg.h0, arg.h3)) }; } break; } };
const Lib_CompileExp_compileTerm = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "Erased": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CErased); case "Lit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLit(_$$1.h1)); case "LetRec": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLetRec(_$$1.h1, t$27, u$27)))))); case "Let": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLet(_$$1.h1, t$27, u$27)))))); case "Case": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$1.h2, ( $$case ) => { switch ($$case.tag) { case "CaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_CompileExp_CLitAlt($$case.h0, eta)), Lib_CompileExp_compileTerm(_$$0, $$case.h1)); case "CaseCons": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_lookupDef(_$$0, Lib_Common_emptyFC, $$case.h0), ( def ) => { switch (def.tag) { case "DCon": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_CompileExp_CConAlt($$case.h0.h1, def.h0, $$case.h1, eta)), Lib_CompileExp_compileTerm(_$$0, $$case.h2)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (("") + ($$case.h0.h1)) + (" is not constructor"))), eta)))); } }))); case "CaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_CompileExp_CDefAlt, Lib_CompileExp_compileTerm(_$$0, $$case.h0)); } }), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CCase(t$27, Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_getBody_doNumCon_fancyCons(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, null, null, null, null, null, null, t$27, alts$27))))))); case "Pi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h4), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, _$$1.h5), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CAppRef(Lib_Common_QN(Lib_Common_primNS, "PiType"), Prelude__$3A$3A_(null, t$27, Prelude__$3A$3A_(null, Lib_CompileExp_CLam(_$$1.h1, u$27), Prelude_Nil(null))), 0)))))); case "UU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CRef(Lib_Common_QN(Prelude_Nil(null), "U"))); case "App": { const sc$$6 = Lib_Util_funArgs(_$$1); switch (sc$$6.h2.tag) { case "Meta": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), (("Compiling an unsolved meta ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$1))) + (""))), eta)))); case "Ref": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_CompileExp_compileTerm(_$$0, eta)), sc$$6.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_arityForName(_$$0, sc$$6.h2.h0, sc$$6.h2.h1), ( arity ) => { const sc$$16 = Lib_CompileExp_compilePrimOp(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$6.h2.h1), args$27); switch (sc$$16.tag) { case "Nothing": { const sc$$18 = Data_SortedMap_lookupMap$27(null, null, sc$$6.h2.h1, defs); switch (sc$$18.tag) { case "Just": switch (sc$$18.h1.tag) { case "DCon": switch (sc$$18.h1.h0) { case "SuccCon": return Lib_CompileExp_compileTerm_applySucc(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, args$27); default: return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, Prelude_Lin(null), arity); } break; default: return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, Prelude_Lin(null), arity); } break; default: return Lib_CompileExp_apply(sc$$6.h2.h1, args$27, Prelude_Lin(null), arity); } break; } case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$16.h1); } }))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("apply other ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$6.h2))), Prelude_Lin(null)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_compileTerm(_$$0, sc$$6.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_CompileExp_compileTerm(_$$0, eta)), sc$$6.h3), ( args$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_CompileExp_CApp(eta, eta1))), t$27, args$27)))))))); } break; } case "Lam": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_CompileExp_CLam(_$$1.h1, eta)), Lib_CompileExp_compileTerm(_$$0, _$$1.h4)); case "Meta": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (("Compiling meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), eta)))); case "Ref": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_CompileExp_arityForName(_$$0, _$$1.h0, _$$1.h1), ( arity ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { switch (arity) { case 0: { const sc$$9 = Data_SortedMap_lookupMap$27(null, null, _$$1.h1, defs); switch (sc$$9.tag) { case "Just": switch (sc$$9.h1.tag) { case "DCon": switch (sc$$9.h1.h0) { case "EnumCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLit(Lib_Types_LString(_$$1.h1.h1))); case "ZeroCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLit(Lib_Types_LInt(0))); case "SuccCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLam("x", Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), Lib_CompileExp_CBnd(0)))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CRef(_$$1.h1)); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CRef(_$$1.h1)); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CRef(_$$1.h1)); } break; } default: { const x = (arity) - (1); switch (x) { case 0: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CRef(_$$1.h1)); default: return Lib_CompileExp_apply(_$$1.h1, Prelude_Nil(null), Prelude_Lin(null), arity); } break; } } }))); case "Bnd": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CBnd(_$$1.h1)); } };
const Lib_CompileExp_apply = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_CompileExp_REC_apply, { tag: "Lib.CompileExp.apply",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_CompileExp_REC_apply = ( arg ) => { switch (arg.h3) { case 0: switch (arg.h2.tag) { case "Lin": return { tag: "return",  h0: Lib_CompileExp_apply_go(arg.h0, arg.h1, arg.h2, arg.h3, null, Lib_CompileExp_CRef(arg.h0), arg.h1) }; default: return { tag: "return",  h0: Lib_CompileExp_apply_go(arg.h0, arg.h1, arg.h2, arg.h3, null, Lib_CompileExp_CAppRef(arg.h0, Prelude__$3C$3E$3E_(null, arg.h2, Prelude_Nil(null)), 0), arg.h1) }; } break; default: { const x = (arg.h3) - (1); switch (arg.h1.tag) { case "_::_": return { tag: "Lib.CompileExp.apply",  h0: arg.h0,  h1: arg.h1.h2,  h2: Prelude__$3A$3C_(null, arg.h2, arg.h1.h1),  h3: x }; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CAppRef(arg.h0, Prelude__$3C$3E$3E_(null, arg.h2, Prelude_Nil(null)), (1) + (Prelude_natToInt(x)))) }; } break; } } };
const Lib_CompileExp_apply_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_CompileExp_REC_apply_go, { tag: "Lib.CompileExp.apply.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_CompileExp_REC_apply_go = ( arg ) => { switch (arg.h6.tag) { case "_::_": return { tag: "Lib.CompileExp.apply.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: Lib_CompileExp_CApp(arg.h5, arg.h6.h1),  h6: arg.h6.h2 }; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, arg.h5) }; } };
const Lib_CompileExp_CApp = ( h0, h1 ) => ({ tag: "CApp",  h0: h0,  h1: h1 });
const Lib_Types_LInt = ( h0 ) => ({ tag: "LInt",  h0: h0 });
const Lib_CompileExp_CPrimOp = ( h0, h1, h2 ) => ({ tag: "CPrimOp",  h0: h0,  h1: h1,  h2: h2 });
const Lib_CompileExp_CLam = ( h0, h1 ) => ({ tag: "CLam",  h0: h0,  h1: h1 });
const Data_IORef_primReadIORef = (_, ref) => (w) => Prelude_MkIORes(null, ref[0], w);
const Lib_CompileExp_arityForName = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$2, defs); switch (sc$$4.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("Name ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2))) + (" not in scope"))), eta)))); case "Just": switch (sc$$4.h1.tag) { case "PrimFn": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$4.h1.h1); case "PrimTCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_intToNat(sc$$4.h1.h0)); case "Fn": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_lamArity(sc$$4.h1.h0)); case "DCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_intToNat(sc$$4.h1.h1)); case "TCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_intToNat(sc$$4.h1.h0)); case "Axiom": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, 0); } break; } }));
const Lib_CompileExp_lamArity = ( _$$0 ) => { switch (_$$0.tag) { case "Lam": return (1) + (Lib_CompileExp_lamArity(_$$0.h4)); default: return 0; } };
const Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$3.h1(tc), ( $$sc ) => { switch ($$sc.tag) { case "Right": return ( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, $$sc.h2.h2, _$$2($$sc.h2.h3))), eta)); case "Left": return ( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, $$sc.h2), eta)); } }, eta)))));
const Lib_Types_pprint$27 = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "Erased": return Lib_Prettier_Text("ERASED"); case "Lit": return Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$2.h1)); case "LetRec": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("letrec"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h3))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("in"))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Nest(2, Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h4))))); case "Let": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("in"))), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_Nest(2, Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h3))))); case "Case": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("case"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("of"))), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Types_pprintAlt(0, _$$1, eta)), _$$2.h2)))))); case "Pi": switch (_$$2.h2) { case "Auto": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("{{"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}}"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h5))))); case "Explicit": switch (_$$2.h3) { case "Many": switch (_$$2.h1) { case "_": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Types_pprint$27(1, _$$1, _$$2.h4), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, "_", _$$1), _$$2.h5)))); default: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h5)))))); } break; default: return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(")"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h5)))))); } break; case "Implicit": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$2.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, _$$1, _$$2.h4))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h5))))); } break; case "UU": return Lib_Prettier_Text("U"); case "App": return Lib_Types_parens(0, _$$0, Lib_Prettier_Seq(Lib_Types_pprint$27(0, _$$1, _$$2.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(1, _$$1, _$$2.h2)))); case "Lam": return Lib_Types_parens(0, _$$0, Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text((((("\\ ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$2.h3))) + ("")) + (_$$2.h1)) + (" =>")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Types_pprint$27(0, Prelude__$3A$3A_(null, _$$2.h1, _$$1), _$$2.h4))))); case "Meta": return Lib_Prettier_Text((("?m:") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h1))) + ("")); case "Ref": return Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h1)); case "Bnd": { const sc$$5 = Prelude_getAt(null, Prelude_intToNat(_$$2.h1), _$$1); switch (sc$$5.tag) { case "Nothing": return Lib_Prettier_Text((("BND:") + (Prelude_showInt(_$$2.h1))) + ("")); case "Just": return Lib_Prettier_Text((((("") + (sc$$5.h1)) + (":")) + (Prelude_showInt(_$$2.h1))) + ("")); } break; } } };
const Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow = ( _$$0 ) => { switch (_$$0) { case "Many": return ""; case "Zero": return "0 "; } };
const Lib_Types_pprintAlt = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "CaseLit": return Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$2.h0)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("=>"), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Types_pprint$27(_$$0, _$$1, _$$2.h1), Lib_Prettier_Text(";"))))))); case "CaseCons": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2.h0)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Prettier_text, _$$2.h1)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("=>"), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Types_pprint$27(_$$0, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude_reverse(null)(_$$2.h1), _$$1), _$$2.h2)))))); case "CaseDefault": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("_"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("=>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Types_pprint$27(_$$0, Prelude__$3A$3A_(null, "_", _$$1), _$$2.h0))); } };
const Lib_Prettier_text = Lib_Prettier_Text;
const Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_ = ( _$$0, _$$1 ) => (Lib_Prettier_Seq(_$$0, Lib_Prettier_Seq(Lib_Prettier_Text(" "), _$$1)));
const Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "LChar": return (("'") + (Prelude_jsShow(null, _$$0.h0))) + ("'"); case "LInt": return Prelude_showInt(_$$0.h0); case "LString": return Lib_Common_quoteString(_$$0.h0); } };
const Prelude_jsShow = (_,a) => ''+a;
const Lib_Types_log = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, top.h6), "GT")), ( _ ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn(_$$1("MkUnit"))))))));
const Prelude_when = ( f$$0, _$$1, _$$2, _$$3 ) => { switch (_$$2) { case "False": return Prelude_return(null, _$$1)(null)("MkUnit"); case "True": return _$$3("MkUnit"); } };
const Lib_Types_getTop = Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, tc, tc)), eta))));
const Lib_CompileExp_compileTerm_applySucc = ( _, _1, _2, _3, _4, _5, _$$6 ) => { switch (_$$6.tag) { case "_::_": switch (_$$6.h2.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), _$$6.h1)); default: return Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("overapplied Succ ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_1))) + (""))), eta)))); } break; case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_CompileExp_CLam("x", Lib_CompileExp_CPrimOp("+", Lib_CompileExp_CLit(Lib_Types_LInt(1)), Lib_CompileExp_CBnd(0)))); } };
const Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "Erased": return "ERASED"; case "Lit": return (("(Lit ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1))) + (")"); case "LetRec": return (((((((("(LetRec ") + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h3))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (")"); case "Let": return (((((("(Let ") + (_$$0.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h3))) + (")"); case "Case": return (((("(Case ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_showCaseAlt, _$$0.h2))))) + (")"); case "Pi": switch (_$$0.h2) { case "Auto": return (((((((("(Pi {{") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + ("}} => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); case "Explicit": return (((((((("(Pi (") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (") => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); case "Implicit": return (((((((("(Pi {") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + ("} => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h5))) + (")"); } break; case "UU": return "U"; case "App": return (((("(") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (")"); case "Lam": return (((((("(\\ ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + ("  => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h4))) + (")"); case "Meta": return (("(Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (")"); case "Ref": return (("(Ref ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (")"); case "Bnd": return (("(Bnd ") + (Prelude_showInt(_$$0.h1))) + (")"); } };
const Lib_Types_showCaseAlt = ( _$$0 ) => { switch (_$$0.tag) { case "CaseLit": return (((("") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h0))) + (" => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (""); case "CaseCons": return (((((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h0))) + (" ")) + (Prelude_joinBy(" ", _$$0.h1))) + (" => ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h2))) + (""); case "CaseDefault": return (("_ => ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h0))) + (""); } };
const Prelude_Prelude_Show$20Prim_String$2Cshow = ( _$$0 ) => (_$$0);
const Lib_CompileExp_compilePrimOp = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "_::_": switch (_$$1.h2.tag) { case "_::_": switch (_$$1.h2.h2.tag) { case "Nil": switch (_$$0) { case "Prelude.addString": return Prelude_Just(null, Lib_CompileExp_CPrimOp("+", _$$1.h1, _$$1.h2.h1)); case "Prelude.addInt": return Prelude_Just(null, Lib_CompileExp_CPrimOp("+", _$$1.h1, _$$1.h2.h1)); case "Prelude.mulInt": return Prelude_Just(null, Lib_CompileExp_CPrimOp("*", _$$1.h1, _$$1.h2.h1)); case "Prelude.subInt": return Prelude_Just(null, Lib_CompileExp_CPrimOp("-", _$$1.h1, _$$1.h2.h1)); case "Prelude.divInt": return Prelude_Just(null, Lib_CompileExp_CPrimOp("|", Lib_CompileExp_CPrimOp("/", _$$1.h1, _$$1.h2.h1), Lib_CompileExp_CLit(Lib_Types_LInt(0)))); default: return Prelude_Nothing(null); } break; default: return Prelude_Nothing(null); } break; default: return Prelude_Nothing(null); } break; default: return Prelude_Nothing(null); } };
const Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case "Erased": return _$$0.h0; case "Lit": return _$$0.h0; case "LetRec": return _$$0.h0; case "Let": return _$$0.h0; case "Case": return _$$0.h0; case "Pi": return _$$0.h0; case "UU": return _$$0.h0; case "App": return _$$0.h0; case "Lam": return _$$0.h0; case "Meta": return _$$0.h0; case "Ref": return _$$0.h0; case "Bnd": return _$$0.h0; } };
const Lib_Util_funArgs = ( _$$0 ) => (Lib_Util_funArgs_go(_$$0, null, _$$0, Prelude_Nil(null)));
const Lib_Util_funArgs_go = ( _, _1, _$$2, _$$3 ) => (bouncer(Lib_Util_REC_funArgs_go, { tag: "Lib.Util.funArgs.go",  h0: _,  h1: _1,  h2: _$$2,  h3: _$$3 }));
const Lib_Util_REC_funArgs_go = ( arg ) => { switch (arg.h2.tag) { case "App": return { tag: "Lib.Util.funArgs.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h1,  h3: Prelude__$3A$3A_(null, arg.h2.h2, arg.h3) }; default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h2, arg.h3) }; } };
const Lib_Common_primNS = Prelude__$3A$3A_(null, "Prim", Prelude_Nil(null));
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_getBody_doNumCon_fancyCons = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12, _$$13 ) => { const sc$$14 = Lib_CompileExp_any(null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP(_, _1, _2, _3, _4, _5, eta)), _$$13); switch (sc$$14) { case "False": return Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt(_, _1, _2, _3, _4, _5, _6, eta)), _$$13); case "True": return Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_getBody_doNumCon(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$12, _$$13); } };
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef_getBody_doNumCon = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _$$11, _$$12 ) => { let zeroAlt; const sc$$13 = Prelude_find(null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo(_, _1, _2, _3, _4, _5, _6, _7, "ZeroCon", eta)), _$$12); switch (sc$$13.tag) { case "Just": switch (sc$$13.h1.tag) { case "CConAlt": { zeroAlt = Prelude__$3A$3A_(null, Lib_CompileExp_CLitAlt(Lib_Types_LInt(0), sc$$13.h1.h3), Prelude_Nil(null)); break; } default: { zeroAlt = Prelude_fatalError(null, (("ERROR zeroAlt mismatch ") + (Prelude_debugStr(null, sc$$13.h1))) + ("")); break; } } break; default: { const sc$$14 = Prelude_find(null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef(_, _1, _2, _3, _4, _5, _6, _7, _8, eta)), _$$12); switch (sc$$14.tag) { case "Just": switch (sc$$14.h1.tag) { case "CDefAlt": { zeroAlt = Prelude__$3A$3A_(null, Lib_CompileExp_CLitAlt(Lib_Types_LInt(0), sc$$14.h1.h0), Prelude_Nil(null)); break; } default: { zeroAlt = Prelude_Nil(null); break; } } break; default: { zeroAlt = Prelude_Nil(null); break; } } break; } } let succAlt; const sc$$14 = Prelude_find(null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo(_, _1, _2, _3, _4, _5, _6, _7, "SuccCon", eta)), _$$12); switch (sc$$14.tag) { case "Just": switch (sc$$14.h1.tag) { case "CConAlt": { succAlt = Prelude__$3A$3A_(null, Lib_CompileExp_CDefAlt(Lib_CompileExp_CLet("x", Lib_CompileExp_CPrimOp("-", _$$11, Lib_CompileExp_CLit(Lib_Types_LInt(1))), sc$$14.h1.h3)), Prelude_Nil(null)); break; } default: { succAlt = Prelude_fatalError(null, (("ERROR succAlt mismatch ") + (Prelude_debugStr(null, sc$$14.h1))) + ("")); break; } } break; default: { const sc$$15 = Prelude_find(null, ( eta ) => (Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef(_, _1, _2, _3, _4, _5, _6, _7, _8, eta)), _$$12); switch (sc$$15.tag) { case "Just": { succAlt = Prelude__$3A$3A_(null, sc$$15.h1, Prelude_Nil(null)); break; } default: { succAlt = Prelude_Nil(null); break; } } break; } } return Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, zeroAlt, succAlt); };
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo_isDef = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9 ) => { switch (_$$9.tag) { case "CDefAlt": return "True"; default: return "False"; } };
const Prelude_find = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC_find, { tag: "Prelude.find",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_find = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$6 = arg.h1(arg.h2.h1); switch (sc$$6) { case "False": return { tag: "Prelude.find",  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; case "True": return { tag: "return",  h0: Prelude_Just(null, arg.h2.h1) }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Prelude_debugStr = (_, obj) => {
  const go = (obj) => {
    if (obj === null) return "_"
    if (typeof obj == 'bigint') return ''+obj
    if (obj.tag === '_,_') {
      let rval = '('
      while (obj?.tag === '_,_') {
        rval += go(obj.h2) + ', '
        obj = obj.h3
      }
      return rval + go(obj) + ')'
    }
    if (obj?.tag === '_::_' || obj?.tag === 'Nil') {
      let stuff = Prelude_listToArray(null,obj)
      return '['+(stuff.map(go).join(', '))+']'
    }
    if (obj instanceof Array) {
      return 'io['+(obj.map(go).join(', '))+']'
    }
    if (obj?.tag === 'S' || obj?.tag === 'Z') {
      return ''+Prelude_natToInt(obj)
    } else if (obj?.tag) {
      let rval = '('+obj.tag
      for(let i=0;;i++) {
        let key = 'h'+i
        if (!(key in obj)) break
        rval += ' ' + go(obj[key])
      }
      return rval+')'
    } else {
      return JSON.stringify(obj)
    }
  }
  return go(obj)
};
const Lib_CompileExp_compileTerm_numAltP_enumAlt_isInfo = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => { switch (_$$9.tag) { case "CConAlt": return Lib_Types_Prelude_Eq$20Lib_Types_ConInfo$2C_$3D$3D_(_$$8, _$$9.h1); default: return "False"; } };
const Lib_Types_Prelude_Eq$20Lib_Types_ConInfo$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case "EnumCon": switch (_$$0) { case "EnumCon": return "True"; default: return "False"; } break; case "ZeroCon": switch (_$$0) { case "ZeroCon": return "True"; default: return "False"; } break; case "SuccCon": switch (_$$0) { case "SuccCon": return "True"; default: return "False"; } break; case "NormalCon": switch (_$$0) { case "NormalCon": return "True"; default: return "False"; } break; } };
const Lib_CompileExp_compileTerm_numAltP_enumAlt = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => { switch (_$$7.tag) { case "CConAlt": switch (_$$7.h1) { case "EnumCon": return Lib_CompileExp_CLitAlt(Lib_Types_LString(_$$7.h0), _$$7.h3); default: return _$$7; } break; default: return _$$7; } };
const Lib_CompileExp_compileTerm_numAltP = ( _, _1, _2, _3, _4, _5, _$$6 ) => { switch (_$$6.tag) { case "CConAlt": switch (_$$6.h1) { case "ZeroCon": return "True"; case "SuccCon": return "True"; default: return "False"; } break; default: return "False"; } };
const Lib_CompileExp_any = ( a$$0, _$$1, _$$2 ) => (bouncer(Lib_CompileExp_REC_any, { tag: "Lib.CompileExp.any",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_CompileExp_REC_any = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$6 = arg.h1(arg.h2.h1); switch (sc$$6) { case "False": return { tag: "Lib.CompileExp.any",  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; case "True": return { tag: "return",  h0: "True" }; } break; } case "Nil": return { tag: "return",  h0: "False" }; } };
const Lib_CompileExp_lookupDef = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _$$0.h2)), ( defs ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$2, defs); switch (sc$$4.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$2))) + (" not in scope"))), eta)))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$4.h1); } }));
const Prelude_MkTraversable = ( h0, h1 ) => ({ tag: "MkTraversable",  h0: h0,  h1: h1 });
const Prelude_Prelude_Traversable$20Prelude_List = Prelude_MkTraversable(null, ( f ) => (( a ) => (( b ) => (( _ ) => (( eta ) => (( eta1 ) => (Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, _, eta, eta1))))))));
const Prelude_for = ( t$$0, f$$1, _$$2, appf$$3, a$$4, b$$5, _$$6, _$$7 ) => (Prelude_traverse(null, _$$2)(null)(null)(null)(appf$$3)(_$$7)(_$$6));
const Prelude_traverse = ( t$$0, _$$1 ) => (( f ) => (( a ) => (( b ) => (( _ ) => (_$$1.h1(null)(null)(null)(_))))));
const Lib_CompileExp_CRaw = ( h0, h1 ) => ({ tag: "CRaw",  h0: h0,  h1: h1 });
const Prelude_mapM = ( m$$0, _$$1, a$$2, b$$3, _$$4, _$$5 ) => { switch (_$$5.tag) { case "_::_": return Prelude_bind(null, _$$1)(null)(null)(_$$4(_$$5.h1))(( b ) => (Prelude_bind(null, _$$1)(null)(null)(Prelude_mapM(null, _$$1, null, null, _$$4, _$$5.h2))(( bs ) => (Prelude_pure(null, _$$1)(null)(Prelude__$3A$3A_(null, b, bs)))))); case "Nil": return Prelude_pure(null, _$$1)(null)(Prelude_Nil(null)); } };
const Lib_LiftWhere_liftWhere = ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _.h2)), ( defs ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$3 ) => ("MkUnit"), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_LiftWhere_liftWhereFn(_, eta)), Data_SortedMap_toList(null, null, defs))))));
const Lib_LiftWhere_liftWhereFn = ( _$$0, _$$1 ) => { switch (_$$1.h3.tag) { case "Fn": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1.h2, Prelude_Nil(null), _$$1.h3.h0), ( tm$27 ) => (Lib_Ref2_modifyRef(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$0, ( eta ) => (Data_SortedMap_updateMap(null, null, _$$1.h2, Lib_Types_Fn(tm$27), eta))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } };
const Lib_Types_Fn = ( h0 ) => ({ tag: "Fn",  h0: h0 });
const Lib_Ref2_Defs = { tag: "Defs" };
const Prelude_MkHasIO = ( h0, h1 ) => ({ tag: "MkHasIO",  h0: h0,  h1: h1 });
const Lib_Types_Prelude_HasIO$20Lib_Types_M = Prelude_MkHasIO(null, ( a ) => (( eta ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, eta))));
const Lib_Ref2_modifyRef = ( io$$0, a$$1, _$$2, l$$3, _$$4, _$$5 ) => (Prelude_liftIO(null, _$$2)(null)(Data_IORef_modifyIORef(null, null, Prelude_Prelude_Monad$20Prelude_IO, Prelude_Prelude_HasIO$20Prelude_IO, _$$4.h2, _$$5)));
const Prelude_liftIO = ( m$$0, _$$1 ) => (( a ) => (_$$1.h1(null)));
const Prelude_Prelude_HasIO$20Prelude_IO = Prelude_MkHasIO(null, ( a ) => (( _$$1 ) => (_$$1)));
const Prelude_Prelude_Monad$20Prelude_IO = Prelude_MkMonad(null, ( a ) => (( b ) => (( eta ) => (( eta1 ) => (( eta2 ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, eta, eta1, eta2)))))), ( a ) => (( eta ) => (( eta1 ) => (Prelude_MkIORes(null, eta, eta1)))));
const Data_IORef_modifyIORef = ( io$$0, a$$1, _$$2, _$$3, _$$4, _$$5 ) => (Prelude_bind(null, _$$2)(null)(null)(Prelude_liftIO(null, _$$3)(null)(Data_IORef_primReadIORef(null, _$$4)))(( a ) => (Prelude_liftIO(null, _$$3)(null)(Data_IORef_primWriteIORef(null, _$$4, _$$5(a))))));
const Data_IORef_primWriteIORef = (_, ref, a) => (w) => {
  ref[0] = a
  return Prelude_MkIORes(null,Prelude_MkUnit,w)
};
const Lib_LiftWhere_liftWhereTm = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "LetRec": { const l = Prelude_length(null, _$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm_getName(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, null, _$$1, _$$3.h1), ( qn ) => { const env$27 = Prelude__$3A$3A_(null, Prelude_Just(null, Prelude__$2C_(null, null, qn, (1) + (l))), _$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, qn, env$27, _$$3.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Ref2_modifyRef(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$0, ( eta ) => (Data_SortedMap_updateMap(null, null, qn, Lib_Types_Fn(Lib_LiftWhere_liftWhereTm_getName_wrapPi_wrapLam(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, null, null, null, (1) + (l), t$27)), eta))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, qn, env$27, _$$3.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_LetRec(_$$3.h0, _$$3.h1, Lib_Types_Erased(_$$3.h0), Lib_Types_Erased(_$$3.h0), u$27)))))))); }); break; } case "Let": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h2), ( v ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(null, Prelude_Nothing(null), _$$2), _$$3.h3), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Let(_$$3.h0, _$$3.h1, v, sc)))))); case "Case": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h1), ( t ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_LiftWhere_liftWhereTm_liftWhereAlt(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, null, eta)), _$$3.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(_$$3.h0, t, alts$27)))))); case "Pi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h4), ( t ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(null, Prelude_Nothing(null), _$$2), _$$3.h5), ( u ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, t, u)))))); case "App": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Types_App(_$$3.h0, eta, eta1))), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h1)), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, _$$2, _$$3.h2)); case "Lam": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta)), Lib_LiftWhere_liftWhereTm(_$$0, _$$1, Prelude__$3A$3A_(null, Prelude_Nothing(null), _$$2), _$$3.h4)); case "Bnd": { const sc$$7 = Prelude_getAt(null, Prelude_intToNat(_$$3.h1), _$$2); switch (sc$$7.tag) { case "Just": switch (sc$$7.h1.tag) { case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_LiftWhere_liftWhereTm_apply(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, null, Prelude_length$27(null, _$$2), Prelude_natToInt(sc$$7.h1.h1.h3), Lib_Types_Ref(_$$3.h0, sc$$7.h1.h1.h2))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$3); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$3); } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$3); } };
const Lib_Types_Ref = ( h0, h1 ) => ({ tag: "Ref",  h0: h0,  h1: h1 });
const Lib_LiftWhere_liftWhereTm_apply = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => { switch (_$$8) { case 0: return _$$9; default: return Lib_Types_App(_4, Lib_LiftWhere_liftWhereTm_apply(_, _1, _2, _3, _4, _5, _6, _$$7, (_$$8) - (1), _$$9), Lib_Types_Bnd(_4, (_$$7) - (_$$8))); } };
const Lib_Types_Bnd = ( h0, h1 ) => ({ tag: "Bnd",  h0: h0,  h1: h1 });
const Lib_Types_App = ( h0, h1, h2 ) => ({ tag: "App",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_Lam = ( h0, h1, h2, h3, h4 ) => ({ tag: "Lam",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_Pi = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "Pi",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Types_Case = ( h0, h1, h2 ) => ({ tag: "Case",  h0: h0,  h1: h1,  h2: h2 });
const Lib_LiftWhere_liftWhereTm_liftWhereAlt = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => { switch (_$$8.tag) { case "CaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseLit(_$$8.h0, eta)), Lib_LiftWhere_liftWhereTm(_, _1, _2, _$$8.h1)); case "CaseCons": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseCons(_$$8.h0, _$$8.h1, eta)), Lib_LiftWhere_liftWhereTm(_, _1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$3 ) => (Prelude_Nothing(null)), _$$8.h1), _2), _$$8.h2)); case "CaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_CaseDefault, Lib_LiftWhere_liftWhereTm(_, _1, _2, _$$8.h0)); } };
const Lib_Types_CaseDefault = ( h0 ) => ({ tag: "CaseDefault",  h0: h0 });
const Lib_Types_CaseCons = ( h0, h1, h2 ) => ({ tag: "CaseCons",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_CaseLit = ( h0, h1 ) => ({ tag: "CaseLit",  h0: h0,  h1: h1 });
const Lib_Types_Let = ( h0, h1, h2, h3 ) => ({ tag: "Let",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_Erased = ( h0 ) => ({ tag: "Erased",  h0: h0 });
const Lib_Types_LetRec = ( h0, h1, h2, h3, h4 ) => ({ tag: "LetRec",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_LiftWhere_liftWhereTm_getName_wrapPi_wrapLam = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12, _$$13 ) => { switch (_$$12) { case 0: return _$$13; default: { const x = (_$$12) - (1); return Lib_Types_Lam(_4, "_", "Explicit", "Many", Lib_LiftWhere_liftWhereTm_getName_wrapPi_wrapLam(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, x, _$$13)); break; } } };
const Lib_LiftWhere_liftWhereTm_getName = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => { const qn$27 = Lib_Common_QN(_$$10.h0, (_$$10.h1) + ((".") + (_$$11))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _.h2)), ( top ) => { const sc$$16 = Data_SortedMap_lookupMap(null, null, qn$27, top); switch (sc$$16.tag) { case "Just": return Lib_LiftWhere_liftWhereTm_getName(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, (_$$11) + ("'")); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, qn$27); } }); };
const Prelude_length = ( a$$0, _$$1 ) => { switch (_$$1.tag) { case "_::_": return (1) + (Prelude_length(null, _$$1.h2)); case "Nil": return 0; } };
const Lib_Compile_eraseEntries_go = ( _, _$$1, _$$2 ) => { switch (_$$2.h3.tag) { case "Fn": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(Prelude_Nil(null), _$$2.h3.h0, Prelude_Nil(null)), ( tm$27 ) => (Lib_Ref2_modifyRef(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M, Lib_Ref2_Defs, _$$1, ( eta ) => (Data_SortedMap_updateMap(null, null, _$$2.h2, Lib_Types_Fn(tm$27), eta))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } };
const Lib_Erasure_erase = ( _$$0, _$$1, _$$2 ) => (bouncer(Lib_Erasure_REC_erase, { tag: "Lib.Erasure.erase",  h0: _$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_Erasure_REC_erase = ( arg ) => { switch (arg.h1.tag) { case "Erased": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h1.h0, "erased value in relevant context")), eta)))) }; case "Lit": return { tag: "return",  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Nothing(null)) }; case "LetRec": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h1, Prelude__$2C_(null, null, "Many", Prelude_Just(null, arg.h1.h2))), arg.h0), arg.h1.h3, Prelude_Nil(null)), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h1, Prelude__$2C_(null, null, "Many", Prelude_Just(null, arg.h1.h2))), arg.h0), arg.h1.h4, Prelude_Nil(null)), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_LetRec(arg.h1.h0, arg.h1.h1, arg.h1.h2, u$27, v$27), arg.h2, Prelude_Nothing(null)))))) }; case "Let": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h1.h2, Prelude_Nil(null)), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h1, Prelude__$2C_(null, null, "Many", Prelude_Nothing(null))), arg.h0), arg.h1.h3, Prelude_Nil(null)), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Let(arg.h1.h0, arg.h1.h1, u$27, v$27), arg.h2, Prelude_Nothing(null)))))) }; case "Case": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h1.h1, Prelude_Nil(null)), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Erasure_doAlt(arg.h0, eta)), arg.h1.h2), ( alts$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Case(arg.h1.h0, u$27, alts$27), arg.h2, Prelude_Nothing(null)))))) }; case "Pi": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h1.h4, Prelude_Nil(null)), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h1, Prelude__$2C_(null, null, "Many", Prelude_Just(null, arg.h1.h4))), arg.h0), arg.h1.h5, Prelude_Nil(null)), ( v$27 ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_Pi(arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h3, u$27, v$27), arg.h2, Prelude_Just(null, Lib_Types_UU(Lib_Common_emptyFC))))))) }; case "UU": return { tag: "return",  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Just(null, Lib_Types_UU(arg.h1.h0))) }; case "App": return { tag: "Lib.Erasure.erase",  h0: arg.h0,  h1: arg.h1.h1,  h2: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h0, arg.h1.h2), arg.h2) }; case "Lam": return { tag: "return",  h0: Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_Lam(arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h3, eta)), Lib_Erasure_erase(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h1.h1, Prelude__$2C_(null, null, arg.h1.h3, Prelude_Nothing(null))), arg.h0), arg.h1.h4, Prelude_Nil(null))) }; case "Meta": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, arg.h1) }; case "Ref": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$7 = Lib_TopContext_lookup(arg.h1.h1, top); switch (sc$$7.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h1.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h1.h1))) + (" not in scope"))), eta)))); case "Just": return Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, Prelude_Just(null, sc$$7.h1.h2)); } }) }; case "Bnd": { const sc$$6 = Prelude_getAt(null, Prelude_intToNat(arg.h1.h1), arg.h0); switch (sc$$6.tag) { case "Nothing": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h1.h0, (("bad index ") + (Prelude_showInt(arg.h1.h1))) + (""))), eta)))) }; case "Just": switch (sc$$6.h1.h3.h2) { case "Many": return { tag: "return",  h0: Lib_Erasure_eraseSpine(arg.h0, arg.h1, arg.h2, sc$$6.h1.h3.h3) }; case "Zero": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h1.h0, (("used erased value ") + (sc$$6.h1.h2)) + (" (FIXME FC may be wrong here)"))), eta)))) }; } break; } break; } } };
const Lib_Erasure_eraseSpine = ( _$$0, _$$1, _$$2, ty$$3 ) => (bouncer(Lib_Erasure_REC_eraseSpine, { tag: "Lib.Erasure.eraseSpine",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: ty$$3 }));
const Lib_Erasure_REC_eraseSpine = ( arg ) => { switch (arg.h2.tag) { case "_::_": switch (arg.h3.tag) { case "Just": switch (arg.h3.h1.tag) { case "Pi": switch (arg.h3.h1.h3) { case "Many": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil(null)), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Just(null, arg.h3.h1.h5)))) }; case "Zero": { const u = Lib_Types_Erased(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h2.h1.h3)); return { tag: "Lib.Erasure.eraseSpine",  h0: arg.h0,  h1: Lib_Types_App(arg.h2.h1.h2, arg.h1, u),  h2: arg.h2.h2,  h3: Prelude_Just(null, arg.h3.h1.h5) }; break; } } break; default: return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil(null)), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Nothing(null)))) }; } break; default: return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Erasure_erase(arg.h0, arg.h2.h1.h3, Prelude_Nil(null)), ( u ) => (Lib_Erasure_eraseSpine(arg.h0, Lib_Types_App(arg.h2.h1.h2, arg.h1, u), arg.h2.h2, Prelude_Nothing(null)))) }; } break; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, arg.h1) }; } };
const Lib_TopContext_lookup = ( _$$0, _$$1 ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$0, _$$1.h4); switch (sc$$4.tag) { case "Nothing": { const sc$$6 = Data_SortedMap_lookupMap$27(null, null, _$$0.h0, _$$1.h0); switch (sc$$6.tag) { case "Nothing": return Prelude_Nothing(null); case "Just": return Data_SortedMap_lookupMap$27(null, null, _$$0, sc$$6.h1.h1); } break; } case "Just": return Prelude_Just(null, sc$$4.h1); } };
const Lib_Types_UU = ( h0 ) => ({ tag: "UU",  h0: h0 });
const Lib_Erasure_doAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "CaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseLit(_$$1.h0, eta)), Lib_Erasure_erase(_$$0, _$$1.h1, Prelude_Nil(null))); case "CaseCons": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$7 = Lib_TopContext_lookup(_$$1.h0, top); switch (sc$$7.tag) { case "Just": { const env$27 = Lib_Erasure_doAlt_piEnv(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$0, sc$$7.h1.h2, _$$1.h1); return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseCons(_$$1.h0, _$$1.h1, eta)), Lib_Erasure_erase(env$27, _$$1.h2, Prelude_Nil(null))); break; } default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h0))) + (" dcon missing from context"))), eta)))); } }); case "CaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_CaseDefault, Lib_Erasure_erase(_$$0, _$$1.h0, Prelude_Nil(null))); } };
const Lib_Erasure_doAlt_piEnv = ( _, _1, _2, _3, _4, _5, _$$6, _$$7, _$$8 ) => (bouncer(Lib_Erasure_REC_doAlt_piEnv, { tag: "Lib.Erasure.doAlt.piEnv",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7,  h8: _$$8 }));
const Lib_Erasure_REC_doAlt_piEnv = ( arg ) => { switch (arg.h8.tag) { case "_::_": switch (arg.h7.tag) { case "Pi": return { tag: "Lib.Erasure.doAlt.piEnv",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h8.h1, Prelude__$2C_(null, null, arg.h7.h3, Prelude_Just(null, arg.h7.h4))), arg.h6),  h7: arg.h7.h5,  h8: arg.h8.h2 }; default: return { tag: "return",  h0: arg.h6 }; } break; default: return { tag: "return",  h0: arg.h6 }; } };
const Lib_Compile_eraseEntries = ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, _.h2)), ( defs ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$3 ) => ("MkUnit"), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Compile_eraseEntries_go(null, _, eta)), Data_SortedMap_toList(null, null, defs))))));
const Data_IORef_primNewIORef = (_, a) => (w) => Prelude_MkIORes(null, [a], w);
const Lib_Compile_getEntries = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookup(_$$1, top); switch (sc$$3.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("bad name ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$0))); case "Just": switch (sc$$3.h1.h3.tag) { case "PrimFn": { const acc = Data_SortedMap_updateMap(null, null, sc$$3.h1.h1, sc$$3.h1.h3, _$$0); return Prelude_foldlM(null, null, null, Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Compile_getEntries(eta, eta1))), acc, sc$$3.h1.h3.h2); break; } case "Fn": { const sc$$12 = Data_SortedMap_lookupMap$27(null, null, sc$$3.h1.h1, _$$0); switch (sc$$12.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_zonk(top1, 0, Prelude_Nil(null), sc$$3.h1.h3.h0), ( exp ) => { const acc = Data_SortedMap_updateMap(null, null, sc$$3.h1.h1, Lib_Types_Fn(exp), _$$0); return Prelude_foldlM(null, null, null, Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Compile_getEntries(eta, eta1))), acc, Lib_Compile_getNames(exp, Prelude_Nil(null))); }))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$0); } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Data_SortedMap_updateMap(null, null, _$$1, sc$$3.h1.h3, _$$0)); } break; } }));
const Lib_Compile_getNames = ( _$$0, _$$1 ) => (bouncer(Lib_Compile_REC_getNames, { tag: "Lib.Compile.getNames",  h0: _$$0,  h1: _$$1 }));
const Lib_Compile_REC_getNames = ( arg ) => { switch (arg.h0.tag) { case "LetRec": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h4,  h1: Lib_Compile_getNames(arg.h0.h3, arg.h1) }; case "Let": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h3,  h1: Lib_Compile_getNames(arg.h0.h2, arg.h1) }; case "Case": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h1,  h1: Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Compile_getNames_getAltNames(arg.h0, arg.h1, arg.h0.h0, arg.h0.h1, arg.h0.h2, null, eta, eta1))), arg.h1, arg.h0.h2) }; case "Pi": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h5,  h1: Lib_Compile_getNames(arg.h0.h4, Prelude__$3A$3A_(null, Lib_Common_QN(Lib_Common_primNS, "PiType"), arg.h1)) }; case "App": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h2,  h1: Lib_Compile_getNames(arg.h0.h1, arg.h1) }; case "Lam": return { tag: "Lib.Compile.getNames",  h0: arg.h0.h4,  h1: arg.h1 }; case "Ref": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h0.h1, arg.h1) }; default: return { tag: "return",  h0: arg.h1 }; } };
const Lib_Compile_getNames_getAltNames = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case "CaseLit": return Lib_Compile_getNames(_$$7.h1, _$$6); case "CaseCons": return Prelude__$3A$3A_(null, _$$7.h0, Lib_Compile_getNames(_$$7.h2, _$$6)); case "CaseDefault": return Lib_Compile_getNames(_$$7.h0, _$$6); } };
const Lib_Eval_zonk = ( _$$0, _$$1, _$$2, _$$3 ) => { const env$27 = Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, _$$1, Prelude_Lin(null)), _$$2); switch (_$$3.tag) { case "Erased": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Erased(_$$3.h0)); case "Lit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lit(_$$3.h0, _$$3.h1)); case "LetRec": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Types_LetRec(_$$3.h0, _$$3.h1, eta, eta1, eta2)))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h3)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h4)); case "Let": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Types_Let(_$$3.h0, _$$3.h1, eta, eta1))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h3)); case "Case": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_zonkAlt(_$$0, _$$1, _$$2, eta)), _$$3.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(_$$3.h0, sc$27, alts$27)))))); case "Pi": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta, eta1))), Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h4)), Lib_Eval_zonkBind(_$$0, (_$$1) + (1), env$27, _$$3.h5)); case "UU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_UU(_$$3.h0)); case "App": return Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3, Prelude_Nil(null)); case "Lam": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, eta)), Lib_Eval_zonk(_$$0, (1) + (_$$1), env$27, _$$3.h4)); case "Meta": return Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3, Prelude_Nil(null)); case "Ref": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Ref(_$$3.h0, _$$3.h1)); case "Bnd": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Bnd(_$$3.h0, _$$3.h1)); } };
const Lib_Eval_zonkApp = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { switch (_$$3.tag) { case "App": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3.h2), ( u$27 ) => (Lib_Eval_zonkApp(_$$0, _$$1, _$$2, _$$3.h1, Prelude__$3A$3A_(null, u$27, _$$4)))); case "Meta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$3.h1), ( meta ) => { switch (meta.tag) { case "Solved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(_$$2, eta)), _$$4), ( sp$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("zonk ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(meta.h2))) + (" spine ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, sp$27)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(meta.h2, Prelude__$3C$3E$3C_(null, Prelude_Lin(null), sp$27)), ( foo ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("-> result is ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(foo))) + (""))), ( _1 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Eval_tweakFC(_$$3.h0, eta)), Lib_Eval_quote(_$$1, foo)))))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Eval_appSpine(_$$3, _$$4)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_zonk(_$$0, _$$1, _$$2, _$$3), ( t$27 ) => { const sc$$7 = Lib_Eval_zonkApp_inlineDef(_$$0, _$$1, _$$2, _$$3, _$$4, null, t$27); switch (sc$$7.tag) { case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(_$$2, eta)), _$$4), ( sp$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$2, sc$$7.h1), ( vtm ) => (Lib_Types_catchError(null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(vtm, Prelude__$3C$3E$3C_(null, Prelude_Lin(null), sp$27)), ( foo ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$1, foo), ( t$271 ) => (Lib_Eval_zonk(_$$0, _$$1, _$$2, t$271))))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Eval_appSpine(t$27, _$$4)))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Eval_appSpine(t$27, _$$4)); } }); } };
const Lib_Eval_appSpine = ( _$$0, _$$1 ) => (bouncer(Lib_Eval_REC_appSpine, { tag: "Lib.Eval.appSpine",  h0: _$$0,  h1: _$$1 }));
const Lib_Eval_REC_appSpine = ( arg ) => { switch (arg.h1.tag) { case "_::_": return { tag: "Lib.Eval.appSpine",  h0: Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h0), arg.h0, arg.h1.h1),  h1: arg.h1.h2 }; case "Nil": return { tag: "return",  h0: arg.h0 }; } };
const Lib_Eval_quote = ( lvl$$0, _$$1 ) => { switch (_$$1.tag) { case "VLit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lit(_$$1.h0, _$$1.h1)); case "VErased": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Erased(_$$1.h0)); case "VU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_UU(_$$1.h0)); case "VLetRec": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(lvl$$0, _$$1.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (lvl$$0), _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (lvl$$0), _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_LetRec(_$$1.h0, _$$1.h1, ty$27, t$27, u$27)))))))); case "VLet": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(lvl$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (lvl$$0), _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Let(_$$1.h0, _$$1.h1, t$27, u$27)))))); case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(lvl$$0, _$$1.h4), ( a$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, lvl$$0, Prelude_Lin(null)), _$$1.h5.h0), _$$1.h5.h1), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (lvl$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Pi(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, a$27, tm)))))))); case "VLam": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, lvl$$0, Prelude_Lin(null)), _$$1.h4.h0), _$$1.h4.h1), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (lvl$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, tm)))))); case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$1.h1), ( meta ) => { switch (meta.tag) { case "Solved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(meta.h2, _$$1.h2), ( eta ) => (Lib_Eval_quote(lvl$$0, eta))); default: return Lib_Eval_quoteSp(lvl$$0, Lib_Types_Meta(_$$1.h0, _$$1.h1), _$$1.h2); } }); case "VCase": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(lvl$$0, _$$1.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_quoteAlt(lvl$$0, eta)), _$$1.h2), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(_$$1.h0, sc$27, alts)))))); case "VRef": return Lib_Eval_quoteSp(lvl$$0, Lib_Types_Ref(_$$1.h0, _$$1.h1), _$$1.h2); case "VVar": { const sc$$5 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$1.h1, lvl$$0), "LT"); switch (sc$$5) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (((("Bad index in quote ") + (Prelude_showInt(_$$1.h1))) + (" depth ")) + (Prelude_showInt(lvl$$0))) + (""))), eta)))); case "True": return Lib_Eval_quoteSp(lvl$$0, Lib_Types_Bnd(_$$1.h0, ((lvl$$0) - (_$$1.h1)) - (1)), _$$1.h2); } break; } } };
const Lib_Eval_quoteSp = ( lvl$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "_:<_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quoteSp(lvl$$0, _$$1, _$$2.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(lvl$$0, _$$2.h2), ( x$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_App(Lib_Common_emptyFC, t$27, x$27)))))); case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1); } };
const Lib_Eval_quoteAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "VCaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_CaseDefault, Lib_Eval_quote(_$$0, _$$1.h0)); case "VCaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseLit(_$$1.h0, eta)), Lib_Eval_quote(_$$0, _$$1.h1)); case "VCaseCons": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Lib_Eval_quoteAlt_mkenv(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, null, _$$0, _$$1.h2, _$$1.h1), _$$1.h3), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((Prelude_length$27(null, _$$1.h1)) + (_$$0), val), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_CaseCons(_$$1.h0, _$$1.h1, tm)))))); } };
const Lib_Eval_quoteAlt_mkenv = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_Eval_REC_quoteAlt_mkenv, { tag: "Lib.Eval.quoteAlt.mkenv",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_Eval_REC_quoteAlt_mkenv = ( arg ) => { switch (arg.h9.tag) { case "_::_": return { tag: "Lib.Eval.quoteAlt.mkenv",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: (arg.h7) + (1),  h8: Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, arg.h7, Prelude_Lin(null)), arg.h8),  h9: arg.h9.h2 }; case "Nil": return { tag: "return",  h0: arg.h8 }; } };
const Lib_Types_VVar = ( h0, h1, h2 ) => ({ tag: "VVar",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Eval_eval = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "Erased": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VErased(_$$1.h0)); case "Lit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VLit(_$$1.h0, _$$1.h1)); case "LetRec": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$1.h0, Prelude_length$27(null, _$$0), Prelude_Lin(null)), _$$0), _$$1.h3), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$1.h0, Prelude_length$27(null, _$$0), Prelude_Lin(null)), _$$0), _$$1.h4), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VLetRec(_$$1.h0, _$$1.h1, ty$27, t$27, u$27)))))))); case "Let": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h2), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$1.h0, Prelude_length$27(null, _$$0), Prelude_Lin(null)), _$$0), _$$1.h3), ( u$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VLet(_$$1.h0, _$$1.h1, t$27, u$27)))))); case "Case": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h1), ( sc$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_unlet(_$$0, sc$27), ( sc$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_forceType(_$$0, sc$271), ( sc$272 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_evalCase(_$$0, sc$272, _$$1.h2), ( $$sc ) => { switch ($$sc.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h1), ( vsc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_evalAlt(_$$0, eta)), _$$1.h2), ( alts$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VCase(_$$1.h0, vsc, alts$27)))))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc.h1); } }))))))); case "Pi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h4), ( a$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VPi(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, a$27, Lib_Types_MkClosure(_$$0, _$$1.h5))))); case "UU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VU(_$$1.h0)); case "App": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h1), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, _$$1.h2), ( u$27 ) => (Lib_Eval_vapp(t$27, u$27))))); case "Lam": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VLam(_$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, Lib_Types_MkClosure(_$$0, _$$1.h4))); case "Meta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$1.h1), ( meta ) => { switch (meta.tag) { case "Solved": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, meta.h2); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VMeta(_$$1.h0, _$$1.h1, Prelude_Lin(null))); } }); case "Ref": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VRef(_$$1.h0, _$$1.h1, Prelude_Lin(null))); case "Bnd": { const sc$$4 = Prelude_getAt(null, Prelude_intToNat(_$$1.h1), _$$0); switch (sc$$4.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (("Bad deBruin index ") + (Prelude_showInt(_$$1.h1))) + (""))), eta)))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$4.h1); } break; } } };
const Lib_Types_VRef = ( h0, h1, h2 ) => ({ tag: "VRef",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_VMeta = ( h0, h1, h2 ) => ({ tag: "VMeta",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Types_lookupMeta = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$0, top.h5.h0); switch (sc$$4.tag) { case "Nothing": { const sc$$6 = Data_SortedMap_lookupMap$27(null, null, _$$0.h0, top.h0); switch (sc$$6.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("missing module: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$0.h0)))) + (""))), eta)))); case "Just": { const sc$$9 = Data_SortedMap_lookupMap$27(null, null, _$$0, sc$$6.h1.h2.h0); switch (sc$$9.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("missing meta: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (""))), eta)))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$9.h1); } break; } } break; } case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$4.h1); } }));
const Lib_Types_MkClosure = ( h0, h1 ) => ({ tag: "MkClosure",  h0: h0,  h1: h1 });
const Lib_Types_VLam = ( h0, h1, h2, h3, h4 ) => ({ tag: "VLam",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Eval_vapp = ( _$$0, _$$1 ) => { switch (_$$0.tag) { case "VLam": return Lib_Eval_eval(Prelude__$3A$3A_(null, _$$1, _$$0.h4.h0), _$$0.h4.h1); case "VMeta": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VMeta(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(null, _$$0.h2, _$$1))); case "VRef": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VRef(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(null, _$$0.h2, _$$1))); case "VVar": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VVar(_$$0.h0, _$$0.h1, Prelude__$3A$3C_(null, _$$0.h2, _$$1))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (((("impossible in vapp ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0))) + (" to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + ("\n"))), eta)))); } };
const Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "VLit": return Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1); case "VErased": return "ERASED"; case "VU": return "U"; case "VLetRec": return (((((((("(%letrec ") + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (" = ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (" in ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + (""); case "VLet": return (((((("(%let ") + (_$$0.h1)) + (" = ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (" in ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (""); case "VPi": switch (_$$0.h2) { case "Auto": return (((((((("(%pi {{") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("}}. ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); case "Explicit": return (((((((("(%pi (") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("). ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); case "Implicit": return (((((((("(%pi {") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + (" ")) + (_$$0.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h4))) + ("}. ")) + (Lib_Types_showClosure(_$$0.h5))) + (")"); } break; case "VLam": return (((((("(%lam ") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" ")) + (Lib_Types_showClosure(_$$0.h4))) + (")"); case "VMeta": return (((("(%meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" [")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(null, _$$0.h2))))) + (" sp])"); case "VCase": return (((("(%case ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow_showAlt(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, eta)), _$$0.h2)))) + (")"); case "VRef": switch (_$$0.h2.tag) { case "Lin": return Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1); default: return (((("(") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$0.h2, Prelude_Nil(null)))))) + (")"); } break; case "VVar": switch (_$$0.h2.tag) { case "Lin": return (("%var") + (Prelude_showInt(_$$0.h1))) + (""); default: return (((("(%var") + (Prelude_showInt(_$$0.h1))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$0.h2, Prelude_Nil(null)))))) + (")"); } break; } };
const Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow_showAlt = ( _, _1, _2, _3, _4, _$$5 ) => { switch (_$$5.tag) { case "VCaseDefault": return (("(%cdef ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5.h0))) + (")"); case "VCaseLit": return (("(%clit ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5.h1))) + (")"); case "VCaseCons": return (((((((("(%ccon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$5.h0))) + (" ")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$5.h1)))) + (" [")) + (Prelude_showInt(Prelude_natToInt(Prelude_length(null, _$$5.h2))))) + (" env] ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$5.h3))) + (""); } };
const Data_SnocList_snoclen = ( a$$0, _$$1 ) => (Data_SnocList_snoclen_go(a$$0, _$$1, null, _$$1, 0));
const Data_SnocList_snoclen_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Data_SnocList_REC_snoclen_go, { tag: "Data.SnocList.snoclen.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Data_SnocList_REC_snoclen_go = ( arg ) => { switch (arg.h3.tag) { case "_:<_": return { tag: "Data.SnocList.snoclen.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1,  h4: (1) + (arg.h4) }; case "Lin": return { tag: "return",  h0: arg.h4 }; } };
const Lib_Types_showClosure = ( _$$0 ) => ((((("(%cl [") + (Prelude_showInt(Prelude_natToInt(Prelude_length(null, _$$0.h0))))) + (" env] ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h1))) + (")"));
const Lib_Types_VU = ( h0 ) => ({ tag: "VU",  h0: h0 });
const Lib_Types_VPi = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "VPi",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Types_VCase = ( h0, h1, h2 ) => ({ tag: "VCase",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Eval_evalAlt = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "CaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_VCaseLit(_$$1.h0, eta)), Lib_Eval_eval(_$$0, _$$1.h1)); case "CaseCons": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VCaseCons(_$$1.h0, _$$1.h1, _$$0, _$$1.h2)); case "CaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_VCaseDefault, Lib_Eval_eval(_$$0, _$$1.h0)); } };
const Lib_Types_VCaseDefault = ( h0 ) => ({ tag: "VCaseDefault",  h0: h0 });
const Lib_Types_VCaseCons = ( h0, h1, h2, h3 ) => ({ tag: "VCaseCons",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_VCaseLit = ( h0, h1 ) => ({ tag: "VCaseLit",  h0: h0,  h1: h1 });
const Lib_Eval_evalCase = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "_::_": switch (_$$2.h1.tag) { case "CaseCons": switch (_$$1.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$14 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$1.h1, _$$2.h1.h0); switch (sc$$14) { case "False": { const sc$$15 = Lib_TopContext_lookup(_$$1.h1, top); switch (sc$$15.tag) { case "Just": switch (sc$$15.h1.h3.tag) { case "DCon": return Lib_Eval_evalCase(_$$0, _$$1, _$$2.h2); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } break; } case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((((("ECase ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$1.h2, Prelude_Nil(null)))))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$2.h1.h1)))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$2.h1.h2))) + (""))), ( _ ) => (Lib_Eval_evalCase_pushArgs(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, _$$2.h1.h0, _$$2.h1.h1, _$$2.h1.h2, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$0, Prelude__$3C$3E$3E_(null, _$$1.h2, Prelude_Nil(null)), _$$2.h1.h1))); } }); case "VVar": { const sc$$12 = Lib_Eval_lookupVar(_$$0, _$$1.h1); switch (sc$$12.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); case "Just": switch (sc$$12.h1.tag) { case "VVar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$12.h1))) + (""))), ( _ ) => { const sc$$19 = Prelude_jsEq(null, sc$$12.h1.h1, _$$1.h1); switch (sc$$19) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(Lib_Types_VVar(sc$$12.h1.h0, sc$$12.h1.h1, sc$$12.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(sc$$12.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } break; } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))))); } break; case "CaseDefault": switch (_$$1.tag) { case "VVar": { const sc$$10 = Lib_Eval_lookupVar(_$$0, _$$1.h1); switch (sc$$10.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); case "Just": switch (sc$$10.h1.tag) { case "VVar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$10.h1))) + (""))), ( _ ) => { const sc$$17 = Prelude_jsEq(null, sc$$10.h1.h1, _$$1.h1); switch (sc$$17) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(Lib_Types_VVar(sc$$10.h1.h0, sc$$10.h1.h1, sc$$10.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(sc$$10.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } break; } break; } default: return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_Just(null, eta)), Lib_Eval_eval(_$$0, _$$2.h1.h0)); } break; default: switch (_$$1.tag) { case "VVar": { const sc$$9 = Lib_Eval_lookupVar(_$$0, _$$1.h1); switch (sc$$9.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); case "Just": switch (sc$$9.h1.tag) { case "VVar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$9.h1))) + (""))), ( _ ) => { const sc$$16 = Prelude_jsEq(null, sc$$9.h1.h1, _$$1.h1); switch (sc$$16) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(Lib_Types_VVar(sc$$9.h1.h0, sc$$9.h1.h1, sc$$9.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(sc$$9.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } break; } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))))); } break; } break; default: switch (_$$1.tag) { case "VVar": { const sc$$6 = Lib_Eval_lookupVar(_$$0, _$$1.h1); switch (sc$$6.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); case "Just": switch (sc$$6.h1.tag) { case "VVar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$6.h1))) + (""))), ( _ ) => { const sc$$13 = Prelude_jsEq(null, sc$$6.h1.h1, _$$1.h1); switch (sc$$13) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(Lib_Types_VVar(sc$$6.h1.h0, sc$$6.h1.h1, sc$$6.h1.h2), _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(sc$$6.h1, _$$1.h2), ( val ) => (Lib_Eval_evalCase(_$$0, val, _$$2))); } break; } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("CASE BAIL sc ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$1))) + (" vs "))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("env is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))))); } break; } };
const Lib_Eval_vappSpine = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "_:<_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(_$$0, _$$1.h1), ( rest ) => (Lib_Eval_vapp(rest, _$$1.h2))); case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$0); } };
const Lib_Eval_lookupVar = ( _$$0, _$$1 ) => { const l = Prelude_natToInt(Prelude_length(null, _$$0)); const sc$$3 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$1, l), "GT"); switch (sc$$3) { case "False": { const sc$$4 = Prelude_getAt(null, Prelude_intToNat(((l) - (_$$1)) - (1)), _$$0); switch (sc$$4.tag) { case "Nothing": return Prelude_Nothing(null); case "Just": switch (sc$$4.h1.tag) { case "VVar": { const sc$$10 = Prelude_jsEq(null, _$$1, sc$$4.h1.h1); switch (sc$$10) { case "False": return Prelude_Just(null, sc$$4.h1); case "True": return Prelude_Nothing(null); } break; } default: return Prelude_Just(null, sc$$4.h1); } break; } break; } case "True": return Prelude_Nothing(null); } };
const Lib_Eval_evalCase_pushArgs = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _$$13, _$$14, _$$15 ) => (bouncer(Lib_Eval_REC_evalCase_pushArgs, { tag: "Lib.Eval.evalCase.pushArgs",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: _9,  h10: _10,  h11: _11,  h12: _12,  h13: _$$13,  h14: _$$14,  h15: _$$15 }));
const Lib_Eval_REC_evalCase_pushArgs = ( arg ) => { switch (arg.h15.tag) { case "_::_": switch (arg.h14.tag) { case "_::_": return { tag: "Lib.Eval.evalCase.pushArgs",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: arg.h12,  h13: Prelude__$3A$3A_(null, arg.h14.h1, arg.h13),  h14: arg.h14.h2,  h15: arg.h15.h2 }; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)) }; } break; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(arg.h13, arg.h8), ( t$27 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_Just(null, eta)), Lib_Eval_vappSpine(t$27, Prelude__$3C$3E$3C_(null, Prelude_Lin(null), arg.h14))))) }; } };
const Prelude__$3C$3E$3C_ = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC__$3C$3E$3C_, { tag: "Prelude._<><_",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC__$3C$3E$3C_ = ( arg ) => { switch (arg.h2.tag) { case "_::_": return { tag: "Prelude._<><_",  h0: null,  h1: Prelude__$3A$3C_(null, arg.h1, arg.h2.h1),  h2: arg.h2.h2 }; case "Nil": return { tag: "return",  h0: arg.h1 }; } };
const Lib_Eval_forceType = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$1.h1), ( meta ) => { switch (meta.tag) { case "Solved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(meta.h2, _$$1.h2), ( eta ) => (Lib_Eval_forceType(_$$0, eta))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VMeta(_$$1.h0, _$$1.h1, _$$1.h2)); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_tryEval(_$$0, _$$1), ( $$sc ) => { switch ($$sc.tag) { case "Just": return Lib_Eval_forceType(_$$0, $$sc.h1); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1); } }); } };
const Lib_Eval_tryEval = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$6 = Lib_TopContext_lookup(_$$1.h1, top); switch (sc$$6.tag) { case "Just": switch (sc$$6.h1.h3.tag) { case "Fn": return Lib_Types_catchError(null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("app ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$6.h1.h1))) + (" to ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$1.h2, Prelude_Nil(null)))))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, sc$$6.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("tm is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$6.h1.h3.h0))), Prelude_Lin(null)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(vtm, _$$1.h2), ( val ) => { switch (val.tag) { case "VLetRec": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); case "VLam": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); case "VCase": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, val)); } }))))))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("tryEval blocked on undefined ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); } break; default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("tryEval blocked on undefined ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } };
const Lib_Types_catchError = ( a$$0, _$$1, _$$2 ) => (Lib_Types_MkM(null, ( tc ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, _$$1.h1(tc), ( $$sc ) => { switch ($$sc.tag) { case "Right": return ( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, $$sc.h2.h2, $$sc.h2.h3)), eta)); case "Left": return Lib_Types__runM(null, _$$2($$sc.h2))(tc); } }, eta)))));
const Lib_Eval_unlet = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "VVar": { const sc$$5 = Lib_Eval_lookupVar(_$$0, _$$1.h1); switch (sc$$5.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is Nothing in env ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1))); case "Just": switch (sc$$5.h1.tag) { case "VVar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Prelude_showInt(_$$1.h1))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$5.h1))) + (""))), ( _ ) => { const sc$$12 = Prelude_jsEq(null, sc$$5.h1.h1, _$$1.h1); switch (sc$$12) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(Lib_Types_VVar(sc$$5.h1.h0, sc$$5.h1.h1, sc$$5.h1.h2), _$$1.h2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(sc$$5.h1, _$$1.h2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))); } break; } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1); } };
const Lib_Types_VLet = ( h0, h1, h2, h3 ) => ({ tag: "VLet",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_VLetRec = ( h0, h1, h2, h3, h4 ) => ({ tag: "VLetRec",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_VLit = ( h0, h1 ) => ({ tag: "VLit",  h0: h0,  h1: h1 });
const Lib_Types_VErased = ( h0 ) => ({ tag: "VErased",  h0: h0 });
const Lib_Types_Meta = ( h0, h1 ) => ({ tag: "Meta",  h0: h0,  h1: h1 });
const Lib_Types_Lit = ( h0, h1 ) => ({ tag: "Lit",  h0: h0,  h1: h1 });
const Lib_Eval_zonkApp_inlineDef = ( _, _1, _2, _3, _4, _5, _$$6 ) => { switch (_$$6.tag) { case "Ref": { const sc$$9 = Lib_TopContext_lookup(_$$6.h1, _); switch (sc$$9.tag) { case "Just": switch (sc$$9.h1.h3.tag) { case "Fn": { const sc$$18 = Prelude_elem(null, Lib_Types_Prelude_Eq$20Lib_Types_EFlag, "Inline", sc$$9.h1.h4); switch (sc$$18) { case "False": return Prelude_Nothing(null); case "True": return Prelude_Just(null, sc$$9.h1.h3.h0); } break; } default: return Prelude_Nothing(null); } break; default: return Prelude_Nothing(null); } break; } default: return Prelude_Nothing(null); } };
const Lib_Types_Prelude_Eq$20Lib_Types_EFlag$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case "Inline": switch (_$$0) { case "Inline": return "True"; default: return "False"; } break; case "Hint": switch (_$$0) { case "Hint": return "True"; default: return "False"; } break; } };
const Lib_Types_Prelude_Eq$20Lib_Types_EFlag = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Lib_Types_Prelude_Eq$20Lib_Types_EFlag$2C_$3D$3D_(eta, eta1))));
const Lib_Eval_tweakFC = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "Erased": return Lib_Types_Erased(_$$0); case "Lit": return Lib_Types_Lit(_$$0, _$$1.h1); case "LetRec": return Lib_Types_LetRec(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case "Let": return Lib_Types_Let(_$$0, _$$1.h1, _$$1.h2, _$$1.h3); case "Case": return Lib_Types_Case(_$$0, _$$1.h1, _$$1.h2); case "Pi": return Lib_Types_Pi(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4, _$$1.h5); case "UU": return Lib_Types_UU(_$$0); case "App": return Lib_Types_App(_$$0, _$$1.h1, _$$1.h2); case "Lam": return Lib_Types_Lam(_$$0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case "Meta": return Lib_Types_Meta(_$$0, _$$1.h1); case "Ref": return Lib_Types_Ref(_$$0, _$$1.h1); case "Bnd": return Lib_Types_Bnd(_$$0, _$$1.h1); } };
const Lib_Eval_zonkBind = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Eval_zonk(_$$0, (1) + (_$$1), Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$3), _$$1, Prelude_Lin(null)), _$$2), _$$3));
const Lib_Eval_zonkAlt = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "CaseLit": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseLit(_$$3.h0, eta)), Lib_Eval_zonkBind(_$$0, _$$1, _$$2, _$$3.h1)); case "CaseCons": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_CaseCons(_$$3.h0, _$$3.h1, eta)), Lib_Eval_zonkAlt_go(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, _$$3.h2, null, _$$1, _$$2, _$$3.h1, _$$3.h2)); case "CaseDefault": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_CaseDefault, Lib_Eval_zonkBind(_$$0, _$$1, _$$2, _$$3.h0)); } };
const Lib_Eval_zonkAlt_go = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11 ) => (bouncer(Lib_Eval_REC_zonkAlt_go, { tag: "Lib.Eval.zonkAlt.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8,  h9: _$$9,  h10: _$$10,  h11: _$$11 }));
const Lib_Eval_REC_zonkAlt_go = ( arg ) => { switch (arg.h10.tag) { case "_::_": return { tag: "Lib.Eval.zonkAlt.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: (1) + (arg.h8),  h9: Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(arg.h11), arg.h8, Prelude_Lin(null)), arg.h9),  h10: arg.h10.h2,  h11: arg.h11 }; case "Nil": return { tag: "return",  h0: Lib_Eval_zonk(arg.h0, arg.h8, arg.h9, arg.h6) }; } };
const Lib_TopContext_lookupRaw = ( _$$0, _$$1 ) => { const sc$$3 = Data_SortedMap_lookupMap$27(null, null, Lib_Common_QN(_$$1.h3, _$$0), _$$1.h4); switch (sc$$3.tag) { case "Nothing": return Lib_TopContext_lookupRaw_go(_$$0, _$$1, null, _$$1.h1); case "Just": return Prelude_Just(null, sc$$3.h1); } };
const Lib_TopContext_lookupRaw_go = ( _, _1, _2, _$$3 ) => (bouncer(Lib_TopContext_REC_lookupRaw_go, { tag: "Lib.TopContext.lookupRaw.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3 }));
const Lib_TopContext_REC_lookupRaw_go = ( arg ) => { switch (arg.h3.tag) { case "_::_": { const sc$$7 = Data_SortedMap_lookupMap$27(null, null, arg.h3.h1, arg.h1.h0); switch (sc$$7.tag) { case "Nothing": return { tag: "Lib.TopContext.lookupRaw.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 }; case "Just": { const sc$$10 = Data_SortedMap_lookupMap$27(null, null, Lib_Common_QN(arg.h3.h1, arg.h0), sc$$7.h1.h1); switch (sc$$10.tag) { case "Nothing": return { tag: "Lib.TopContext.lookupRaw.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h2 }; case "Just": return { tag: "return",  h0: Prelude_Just(null, sc$$10.h1) }; } break; } } break; } case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Compile_compile = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$1 = Lib_TopContext_lookupRaw("main", top); switch (sc$$1.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "No main function found")), eta)))); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Compile_process(sc$$1.h1.h1), ( tmp ) => { const exec = Lib_Compile_stmtToDoc(null, Lib_Compile_JPlain(Lib_Compile_Apply(Lib_Compile_Var(Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$1.h1.h1)), Prelude_Nil(null)))); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_reverse(null)(Prelude__$3A$3A_(null, exec, tmp))); }); } });
const Lib_Common_renderJson = ( _$$0 ) => { switch (_$$0.tag) { case "JsonArray": return ("[") + ((Prelude_joinBy(",", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_renderJson, _$$0.h0))) + ("]")); case "JsonInt": return Prelude_showInt(_$$0.h0); case "JsonBool": return Prelude_ite(null, _$$0.h0, "true", "false"); case "JsonStr": return Lib_Common_quoteString(_$$0.h0); case "JsonObj": return ("{") + ((Prelude_joinBy(",", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Common_renderJson_renderPair(_$$0, _$$0.h0, null, eta)), _$$0.h0))) + ("}")); } };
const Lib_Common_renderJson_renderPair = ( _, _1, _2, _$$3 ) => ((Lib_Common_quoteString(_$$3.h2)) + ((":") + (Lib_Common_renderJson(_$$3.h3))));
const Prelude_ite = ( a$$0, _$$1, _$$2, _$$3 ) => { switch (_$$1) { case "False": return _$$3; case "True": return _$$2; } };
const Main_jsonTopContext_jsonDef = ( _, _$$1 ) => (Lib_Common_JsonObj(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "fc", Lib_Common_Lib_Common_ToJSON$20Lib_Common_FC$2CtoJson(_$$1.h0)), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "name", Lib_Common_JsonStr(_$$1.h1.h1)), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "type", Lib_Common_JsonStr(Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), _$$1.h2))), Prelude_Lin(null)))), Prelude_Nil(null))))));
const Lib_Common_JsonStr = ( h0 ) => ({ tag: "JsonStr",  h0: h0 });
const Lib_Common_Lib_Common_ToJSON$20Lib_Common_FC$2CtoJson = ( _$$0 ) => (Lib_Common_JsonObj(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "file", Lib_Common_JsonStr(_$$0.h0)), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "line", Lib_Common_JsonInt(_$$0.h1.h2)), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "col", Lib_Common_JsonInt(_$$0.h1.h3)), Prelude_Nil(null))))));
const Lib_Common_JsonInt = ( h0 ) => ({ tag: "JsonInt",  h0: h0 });
const Lib_Common_JsonObj = ( h0 ) => ({ tag: "JsonObj",  h0: h0 });
const Lib_Common_JsonArray = ( h0 ) => ({ tag: "JsonArray",  h0: h0 });
const Data_SortedMap_listValues = ( k$$0, v$$1, _$$2 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h3), Data_SortedMap_toList(null, null, _$$2)));
const Main_jsonTopContext = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const defs = Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( mod ) => (Data_SortedMap_listValues(null, null, mod.h1)), Data_SortedMap_listValues(null, null, top.h0)), ( _$$1 ) => (_$$1)); return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Common_JsonObj(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "context", Lib_Common_JsonArray(Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Main_jsonTopContext_jsonDef(null, eta)), defs))), Prelude_Nil(null)))); });
const Main_processFile = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("*** Process ") + (_$$0)) + (""))), ( _ ) => { const parts = Data_List1_split1(_$$0, "/"); const sc$$3 = Data_List1_unsnoc(null, parts); let dir; const sc$$8 = Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(null, Prelude_Prelude_Eq$20Prim_String, sc$$3.h2, Prelude_Nil(null)); switch (sc$$8) { case "False": { dir = Prelude_joinBy("/", sc$$3.h2); break; } case "True": { dir = "."; break; } } const sc$$9 = Data_List1_splitFileName(sc$$3.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((((((("") + (dir)) + (" ")) + (sc$$9.h2)) + (" ")) + (sc$$9.h3)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Node_readFile(_$$0)), ( $$sc ) => { switch ($$sc.tag) { case "Right": { const sc$$20 = Lib_Tokenizer_tokenise(_$$0, $$sc.h2); switch (sc$$20.tag) { case "Right": { const sc$$24 = Lib_Parser_Impl_partialParse(null, _$$0, Lib_Parser_parseModHeader, Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1)))), sc$$20.h2); switch (sc$$24.tag) { case "Right": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Util_getBaseDir(_$$0, sc$$24.h2.h2.h3), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "Int", Prelude_Nothing(null))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "String", Prelude_Nothing(null))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(Lib_Common_primNS, Lib_Syntax_PType(Lib_Common_emptyFC, "Char", Prelude_Nothing(null))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setDef(Lib_Common_QN(Lib_Common_primNS, "PiType"), Lib_Common_emptyFC, Lib_Types_Erased(Lib_Common_emptyFC), Lib_Types_PrimFn("(h0, h1) => ({ tag: \"PiType\", h0, h1 });", (1) + ((1) + (0)), Prelude_Nil(null)), Prelude_Nil(null)), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const modules = Data_SortedMap_updateMap(null, null, Lib_Common_primNS, Lib_Types_MkModCtx("", top.h4, Lib_Types_MC(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), 0, "CheckAll"), top.h8), top.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, Prelude__$3A$3A_(null, Lib_Common_primNS, Prelude_Nil(null)), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), tc.h5, tc.h6, tc.h7, tc.h8)))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_processModule(Lib_Common_emptyFC, $$sc1.h2, Prelude_Nil(null), $$sc1.h3), ( src ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_showErrors(_$$0, src), ( _7 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"))))))))); }))))))))))); case "Left": return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, sc$$24.h2.h2), eta)))); } break; } case "Left": return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, sc$$20.h2), eta)))); } break; } case "Left": return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, 0, 0)), (((("error reading ") + (_$$0)) + (": ")) + ($$sc.h2)) + (""))), eta)))); } }))); }));
const Main_showErrors = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, top.h7)), ( $$sc ) => { switch ($$sc.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( _$$5 ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn(Lib_Common_showError(_$$1, _$$5)))), $$sc), ( _ ) => (Node_exitFailure(null, "Compile failed"))); } }))));
const Lib_Common_showError = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "Postpone": return ((((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$1.h0))) + (": Postpone ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1.h1))) + (" ")) + (_$$1.h2)) + ("\n")) + (Lib_Common_showError_go(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, 0, Prelude_lines(_$$0))); case "E": return ((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$1.h0))) + (": ")) + (_$$1.h1)) + ("\n")) + (Lib_Common_showError_go$27(_$$0, _$$1, _$$1.h0, _$$1.h1, null, 0, Prelude_lines(_$$0))); } };
const Prelude_arrayToList = (a,arr) => {
  let rval = Prelude_Nil(null)
  for (let i = arr.length - 1;i >= 0; i--) {
    rval = Prelude__$3A$3A_(a, arr[i], rval)
  }
  return rval
};
const Prelude_lines = (s) => Prelude_arrayToList(null,s.split('\n'));
const Lib_Common_showError_go$27 = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_Common_REC_showError_go$27, { tag: "Lib.Common.showError.go'",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_Common_REC_showError_go$27 = ( arg ) => { switch (arg.h6.tag) { case "_::_": { const sc$$10 = Prelude_jsEq(null, arg.h5, arg.h2.h1.h2); switch (sc$$10) { case "False": { const sc$$11 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h2.h1.h2) - (3), arg.h5), "LT"); switch (sc$$11) { case "False": return { tag: "Lib.Common.showError.go'",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (arg.h5) + (1),  h6: arg.h6.h2 }; case "True": return { tag: "return",  h0: ("  ") + ((arg.h6.h1) + (("\n") + (Lib_Common_showError_go$27(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, (arg.h5) + (1), arg.h6.h2)))) }; } break; } case "True": return { tag: "return",  h0: (((("  ") + (arg.h6.h1)) + ("\n  ")) + (Prelude_replicate(Prelude_intToNat(arg.h2.h1.h3), " "))) + ("^\n") }; } break; } case "Nil": return { tag: "return",  h0: "" }; } };
const Lib_Common_showError_go = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_Common_REC_showError_go, { tag: "Lib.Common.showError.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_Common_REC_showError_go = ( arg ) => { switch (arg.h7.tag) { case "_::_": { const sc$$11 = Prelude_jsEq(null, arg.h6, arg.h2.h1.h2); switch (sc$$11) { case "False": { const sc$$12 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, (arg.h2.h1.h2) - (3), arg.h6), "LT"); switch (sc$$12) { case "False": return { tag: "Lib.Common.showError.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: (arg.h6) + (1),  h7: arg.h7.h2 }; case "True": return { tag: "return",  h0: ("  ") + ((arg.h7.h1) + (("\n") + (Lib_Common_showError_go(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, (arg.h6) + (1), arg.h7.h2)))) }; } break; } case "True": return { tag: "return",  h0: (((("  ") + (arg.h7.h1)) + ("\n  ")) + (Prelude_replicate(Prelude_intToNat(arg.h2.h1.h3), " "))) + ("^\n") }; } break; } case "Nil": return { tag: "return",  h0: "" }; } };
const Main_processModule = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const modns = Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, _$$3.h0, Prelude__$3A$3A_(null, _$$3.h1, Prelude_Nil(null))); const name = Prelude_joinBy(".", modns); const sc$$10 = Data_SortedMap_lookupMap(null, null, modns, top.h0); switch (sc$$10.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(Data_SortedMap_updateMap(null, null, modns, Lib_Types_emptyModCtx(""), top.h0), tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _ ) => { const fn = (Prelude_joinBy("/", Prelude__$3A$3A_(null, _$$1, _$$3.h0))) + (("/") + ((_$$3.h1) + (".newt"))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Node_readFile(fn)), ( $$sc ) => { switch ($$sc.tag) { case "Right": { const sc$$19 = Lib_Tokenizer_tokenise(fn, $$sc.h2); switch (sc$$19.tag) { case "Right": { const sc$$23 = Lib_Parser_Impl_partialParse(null, fn, Lib_Parser_parseModHeader, top.h8, sc$$19.h2); switch (sc$$23.tag) { case "Right": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("scan imports for module ") + (sc$$23.h2.h2.h3)) + (""))), ( _1 ) => { const ns = Prelude_split(sc$$23.h2.h2.h3, "."); const sc$$41 = Data_List1_unsnoc(null, Data_List1_split1(sc$$23.h2.h2.h3, ".")); const sc$$46 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$3, Lib_Common_QN(sc$$41.h2, sc$$41.h3)); switch (sc$$46) { case "True": { const sc$$47 = Lib_Parser_Impl_partialParse(null, fn, Lib_Parser_parseImports, sc$$23.h2.h3.h2, sc$$23.h2.h3.h3); switch (sc$$47.tag) { case "Right": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, sc$$47.h2.h2, ( $$case ) => { const sc$$63 = Data_List1_unsnoc(null, Data_List1_split1($$case.h1, ".")); const qname = Lib_Common_QN(sc$$63.h2, sc$$63.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(null, Prelude_Prelude_Eq$20Prim_String, $$case.h1, _$$2), ( _2 ) => (Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (((("import loop ") + (name)) + (" -> ")) + ($$case.h1)) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_processModule($$case.h0, _$$1, Prelude__$3A$3A_(null, name, _$$2), qname), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_split($$case.h1, ".")))))); }), ( imported ) => { const imported1 = Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, imported, Prelude__$3A$3A_(null, Lib_Common_primNS, Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Serialize_checksum($$sc.h2)), ( srcSum ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_moduleHash(srcSum, imported1), ( csum ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("module ") + (sc$$23.h2.h2.h3)) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Serialize_loadModule(_$$3, csum), ( $$sc1 ) => { switch ($$sc1.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _3 ) => (("MODNS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, modns))))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_parseDecls(fn, top2.h8, sc$$47.h2.h3.h3, Prelude_Lin(null)), ( $$sc2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top3 ) => { const freshMC = Lib_Types_MC(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), 0, "CheckAll"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, imported1, Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), modns, Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), freshMC, tc.h6, tc.h7, $$sc2.h3)))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, imported1, ( ns1 ) => { const sc$$80 = Data_SortedMap_lookupMap$27(null, null, ns1, top3.h0); switch (sc$$80.tag) { case "Just": return Main_importHints(Data_SortedMap_listValues(null, null, sc$$80.h1.h1)); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("namespace ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, ns1)))) + (" missing"))), eta)))); } }), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _6 ) => ("process Decls")), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Main_processModule_tryProcessDecl(_$$0, _$$1, _$$2, _$$3, _$$3.h0, _$$3.h1, null, $$sc.h2, ns, eta)), Lib_Elab_collectDecl($$sc2.h2)), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top4 ) => { const mod = Lib_Types_MkModCtx(csum, top4.h4, top4.h5, top4.h8); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, top4.h7)), ( errors ) => { const sc$$85 = Prelude__$26$26_(Prelude_not(Prelude_Prelude_Eq$20$28Prelude_List$20BND$3A1$29$2C_$3D$3D_(null, Prelude_Prelude_Eq$20Prim_String, _$$2, Prelude_Nil(null))), Prelude_jsEq(null, Prelude_length$27(null, errors), 0)); switch (sc$$85) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"), ( _8 ) => { const modules = Data_SortedMap_updateMap(null, null, modns, mod, top4.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, top4.h7)), ( $$sc3 ) => { switch ($$sc3.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_logMetas(Prelude_reverse(null)(Data_SortedMap_listValues(null, null, top4.h5.h0))), ( _10 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc.h2))); default: return Node_exitFailure(null, "Compile failed"); } }))); }); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Serialize_dumpModule(_$$3, $$sc.h2, mod), ( _8 ) => { const modules = Data_SortedMap_updateMap(null, null, modns, mod, top4.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, tc.h8)))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Data_IORef_primReadIORef(null, top4.h7)), ( $$sc3 ) => { switch ($$sc3.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_logMetas(Prelude_reverse(null)(Data_SortedMap_listValues(null, null, top4.h5.h0))), ( _10 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc.h2))); default: return Node_exitFailure(null, "Compile failed"); } }))); }); } }); }))))))))); }))))))); case "Just": { const modules = Data_SortedMap_updateMap(null, null, modns, $$sc1.h1, top1.h0); const ops = Data_SortedMap_foldMap(null, null, ( _$$21 ) => (( _$$31 ) => (_$$21)), top1.h8, Data_SortedMap_toList(null, null, $$sc1.h1.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(modules, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, tc.h6, tc.h7, ops)))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc.h2))); break; } } }))))))))); }); case "Left": return Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$47.h2.h2)); } break; } default: return Node_exitFailure(null, (((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$23.h2.h2.h2))) + (": module name ")) + (sc$$23.h2.h2.h3)) + (" doesn't match file name ")) + (fn)) + ("")); } }); case "Left": return Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$23.h2.h2)); } break; } case "Left": return Node_exitFailure(null, Lib_Common_showError($$sc.h2, sc$$19.h2)); } break; } case "Left": return Node_exitFailure(null, (((((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0))) + (": error reading ")) + (fn)) + (": ")) + ($$sc.h2)) + ("")); } }); }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, ""); } }));
const Lib_Types_MkTop = ( h0, h1, h2, h3, h4, h5, h6, h7, h8 ) => ({ tag: "MkTop",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5,  h6: h6,  h7: h7,  h8: h8 });
const Lib_Types_putTop = ( _$$0 ) => (Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Right(null, null, Prelude__$2C_(null, null, _$$0, "MkUnit")), eta)))));
const Lib_ProcessDecl_logMetas = ( _$$0 ) => (bouncer(Lib_ProcessDecl_REC_logMetas, { tag: "Lib.ProcessDecl.logMetas",  h0: _$$0 }));
const Lib_ProcessDecl_REC_logMetas = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1.tag) { case "OutOfScope": return { tag: "Lib.ProcessDecl.logMetas",  h0: arg.h0.h2 }; case "Solved": return { tag: "Lib.ProcessDecl.logMetas",  h0: arg.h0.h2 }; case "Unsolved": switch (arg.h0.h1.h4) { case "User": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(arg.h0.h1.h2.h0, arg.h0.h1.h3), ( ty$27 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), arg.h0.h1.h2.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_dumpEnv(arg.h0.h1.h2), ( env ) => { const msg = (((("") + (env)) + ("\n  -----------\n  ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, ty$27))), Prelude_Lin(null)))) + (""); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(arg.h0.h1.h0, (("User Hole\n") + (msg)) + ("")), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))); }); }) }; default: return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta(arg.h0.h1.h3), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(arg.h0.h1.h2.h0, ty$27), ( tm ) => { const msg = (((((((("Unsolved meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h0.h1.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(arg.h0.h1.h4))) + (" type ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), arg.h0.h1.h2.h2), tm))), Prelude_Lin(null)))) + (" ")) + (Prelude_showInt(Prelude_length$27(null, arg.h0.h1.h5)))) + (" constraints"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, arg.h0.h1.h5, ( $$case ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, (((((("  * (m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h0.h1.h1))) + (" (")) + (Prelude_joinBy(" ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, $$case.h2, Prelude_Nil(null)))))) + (") =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$case.h3))) + ("")))), ( msgs ) => { switch (arg.h0.h1.h4) { case "AutoSolve": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(arg.h0.h1.h2.h0, arg.h0.h1.h3), ( x ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(arg.h0.h1.h2.h1, x), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("AUTO ---> ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { switch (ty.tag) { case "VRef": { const cands = Prelude_fromMaybe(null, Prelude_Nil(null), Data_SortedMap_lookupMap$27(null, null, ty.h1, top.h2)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_findMatches(arg.h0.h1.h2, ty, cands), ( matches ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, (((("  ") + (Prelude_showInt(Prelude_length$27(null, matches)))) + (" Solutions: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, matches)))) + (""), Prelude_Nil(null))))); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)); } }))))))), ( sols ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(arg.h0.h1.h0, Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude__$3A$3A_(null, msg, Prelude_Nil(null)), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, msgs, sols)))), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)), ( sols ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(arg.h0.h1.h0, Prelude_joinBy("\n", Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, Prelude__$3A$3A_(null, msg, Prelude_Nil(null)), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, msgs, sols)))), ( _ ) => (Lib_ProcessDecl_logMetas(arg.h0.h2))))); } }); }))) }; } break; } break; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit") }; } };
const Lib_Types_info = ( _$$0, _$$1 ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((((("INFO at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0))) + (": ")) + (_$$1)) + (""))));
const Lib_Elab_findMatches = ( _$$0, _$$1, _$$2 ) => (bouncer(Lib_Elab_REC_findMatches, { tag: "Lib.Elab.findMatches",  h0: _$$0,  h1: _$$1,  h2: _$$2 }));
const Lib_Elab_REC_findMatches = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$10 = Lib_Elab_isCandidate(arg.h1, arg.h2.h1.h3); switch (sc$$10) { case "False": return { tag: "Lib.Elab.findMatches",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2.h2 }; case "True": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const fc = Lib_Types_getValFC(arg.h1); return Lib_Types_catchError(null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("TRY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h2.h1.h2))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), arg.h2.h1.h3))), Prelude_Lin(null)))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (""))), ( _ ) => { const sc$$18 = Lib_Util_splitTele(arg.h2.h1.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_setMetaMode("CheckFirst"), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(arg.h0, Lib_Syntax_RVar(fc, arg.h2.h1.h2.h1), arg.h1), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("Found ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), tm))), Prelude_Lin(null)))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _3 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$3A$3A_(null, arg.h2.h1.h2, eta)), Lib_Elab_findMatches(arg.h0, arg.h1, arg.h2.h2)))))))))); }), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("No match ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1))) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), arg.h2.h1.h3))), Prelude_Lin(null)))) + (" ")) + (Lib_Common_showError("", err))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _1 ) => (Lib_Elab_findMatches(arg.h0, arg.h1, arg.h2.h2))))))); }) }; } break; } case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)) }; } };
const Lib_Syntax_RVar = ( h0, h1 ) => ({ tag: "RVar",  h0: h0,  h1: h1 });
const Lib_Elab_check = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_forceType(_$$0.h1, _$$2), ( ty$27 ) => { const sc$$4 = Prelude__$2C_(null, null, _$$1, ty$27); switch (sc$$4.h2.tag) { case "RUpdateRec": return Lib_Elab_updateRec(_$$0, sc$$4.h2.h0, sc$$4.h2.h1, sc$$4.h2.h2, sc$$4.h3); case "RWhere": return Lib_Elab_checkWhere(_$$0, Lib_Elab_collectDecl(sc$$4.h2.h1), sc$$4.h2.h2, sc$$4.h3); case "RIf": { const tm$27 = Lib_Syntax_RCase(sc$$4.h2.h0, sc$$4.h2.h1, Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(Lib_Syntax_RVar(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2.h2), "True"), sc$$4.h2.h2), Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(Lib_Syntax_RVar(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2.h3), "False"), sc$$4.h2.h3), Prelude_Nil(null)))); return Lib_Elab_check(_$$0, tm$27, sc$$4.h3); break; } case "RDo": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(sc$$4.h2.h0, sc$$4.h2.h1), ( stmts$27 ) => (Lib_Elab_check(_$$0, stmts$27, sc$$4.h3))); case "RHole": return Lib_Elab_freshMeta(_$$0, sc$$4.h2.h0, sc$$4.h3, "User"); case "RImplicit": return Lib_Elab_freshMeta(_$$0, sc$$4.h2.h0, sc$$4.h3, "Normal"); case "RCase": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, sc$$4.h2.h1), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta($$sc.h3), ( scty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("SCTM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2), $$sc.h2))), Prelude_Lin(null)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("SCTY ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty))) + (""))), ( _1 ) => { const scnm = Lib_Elab_fresh(_$$0, "sc"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, sc$$4.h2.h2, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_mkPat(Prelude__$2C_(null, null, $$case.h0, "Explicit")), ( pat$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC($$case.h0), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, scnm, pat$27), Prelude_Nil(null)), Prelude_Nil(null), $$case.h1)))))), ( clauses ) => { let ctx$27; const _sc$$22 = Lib_Types_extend(_$$0, scnm, scty); ctx$27 = Lib_Types_MkCtx(_sc$$22.h0, _sc$$22.h1, _sc$$22.h2, _sc$$22.h3, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, sc$$4.h3)), ( tree ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Let(sc$$4.h2.h0, scnm, $$sc.h2, tree)))); }))); }))))))); case "RLet": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, sc$$4.h2.h2, Lib_Types_VU(Lib_Common_emptyFC)), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, ty$271), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, sc$$4.h2.h3, vty), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, v$27), ( vv ) => { const ctx$27 = Lib_Types_define(_$$0, sc$$4.h2.h1, vv, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(ctx$27, sc$$4.h2.h4, sc$$4.h3), ( sc$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Let(sc$$4.h2.h0, sc$$4.h2.h1, v$27, sc$27)))); }))))))); case "RLam": switch (sc$$4.h3.tag) { case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((((("icits ") + (sc$$4.h2.h1.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(sc$$4.h2.h1.h2))) + (" ")) + (sc$$4.h3.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(sc$$4.h3.h2))) + (""))), ( _ ) => { const sc$$23 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(sc$$4.h2.h1.h2, sc$$4.h3.h2); switch (sc$$23) { case "False": { const sc$$24 = Prelude_not(Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(sc$$4.h3.h2, "Explicit")); switch (sc$$24) { case "False": return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$4.h2.h0, (((("Icity issue checking ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" at ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), eta)))); case "True": { const $var = Lib_Types_VVar(sc$$4.h2.h0, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, $var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(sc$$4.h2.h0, sc$$4.h3.h1, sc$$4.h2.h1.h2, sc$$4.h3.h3, sc)))))); break; } } break; } case "True": { const $var = Lib_Types_VVar(sc$$4.h2.h0, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)); const ctx$27 = Lib_Types_extend(_$$0, sc$$4.h2.h1.h1, sc$$4.h3.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, $var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( bapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(ctx$27, sc$$4.h2.h2, bapp), ( tm$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(sc$$4.h2.h0, sc$$4.h2.h1.h1, sc$$4.h2.h1.h2, sc$$4.h3.h3, tm$27)))))); break; } } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_prvalCtx(_$$0, sc$$4.h3), ( pty ) => (Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$4.h2.h1.h0, (("Expected pi type, got ") + (pty)) + (""))), eta)))))); } break; default: switch (sc$$4.h3.tag) { case "VPi": switch (sc$$4.h3.h2) { case "Auto": { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("XXX edge case add auto lambda {") + (sc$$4.h3.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3.h4))) + ("} to ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" "))), ( _ ) => { const $var = Lib_Types_VVar(sc$$4.h3.h0, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, $var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_logM(2, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_prvalCtx(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), ty$271), ( pty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, (("XXX ty' is ") + (pty$27)) + (""))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), sc$$4.h3.h1, "Auto", sc$$4.h3.h3, sc)))))))); }); break; } case "Implicit": { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("XXX edge case add implicit lambda {") + (sc$$4.h3.h1)) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3.h4))) + ("} to ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" "))), ( _ ) => { const $var = Lib_Types_VVar(sc$$4.h3.h0, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, $var, sc$$4.h3.h5.h0), sc$$4.h3.h5.h1), ( ty$271 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_logM(2, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_prvalCtx(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), ty$271), ( pty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, (("XXX ty' is ") + (pty$27)) + (""))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_extend(_$$0, sc$$4.h3.h1, sc$$4.h3.h4), sc$$4.h2, ty$271), ( sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), sc$$4.h3.h1, "Implicit", sc$$4.h3.h3, sc)))))))); }); break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, sc$$4.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((((("INFER ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" to (")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, $$sc1.h2))), Prelude_Lin(null)))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc1.h3))) + (") expect ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), _$$0, $$sc1.h3, sc$$4.h3), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc1.h2))))); }))); } break; default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, sc$$4.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((((("INFER ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$4.h2))) + (" to (")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, $$sc1.h2))), Prelude_Lin(null)))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc1.h3))) + (") expect ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$4.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$4.h2), _$$0, $$sc1.h3, sc$$4.h3), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, $$sc1.h2))))); }))); } break; } }));
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case "RUpdateRec": return _$$0.h0; case "RAs": return _$$0.h0; case "RWhere": return _$$0.h0; case "RIf": return _$$0.h0; case "RDo": return _$$0.h0; case "RHole": return _$$0.h0; case "RImplicit": return _$$0.h0; case "RCase": return _$$0.h0; case "RLit": return _$$0.h0; case "RAnn": return _$$0.h0; case "RLet": return _$$0.h0; case "RPi": return _$$0.h0; case "RU": return _$$0.h0; case "RApp": return _$$0.h0; case "RLam": return _$$0.h0; case "RVar": return _$$0.h0; } };
const Lib_Elab_unifyCatch = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_catchError(null, Lib_Elab_unify(_$$1.h1, "UNormal", _$$2, _$$3), ( err ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("fail ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$1.h0, _$$2), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$1.h0, _$$3), ( b ) => { const msg = (((((("unification failure: ") + (Lib_Types_errorMsg(err))) + ("\n  failed to unify ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, a))), Prelude_Lin(null)))) + ("\n             with ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, b))), Prelude_Lin(null)))) + ("\n  "); return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, msg)), eta)))); }))))); }), ( res ) => { switch (res.h0.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("fail with constraints ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), res.h0)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$1.h0, _$$2), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$1.h0, _$$3), ( b ) => { const names = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$1.h2); const msg = (((("unification failure\n  failed to unify ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, a))), Prelude_Lin(null)))) + ("\n             with ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, names, b))), Prelude_Lin(null)))) + (""); const msg1 = (msg) + ((("\nconstraints ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), res.h0)))) + ("")); return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, msg1)), eta)))); }))))); } }));
const Prelude_MkShow = ( h0, h1 ) => ({ tag: "MkShow",  h0: h0,  h1: h1 });
const Lib_Types_Prelude_Show$20Lib_Types_Val = Prelude_MkShow(null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow);
const Prelude_Prelude_Show$20Prim_Int$2Cshow = Prelude_showInt;
const Prelude_Prelude_Show$20Prim_Int = Prelude_MkShow(null, Prelude_Prelude_Show$20Prim_Int$2Cshow);
const Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow = ( a$$0, b$$1, _$$2, _$$3, _$$4 ) => (("(") + ((Prelude_show(null, _$$2)(_$$4.h2)) + ((", ") + ((Prelude_show(null, _$$3)(_$$4.h3)) + (")")))));
const Prelude_show = ( a$$0, _$$1 ) => (_$$1.h1);
const Lib_Elab_unify = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("Unify lvl ") + (Prelude_showInt(Prelude_natToInt(Prelude_length(null, _$$0))))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("  ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((("  =?= ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta(_$$2), ( eta ) => (Lib_Eval_unlet(_$$0, eta))), ( t$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta(_$$3), ( eta ) => (Lib_Eval_unlet(_$$0, eta))), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((("forced ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(t$27))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("  =?= ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(u$27))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("env ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _$$0)))) + (""))), ( _5 ) => { const l = Prelude_length$27(null, _$$0); switch (_$$1) { case "UPattern": return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta_unifyPattern(_$$0, _$$1, _$$2, _$$3, null, null, null, null, null, null, t$27, u$27); case "UNormal": return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_$$0, _$$1, _$$2, _$$3, null, null, null, null, null, t$27, u$27); } }))))))))))))))));
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10 ) => { switch (_$$10.tag) { case "VMeta": switch (_$$9.tag) { case "VMeta": { const sc$$17 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$9.h1, _$$10.h1); switch (sc$$17) { case "False": { const sc$$18 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_Prelude_Ord$20Prelude_Nat$2Ccompare(Data_SnocList_snoclen(null, _$$9.h2), Data_SnocList_snoclen(null, _$$10.h2)), "LT"); switch (sc$$18) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_, _$$9.h1, _$$9.h2, Lib_Types_VMeta(_$$10.h0, _$$10.h1, _$$10.h2)), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_, _$$10.h1, _$$10.h2, Lib_Types_VMeta(_$$9.h0, _$$9.h1, _$$9.h2)), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); } break; } case "True": return Lib_Elab_unifySpine(_, _1, Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$9.h1, _$$10.h1), _$$9.h2, _$$10.h2); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_, _$$10.h1, _$$10.h2, _$$9), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); } break; default: switch (_$$9.tag) { case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_, _$$9.h1, _$$9.h2, _$$10), ( _9 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral))); default: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam(_, _1, _2, _3, _4, _5, _6, _7, _$$9, _$$10); } break; } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => { switch (_$$9.tag) { case "VLam": switch (_$$8.tag) { case "VLam": { const fresh = Lib_Types_VVar(_$$8.h0, Prelude_length$27(null, _), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$8.h4.h0), _$$8.h4.h1), ( vappt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$9.h4.h0), _$$9.h4.h1), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(null, fresh, _), _1, vappt, vappt$27))))); break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => ((("ETA ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), ( _8 ) => { const fresh = Lib_Types_VVar(_$$9.h0, Prelude_length$27(null, _), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vapp(_$$8, fresh), ( vappt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$9.h4.h0), _$$9.h4.h1), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(null, fresh, _), _1, vappt, vappt$27))))); }); } break; default: switch (_$$8.tag) { case "VLam": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => ((("ETA' ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$9))) + (""))), ( _8 ) => { const fresh = Lib_Types_VVar(_$$8.h0, Prelude_length$27(null, _), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$8.h4.h0), _$$8.h4.h1), ( appt ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vapp(_$$9, fresh), ( vappt$27 ) => (Lib_Elab_unify(Prelude__$3A$3A_(null, fresh, _), _1, appt, vappt$27))))); }); default: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar(_, _1, _2, _3, _4, _5, _6, _$$8, _$$9); } break; } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => { switch (_$$8.tag) { case "VVar": switch (_$$7.tag) { case "VVar": { const sc$$15 = Prelude_jsEq(null, _$$7.h1, _$$8.h1); switch (sc$$15) { case "False": return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$7.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))); case "True": return Lib_Elab_unifySpine(_, _1, Prelude_jsEq(null, _$$7.h1, _$$8.h1), _$$7.h2, _$$8.h2); } break; } default: switch (_$$8.h2.tag) { case "Lin": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_tryEval(_, _$$7), ( vt ) => { switch (vt.tag) { case "Nothing": return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$8.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))); case "Just": return Lib_Elab_unify(_, _1, vt.h1, _$$8); } }); default: return Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8); } break; } break; default: switch (_$$7.tag) { case "VVar": switch (_$$7.h2.tag) { case "Lin": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_tryEval(_, _$$8), ( vu ) => { switch (vu.tag) { case "Nothing": return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$7.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))); case "Just": return Lib_Elab_unify(_, _1, _$$7, vu.h1); } }); default: return Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8); } break; default: return Lib_Elab_unify_unifyRest_unifyRef(_, _1, _2, _3, _4, _5, _$$7, _$$8); } break; } };
const Lib_Elab_unify_unifyRest_unifyRef = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case "VRef": switch (_$$6.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_tryEval(_, _$$6), ( $$sc ) => { switch ($$sc.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_tryEval(_, _$$7), ( $$sc1 ) => { switch ($$sc1.tag) { case "Nothing": { const sc$$20 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$6.h1, _$$7.h1); switch (sc$$20) { case "False": return Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$6.h0, (((("vref mismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), eta)))); case "True": return Lib_Elab_unifySpine(_, _1, Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$6.h1, _$$7.h1), _$$6.h2, _$$7.h2); } break; } case "Just": return Lib_Elab_unify(_, _1, _$$6, $$sc1.h1); } }); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((((("tryEval ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h1))) + (""))), ( _6 ) => (Lib_Elab_unify(_, _1, $$sc.h1, _$$7))); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((((("expand ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= %ref ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$7.h1))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookup(_$$7.h1, top); switch (sc$$13.tag) { case "Just": switch (sc$$13.h1.h3.tag) { case "Fn": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$13.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(vtm, _$$7.h2), ( appvtm ) => (Lib_Elab_unify(_, _1, _$$6, appvtm))))); default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$7.h0, (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" [no Fn]\n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$7.h0, (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (" [no Fn]\n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } }))); } break; default: switch (_$$6.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((((((("expand %ref ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$6.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$6.h2, Prelude_Nil(null)))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookup(_$$6.h1, top); switch (sc$$13.tag) { case "Just": switch (sc$$13.h1.h3.tag) { case "Fn": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$13.h1.h3.h0), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(vtm, _$$6.h2), ( tmsp ) => (Lib_Elab_unify(_, _1, tmsp, _$$7))))); default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$6.h0, (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" [no Fn] =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + ("\n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$6.h0, (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" [no Fn] =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$7))) + ("\n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } }))); default: return Lib_Elab_unify_unifyRest(_, _1, _2, _3, _4, _$$6, _$$7); } break; } };
const Lib_Elab_unify_unifyRest = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => { switch (_$$6.tag) { case "VLit": switch (_$$5.tag) { case "VLit": { const sc$$11 = Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(_$$5.h1, _$$6.h1); switch (sc$$11) { case "False": return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$5.h0, (((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$5.h1))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$6.h1))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral); } break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } break; case "VU": switch (_$$5.tag) { case "VU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } break; case "VPi": switch (_$$5.tag) { case "VPi": { const fresh = Lib_Types_VVar(_$$5.h0, Prelude_length$27(null, _), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$5.h5.h0), _$$5.h5.h1), ( xb ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, fresh, _$$6.h5.h0), _$$6.h5.h1), ( xb$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_(eta, eta1))), Lib_Elab_unify(_, _1, _$$5.h4, _$$6.h4)), Lib_Elab_unify(Prelude__$3A$3A_(null, fresh, _), _1, xb, xb$27)))))); break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$5), (((((("unify failed ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$5))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$6))) + (" \n  env is ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, _)))) + (""))), eta)))); } };
const Lib_Types_getValFC = ( _$$0 ) => { switch (_$$0.tag) { case "VLit": return _$$0.h0; case "VErased": return _$$0.h0; case "VU": return _$$0.h0; case "VLetRec": return _$$0.h0; case "VLet": return _$$0.h0; case "VPi": return _$$0.h0; case "VLam": return _$$0.h0; case "VMeta": return _$$0.h0; case "VCase": return _$$0.h0; case "VRef": return _$$0.h0; case "VVar": return _$$0.h0; } };
const Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_ = ( _$$0, _$$1 ) => (Lib_Elab_MkResult(Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, _$$0.h0, _$$1.h0)));
const Lib_Elab_MkResult = ( h0 ) => ({ tag: "MkResult",  h0: h0 });
const Lib_Elab_Prelude_Monoid$20Lib_Elab_UnifyResult$2Cneutral = Lib_Elab_MkResult(Prelude_Nil(null));
const Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "LChar": switch (_$$0.tag) { case "LChar": return Prelude_jsEq(null, _$$0.h0, _$$1.h0); default: return "False"; } break; case "LInt": switch (_$$0.tag) { case "LInt": return Prelude_jsEq(null, _$$0.h0, _$$1.h0); default: return "False"; } break; case "LString": switch (_$$0.tag) { case "LString": return Prelude_jsEq(null, _$$0.h0, _$$1.h0); default: return "False"; } break; } };
const Lib_Elab_unifySpine = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { switch (_$$2) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "unify failed at head")), eta)))); case "True": switch (_$$3.tag) { case "_:<_": switch (_$$4.tag) { case "_:<_": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2C_$3C$2A$3E_(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Elab_Prelude_Semigroup$20Lib_Elab_UnifyResult$2C_$3C$2B$3E_(eta, eta1))), Lib_Elab_unify(_$$0, _$$1, _$$3.h2, _$$4.h2)), Lib_Elab_unifySpine(_$$0, _$$1, "True", _$$3.h1, _$$4.h1)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "meta spine length mismatch")), eta)))); } break; case "Lin": switch (_$$4.tag) { case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_MkResult(Prelude_Nil(null))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "meta spine length mismatch")), eta)))); } break; } break; } };
const Lib_Elab_solve = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$1), ( $$sc ) => { switch ($$sc.tag) { case "Unsolved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((((((("SOLVE ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow($$sc.h4))) + (" lvl ")) + (Prelude_showInt(Prelude_length$27(null, _$$0)))) + (" sp ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$2, Prelude_Nil(null)))))) + (" is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => { const size = Prelude_length(null, Prelude_filter(null, ( x ) => (Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_(x, "Bound")), $$sc.h2.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((((((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" size is ")) + (Prelude_showInt(Prelude_natToInt(size)))) + (" sps ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(null, _$$2))))) + (""))), ( _1 ) => { const sc$$15 = Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_(Data_SnocList_snoclen(null, _$$2), size); switch (sc$$15) { case "True": { const l = Prelude_length$27(null, _$$0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((("meta ") + (Lib_Types_Prelude_Show$20Lib_Types_MetaEntry$2Cshow($$sc))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_invert(l, _$$2), ( ren ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(l, _$$3), ( hack ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0, hack), ( t ) => (Lib_Types_catchError(null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$1, ren, l, t), ( tm ) => { const tm1 = Lib_Elab_lams(Data_SnocList_snoclen(null, _$$2), Prelude_reverse(null)(Lib_Elab__boundNames($$sc.h2)), tm); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), tm1), ( soln ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateMeta(_$$1, ( $$case ) => { switch ($$case.tag) { case "OutOfScope": return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" out of scope"))), eta)))); case "Solved": return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E($$case.h0, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" already solved! [solve2]"))), eta)))); case "Unsolved": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Solved($$case.h0, $$case.h1, soln)); } }), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_maybeCheck(Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for_(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, $$sc.h5, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(soln, $$case.h2), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((((((("discharge l=") + (Prelude_showInt(Prelude_length$27(null, $$case.h1)))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$case.h3))) + (""))), ( _4 ) => (Lib_Elab_unify($$case.h1, "UNormal", val, $$case.h3))))))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top1 ) => { switch (top1.h5.h3) { case "CheckAll": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((("check autos depending on ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" ")) + (Prelude_debugStr(null, top1.h5.h3))) + (""))), ( _5 ) => (Lib_Elab_checkAutos($$sc.h1, top1.h5.h1))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } })))), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"))))))))); }), ( $$case ) => { switch ($$case.tag) { case "Postpone": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((("CONSTRAINT2 m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$2, Prelude_Nil(null)))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(t))) + (""))), ( _3 ) => (Lib_Elab_addConstraint(_$$0, _$$1, _$$2, t))); default: return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, $$case), eta)))); } }))))))))); break; } default: { const l = Prelude_length$27(null, _$$0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((((((("meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" (")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (") applied to ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(null, _$$2))))) + (" args instead of ")) + (Prelude_showInt(Prelude_natToInt(size)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((("CONSTRAINT m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$sc.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$2, Prelude_Nil(null)))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Elab_addConstraint(_$$0, _$$1, _$$2, _$$3))))); break; } } }); }); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$3), (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" already solved! [solve]"))), eta)))); } }));
const Lib_Elab_addConstraint = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { switch (top.h5.h3) { case "CheckAll": return Lib_Elab_updateMeta(_$$1, ( $$case ) => { switch ($$case.tag) { case "OutOfScope": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" out of scope"))), eta)))); case "Solved": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E($$case.h0, (("Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow($$case.h1))) + (" already solved [addConstraint]"))), eta)))); case "Unsolved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("Add constraint m") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$2, Prelude_Nil(null)))))) + (" =?= ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Unsolved($$case.h0, $$case.h1, $$case.h2, $$case.h3, $$case.h4, Prelude__$3A$3A_(null, Lib_Types_MkMc(Lib_Types_getValFC(_$$3), _$$0, _$$2, _$$3), $$case.h5))))); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } }));
const Lib_Types_MkMc = ( h0, h1, h2, h3 ) => ({ tag: "MkMc",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Types_Unsolved = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "Unsolved",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Elab_updateMeta = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$0, top.h5.h0); switch (sc$$4.tag) { case "Nothing": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, _$$1(sc$$4.h1), ( me ) => { let autos; switch (me.tag) { case "Solved": { autos = Prelude_filter(null, ( _$$3 ) => (Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$0, _$$3))), top.h5.h1); break; } default: { autos = top.h5.h1; break; } } return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(Data_SortedMap_updateMap(null, null, _$$0, me, top.h5.h0), autos, top.h5.h2, top.h5.h3), tc.h6, tc.h7, tc.h8)))); }); } }));
const Lib_Types_MC = ( h0, h1, h2, h3 ) => ({ tag: "MC",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Elab_checkAutos = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$1.h1), ( $$sc ) => { switch ($$sc.tag) { case "Unsolved": switch ($$sc.h4) { case "AutoSolve": switch ($$sc.h3.tag) { case "VRef": { const sc$$18 = Lib_Elab_checkAutos_checkMeta(_$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, $$sc.h3.h2); switch (sc$$18) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_trySolveAuto($$sc), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"), ( _ ) => (Lib_Elab_checkAutos(_$$0, _$$1.h2))); } break; default: return Lib_Elab_checkAutos(_$$0, _$$1.h2); } break; default: return Lib_Elab_checkAutos(_$$0, _$$1.h2); } }); case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } };
const Lib_Elab_trySolveAuto = ( _$$0 ) => { switch (_$$0.tag) { case "Unsolved": switch (_$$0.h4) { case "AutoSolve": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("TRYAUTO solving ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_$$0.h2.h0, _$$0.h3), ( x ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h2.h1, x), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("AUTO ---> ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_contextMatches(_$$0.h2, ty), ( $$sc ) => { switch ($$sc.tag) { case "_::_": switch ($$sc.h2.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h2.h1, $$sc.h1.h2), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("LOCAL SOLUTION ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), $$sc.h1.h2))), Prelude_Lin(null)))) + (" evaled to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _2 ) => { const sp = Lib_Elab_makeSpine(_$$0.h2.h0, _$$0.h2.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_$$0.h2.h1, _$$0.h1, sp, val), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ("<-- AUTO LOCAL")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => (((">UNIFY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(Lib_Types_getValFC(ty), _$$0.h2, ty, $$sc.h1.h3), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _7 ) => ((("<UNIFY ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (""))), ( _7 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"))))))))))); }))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("LOCAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(a, Lib_Prettier_Text(",")), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), b)))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$5 ) => (Lib_Types_pprint$27(0, Prelude_Nil(null), _$$5.h2)), $$sc)))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"))); } break; case "Nil": switch (ty.tag) { case "VRef": { const cands = Prelude_fromMaybe(null, Prelude_Nil(null), Data_SortedMap_lookupMap$27(null, null, ty.h1, top.h2)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_findMatches(_$$0.h2, ty, cands), ( $$sc1 ) => { switch ($$sc1.tag) { case "_::_": switch ($$sc1.h2.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0.h2, Lib_Syntax_RVar(_$$0.h0, $$sc1.h1.h1), ty), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h2.h1, tm), ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("SOLUTION ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), tm))), Prelude_Lin(null)))) + (" evaled to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((("GLOBAL SOLUTION ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(val))) + (""))), ( _3 ) => { const sp = Lib_Elab_makeSpine(_$$0.h2.h0, _$$0.h2.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$0.h1), ( $$sc2 ) => { switch ($$sc2.tag) { case "Unsolved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solve(_$$0.h2.h1, _$$0.h1, sp, val), ( _4 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"); } }); }))))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("GLOBAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, $$sc1)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"))); } break; default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("GLOBAL FAILED to solve ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty))) + (", matches: ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, $$sc1)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"))); } }); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"); } break; } }))))))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"); } };
const Lib_Elab_makeSpine = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_makeSpine, { tag: "Lib.Elab.makeSpine",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_makeSpine = ( arg ) => { switch (arg.h1.tag) { case "_::_": switch (arg.h1.h1) { case "Defined": return { tag: "Lib.Elab.makeSpine",  h0: (arg.h0) - (1),  h1: arg.h1.h2 }; case "Bound": return { tag: "return",  h0: Prelude__$3A$3C_(null, Lib_Elab_makeSpine((arg.h0) - (1), arg.h1.h2), Lib_Types_VVar(Lib_Common_emptyFC, (arg.h0) - (1), Prelude_Lin(null))) }; } break; case "Nil": return { tag: "return",  h0: Prelude_Lin(null) }; } };
const Lib_Elab_contextMatches = ( _$$0, _$$1 ) => (Lib_Elab_contextMatches_go(_$$0, _$$1, null, Prelude_zip(null, null, _$$0.h1, _$$0.h2)));
const Prelude_zip = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "_::_": switch (_$$2.tag) { case "_::_": return Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$2.h1, _$$3.h1), Prelude_zip(null, null, _$$2.h2, _$$3.h2)); default: return Prelude_Nil(null); } break; default: return Prelude_Nil(null); } };
const Lib_Elab_contextMatches_go = ( _, _1, _2, _$$3 ) => { switch (_$$3.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$3.h1.h3.h3), ( type ) => { const sc$$16 = Lib_Elab_isCandidate(_1, type); switch (sc$$16) { case "False": return Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_catchError(null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((("TRY context ") + (_$$3.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _.h2), type))), Prelude_Lin(null)))) + (" for ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(Lib_Types_getValFC(_1), _, _1, _$$3.h1.h3.h3), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$3.h1.h2), ( tm ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$3A$3A_(null, Prelude__$2C_(null, null, tm, _$$3.h1.h3.h3), eta)), Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2)))))))))), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((("No match ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_1))) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _.h2), type))), Prelude_Lin(null)))) + (" ")) + (Lib_Common_showError("", err))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, top.h5, tc.h6, tc.h7, tc.h8)))), ( _4 ) => (Lib_Elab_contextMatches_go(_, _1, _2, _$$3.h2))))))))); } }); case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)); } };
const Lib_Elab_isCandidate = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_isCandidate, { tag: "Lib.Elab.isCandidate",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_isCandidate = ( arg ) => { switch (arg.h1.tag) { case "Pi": switch (arg.h1.h2) { case "Explicit": return { tag: "return",  h0: "False" }; default: return { tag: "Lib.Elab.isCandidate",  h0: arg.h0,  h1: arg.h1.h5 }; } break; case "App": return { tag: "Lib.Elab.isCandidate",  h0: arg.h0,  h1: arg.h1.h1 }; case "Ref": switch (arg.h0.tag) { case "VRef": return { tag: "return",  h0: Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h0.h1, arg.h1.h1) }; default: return { tag: "return",  h0: "False" }; } break; default: return { tag: "return",  h0: "False" }; } };
const Lib_Elab_checkAutos_checkMeta = ( _, _1, _2, _3, _4, _5, _$$6 ) => (bouncer(Lib_Elab_REC_checkAutos_checkMeta, { tag: "Lib.Elab.checkAutos.checkMeta",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6 }));
const Lib_Elab_REC_checkAutos_checkMeta = ( arg ) => { switch (arg.h6.tag) { case "_:<_": switch (arg.h6.h2.tag) { case "VMeta": { const sc$$13 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h6.h2.h1, arg.h0); switch (sc$$13) { case "False": return { tag: "Lib.Elab.checkAutos.checkMeta",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; case "True": return { tag: "return",  h0: "True" }; } break; } default: return { tag: "Lib.Elab.checkAutos.checkMeta",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1 }; } break; case "Lin": return { tag: "return",  h0: "False" }; } };
const Prelude_for_ = ( t$$0, f$$1, _$$2, appf$$3, a$$4, b$$5, _$$6, _$$7 ) => (Prelude__$3C$2A$3E_(null, appf$$3)(null)(null)(Prelude_return(null, appf$$3)(null)(( _$$3 ) => ("MkUnit")))(Prelude_traverse(null, _$$2)(null)(null)(null)(appf$$3)(_$$7)(_$$6)));
const Lib_Elab_maybeCheck = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { switch (top.h5.h3) { case "NoCheck": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "CheckFirst": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_setMetaMode("NoCheck"), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, _$$0, ( _1 ) => (Lib_Elab_setMetaMode("CheckFirst"))))); case "CheckAll": return _$$0; } }));
const Lib_Elab_setMetaMode = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(tc.h5.h0, tc.h5.h1, tc.h5.h2, _$$0), tc.h6, tc.h7, tc.h8)))));
const Lib_Types_Solved = ( h0, h1, h2 ) => ({ tag: "Solved",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab__boundNames = ( _$$0 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h3), Prelude_filter(null, ( x ) => (Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_(x.h2, "Bound")), Prelude_zip(null, null, _$$0.h3, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0.h2)))));
const Lib_Types_Prelude_Eq$20Lib_Types_BD$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case "Defined": switch (_$$0) { case "Defined": return "True"; default: return "False"; } break; case "Bound": switch (_$$0) { case "Bound": return "True"; default: return "False"; } break; } };
const Lib_Elab_lams = ( _$$0, _$$1, _$$2 ) => { switch (_$$0) { case 0: return _$$2; default: { const x = (_$$0) - (1); switch (_$$1.tag) { case "_::_": return Lib_Types_Lam(Lib_Common_emptyFC, _$$1.h1, "Explicit", "Many", Lib_Elab_lams(x, _$$1.h2, _$$2)); case "Nil": return Lib_Types_Lam(Lib_Common_emptyFC, (("arg_") + (Prelude_showInt(Prelude_natToInt(x)))) + (""), "Explicit", "Many", Lib_Elab_lams(x, Prelude_Nil(null), _$$2)); } break; } } };
const Lib_Elab_rename = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "VLit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lit(_$$3.h0, _$$3.h1)); case "VErased": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Erased(_$$3.h0)); case "VU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_UU(_$$3.h0)); case "VLetRec": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h2), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, Prelude__$3A$3A_(null, _$$2, _$$1), (1) + (_$$2), _$$3.h3), ( val$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, Prelude__$3A$3A_(null, _$$2, _$$1), (1) + (_$$2), _$$3.h4), ( body$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_LetRec(_$$3.h0, _$$3.h1, ty$27, val$27, body$27)))))))); case "VLet": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h2), ( val$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, Prelude__$3A$3A_(null, _$$2, _$$1), (1) + (_$$2), _$$3.h3), ( body$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Let(_$$3.h0, _$$3.h1, val$27, body$27)))))); case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, _$$1, _$$2, _$$3.h4), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, _$$2, Prelude_Lin(null)), _$$3.h5.h0), _$$3.h5.h1), ( tmapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, Prelude__$3A$3A_(null, _$$2, _$$1), (1) + (_$$2), tmapp), ( scope$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Pi(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, ty$27, scope$27)))))))); case "VLam": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$3.h0, _$$2, Prelude_Lin(null)), _$$3.h4.h0), _$$3.h4.h1), ( tapp ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, Prelude__$3A$3A_(null, _$$2, _$$1), (1) + (_$$2), tapp), ( scope ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Lam(_$$3.h0, _$$3.h1, _$$3.h2, _$$3.h3, scope)))))); case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("rename Meta ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" spine ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, _$$3.h2, Prelude_Nil(null)))))) + (""))), ( _ ) => { const sc$$8 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$3.h1, _$$0); switch (sc$$8) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$3.h1), ( meta$27 ) => { switch (meta$27.tag) { case "Solved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("rename: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" is solved"))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(meta$27.h2, _$$3.h2), ( val$27 ) => (Lib_Elab_rename(_$$0, _$$1, _$$2, val$27))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("rename: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$3.h1))) + (" is unsolved"))), ( _1 ) => (Lib_Types_catchError(null, Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Meta(_$$3.h0, _$$3.h1), _$$3.h2), ( err ) => (Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_Postpone(_$$3.h0, _$$3.h1, Lib_Types_errorMsg(err))), eta)))))))); } }); case "True": return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$3.h0, "meta occurs check")), eta)))); } }); case "VCase": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$3.h0, "Case in solution")), eta)))); case "VRef": return Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Ref(_$$3.h0, _$$3.h1), _$$3.h2); case "VVar": { const sc$$7 = Prelude_findIndex$27(null, ( _$$11 ) => (Prelude_jsEq(null, _$$3.h1, _$$11)), _$$1); switch (sc$$7.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$3.h0, (((("scope/skolem thinger VVar ") + (Prelude_showInt(_$$3.h1))) + (" ren ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_Int$2Cshow, _$$1)))) + (""))), eta)))); case "Just": return Lib_Elab_renameSpine(_$$0, _$$1, _$$2, Lib_Types_Bnd(_$$3.h0, sc$$7.h1), _$$3.h2); } break; } } };
const Lib_Elab_renameSpine = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { switch (_$$4.tag) { case "_:<_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_rename(_$$0, _$$1, _$$2, _$$4.h2), ( xtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_renameSpine(_$$0, _$$1, _$$2, _$$3, _$$4.h1), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_App(Lib_Common_emptyFC, xs$27, xtm)))))); case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$3); } };
const Prelude_findIndex$27 = ( a$$0, _$$1, _$$2 ) => (Prelude_findIndex$27_go(a$$0, _$$1, _$$2, null, _$$2, 0));
const Prelude_findIndex$27_go = ( _, _1, _2, _3, _$$4, _$$5 ) => (bouncer(Prelude_REC_findIndex$27_go, { tag: "Prelude.findIndex'.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5 }));
const Prelude_REC_findIndex$27_go = ( arg ) => { switch (arg.h4.tag) { case "_::_": { const sc$$9 = arg.h1(arg.h4.h1); switch (sc$$9) { case "False": return { tag: "Prelude.findIndex'.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: (arg.h5) + (1) }; case "True": return { tag: "return",  h0: Prelude_Just(null, arg.h5) }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Common_Postpone = ( h0, h1, h2 ) => ({ tag: "Postpone",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_invert = ( _$$0, _$$1 ) => (Lib_Elab_invert_go(_$$0, _$$1, null, _$$1, Prelude_Nil(null)));
const Lib_Elab_invert_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Elab_REC_invert_go, { tag: "Lib.Elab.invert.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Elab_REC_invert_go = ( arg ) => { switch (arg.h3.tag) { case "_:<_": switch (arg.h3.h2.tag) { case "VVar": switch (arg.h3.h2.h2.tag) { case "Lin": { const sc$$12 = Prelude_elem(null, Prelude_Prelude_Eq$20Prim_Int, arg.h3.h2.h1, arg.h4); switch (sc$$12) { case "False": return { tag: "Lib.Elab.invert.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1,  h4: Prelude__$3A$3A_(null, arg.h3.h2.h1, arg.h4) }; case "True": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("") + (Prelude_showInt(arg.h3.h2.h1))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_Int$2Cshow, arg.h4)))) + (""))), ( _ ) => (Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h3.h2.h0, (("non-linear pattern: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, Prelude__$3C$3E$3E_(null, arg.h1, Prelude_Nil(null)))))) + (""))), eta)))))) }; } break; } default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("non-variable in pattern ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3.h2))) + (""))), eta)))) }; } break; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("non-variable in pattern ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3.h2))) + (""))), eta)))) }; } break; case "Lin": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_reverse(null)(arg.h4)) }; } };
const Prelude_Prelude_Eq$20Prim_Int$2C_$3D$3D_ = ( _$$0, _$$1 ) => (Prelude_jsEq(null, _$$0, _$$1));
const Prelude_Prelude_Eq$20Prim_Int = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_Int$2C_$3D$3D_(eta, eta1))));
const Lib_Types_Prelude_Show$20Lib_Types_MetaEntry$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "OutOfScope": return "OutOfScope"; case "Solved": return (((("Solved ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h2))) + (""); case "Unsolved": return (((((((((((("Unsolved ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(_$$0.h0))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h1))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(_$$0.h4))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$0.h3))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_BD$2Cshow, _$$0.h2.h3)))) + (" cs ")) + (Prelude_showInt(Prelude_natToInt(Prelude_length(null, _$$0.h5))))) + (""); } };
const Lib_Types_Prelude_Show$20Lib_Types_BD$2Cshow = ( _$$0 ) => { switch (_$$0) { case "Defined": return "def"; case "Bound": return "bnd"; } };
const Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow = ( _$$0 ) => { switch (_$$0) { case "AutoSolve": return "Auto"; case "User": return "User"; case "Normal": return "Normal"; } };
const Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_ = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_, { tag: "Prelude.Prelude.Eq Prelude.Nat,_==_",  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_ = ( arg ) => { switch (arg.h1) { case 0: switch (arg.h0) { case 0: return { tag: "return",  h0: "True" }; default: return { tag: "return",  h0: "False" }; } break; default: { const x = (arg.h1) - (1); switch (arg.h0) { case 0: return { tag: "return",  h0: "False" }; default: { const x1 = (arg.h0) - (1); return { tag: "Prelude.Prelude.Eq Prelude.Nat,_==_",  h0: x1,  h1: x }; break; } } break; } } };
const Prelude_Prelude_Ord$20Prelude_Nat$2Ccompare = ( _$$0, _$$1 ) => (bouncer(Prelude_REC_Prelude_Ord$20Prelude_Nat$2Ccompare, { tag: "Prelude.Prelude.Ord Prelude.Nat,compare",  h0: _$$0,  h1: _$$1 }));
const Prelude_REC_Prelude_Ord$20Prelude_Nat$2Ccompare = ( arg ) => { switch (arg.h1) { case 0: switch (arg.h0) { case 0: return { tag: "return",  h0: "EQ" }; default: return { tag: "return",  h0: "GT" }; } break; default: { const x = (arg.h1) - (1); switch (arg.h0) { case 0: return { tag: "return",  h0: "LT" }; default: { const x1 = (arg.h0) - (1); return { tag: "Prelude.Prelude.Ord Prelude.Nat,compare",  h0: x1,  h1: x }; break; } } break; } } };
const Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta_unifyPattern = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _$$10, _$$11 ) => { switch (_$$11.tag) { case "VVar": switch (_$$10.tag) { case "VVar": { const sc$$18 = Prelude_jsEq(null, _$$10.h1, _$$11.h1); switch (sc$$18) { case "False": { const sc$$19 = Prelude__$2C_(null, null, _$$10.h2, _$$11.h2); switch (sc$$19.h2.tag) { case "Lin": switch (sc$$19.h3.tag) { case "Lin": { const sc$$26 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$10.h1, _$$11.h1), "LT"); switch (sc$$26) { case "False": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_MkResult(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$11.h1, _$$10), Prelude_Nil(null)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_MkResult(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$10.h1, _$$11), Prelude_Nil(null)))); } break; } default: return Lib_Types_MkM(null, ( _10 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$10.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$10))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$11))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _10 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$10.h0, (((("Failed to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$10))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$11))) + (""))), eta)))); } break; } case "True": return Lib_Elab_unifySpine(_, _1, Prelude_jsEq(null, _$$10.h1, _$$11.h1), _$$10.h2, _$$11.h2); } break; } default: switch (_$$11.h2.tag) { case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_MkResult(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$11.h1, _$$10), Prelude_Nil(null)))); default: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11); } break; } break; default: switch (_$$10.tag) { case "VVar": switch (_$$10.h2.tag) { case "Lin": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_MkResult(Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$10.h1, _$$11), Prelude_Nil(null)))); default: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11); } break; default: return Lib_Elab_unify_unifyRest_unifyRef_unifyVar_unifyLam_unifyMeta(_, _1, _2, _3, _4, _5, _6, _7, _8, _$$10, _$$11); } break; } };
const Lib_Elab_forceMeta = ( _$$0 ) => { switch (_$$0.tag) { case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(_$$0.h1), ( meta ) => { switch (meta.tag) { case "Solved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_vappSpine(meta.h2, _$$0.h2), Lib_Elab_forceMeta); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VMeta(_$$0.h0, _$$0.h1, _$$0.h2)); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$0); } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "RUpdateRec": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "RUpdateRec", Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_UpdateClause$2Cshow, _$$0.h1)), Prelude__$3A$3A_(null, Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, _$$0.h2), Prelude_Nil(null)))))) + (")")); case "RAs": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "RAs", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); case "RWhere": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Where", Prelude__$3A$3A_(null, "FIXME", Prelude_Nil(null))))) + (")")); case "RIf": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "If", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude_Nil(null))))))) + (")")); case "RDo": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "DO", Prelude__$3A$3A_(null, "FIXME", Prelude_Nil(null))))) + (")")); case "RHole": return "?"; case "RImplicit": return "_"; case "RCase": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Case", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_RCaseAlt$2Cshow, _$$0.h2)), Prelude_Nil(null)))))) + (")")); case "RLit": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "RLit", Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1), Prelude_Nil(null))))) + (")")); case "RAnn": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "RAnn", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); case "RLet": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Let", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, " : ", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, " = ", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude__$3A$3A_(null, " in ", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h4), Prelude_Nil(null))))))))))) + (")")); case "RPi": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Pi", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude_Nil(null))))))) + (")")); case "RU": return "U"; case "RApp": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "App", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h3), Prelude_Nil(null))))))) + (")")); case "RLam": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Lam", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); case "RVar": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "RVar", Prelude__$3A$3A_(null, _$$0.h1, Prelude_Nil(null))))) + (")")); } };
const Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow = ( _$$0 ) => (("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "BI", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3), Prelude_Nil(null))))))) + (")")));
const Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow = ( _$$0 ) => { switch (_$$0) { case "Auto": return "Auto"; case "Explicit": return "Explicit"; case "Implicit": return "Implicit"; } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_RCaseAlt$2Cshow = ( _$$0 ) => (("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "MkAlt", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h0), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude_Nil(null)))))) + (")")));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw = Prelude_MkShow(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow);
const Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow = ( a$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "Nothing": return "Nothing"; case "Just": return "Just {show a}"; } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_UpdateClause$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "ModifyField": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "ModifyField", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); case "AssignField": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "AssignField", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); } };
const Lib_Elab_insert = ( ctx$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta(_$$2), ( ty$27 ) => { switch (ty$27.tag) { case "VPi": switch (ty$27.h2) { case "Auto": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(ctx$$0, Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), ty$27.h4, "AutoSolve"), ( m ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("INSERT Auto ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), ctx$$0.h2), m))), Prelude_Lin(null)))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty$27.h4))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("TM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), ctx$$0.h2), _$$1))), Prelude_Lin(null)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(ctx$$0.h1, m), ( mv ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, mv, ty$27.h5.h0), ty$27.h5.h1), ( bapp ) => (Lib_Elab_insert(ctx$$0, Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), _$$1, m), bapp))))))))))); case "Implicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(ctx$$0, Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), ty$27.h4, "Normal"), ( m ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("INSERT ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), ctx$$0.h2), m))), Prelude_Lin(null)))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty$27.h4))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("TM ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), ctx$$0.h2), _$$1))), Prelude_Lin(null)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(ctx$$0.h1, m), ( mv ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, mv, ty$27.h5.h0), ty$27.h5.h1), ( bapp ) => (Lib_Elab_insert(ctx$$0, Lib_Types_App(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(_$$1), _$$1, m), bapp))))))))))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1, ty$27)); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$1, ty$27)); } }));
const Lib_Elab_freshMeta = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("fresh meta ") + (Prelude_showInt(top.h5.h2))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$2))) + (" (")) + (Lib_Types_Prelude_Show$20Lib_Types_MetaKind$2Cshow(_$$3))) + (")"))), ( _ ) => { const qn = Lib_Common_QN(top.h3, (("$m") + (Prelude_showInt(top.h5.h2))) + ("")); const newmeta = Lib_Types_Unsolved(_$$1, qn, _$$0, _$$2, _$$3, Prelude_Nil(null)); let autos; switch (_$$3) { case "AutoSolve": { autos = Prelude__$3A$3A_(null, qn, top.h5.h1); break; } default: { autos = top.h5.h1; break; } } return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, Lib_Types_MC(Data_SortedMap_updateMap(null, null, qn, newmeta, top.h5.h0), autos, (1) + (top.h5.h2), top.h5.h3), tc.h6, tc.h7, tc.h8)))), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Elab_freshMeta_applyBDs(_$$0, _$$1, _$$2, _$$3, null, 0, Lib_Types_Meta(_$$1, qn), _$$0.h3)))); }))));
const Lib_Elab_freshMeta_applyBDs = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => (bouncer(Lib_Elab_REC_freshMeta_applyBDs, { tag: "Lib.Elab.freshMeta.applyBDs",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6,  h7: _$$7 }));
const Lib_Elab_REC_freshMeta_applyBDs = ( arg ) => { switch (arg.h7.tag) { case "_::_": switch (arg.h7.h1) { case "Defined": return { tag: "Lib.Elab.freshMeta.applyBDs",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (1) + (arg.h5),  h6: arg.h6,  h7: arg.h7.h2 }; case "Bound": return { tag: "return",  h0: Lib_Types_App(Lib_Common_emptyFC, Lib_Elab_freshMeta_applyBDs(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, (1) + (arg.h5), arg.h6, arg.h7.h2), Lib_Types_Bnd(Lib_Common_emptyFC, arg.h5)) }; } break; case "Nil": return { tag: "return",  h0: arg.h6 }; } };
const Lib_Elab_infer = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "RUpdateRec": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, "I can't infer record updates")), eta)))); case "RAs": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, "@ can only be used in patterns")), eta)))); case "RImplicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal"), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, ty), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h0, vty, "Normal"), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, tm, vty)))))))); case "RLit": switch (_$$1.h1.tag) { case "LChar": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_primType(_$$1.h0, Lib_Elab_charType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Lit(_$$1.h0, Lib_Types_LChar(_$$1.h1.h0)), ty)))); case "LInt": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_primType(_$$1.h0, Lib_Elab_intType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Lit(_$$1.h0, Lib_Types_LInt(_$$1.h1.h0)), ty)))); case "LString": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_primType(_$$1.h0, Lib_Elab_stringType), ( ty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Lit(_$$1.h0, Lib_Types_LString(_$$1.h1.h0)), ty)))); } break; case "RAnn": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(_$$1.h0)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, ty), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h1, vty), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, tm, vty)))))))); case "RLet": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(Lib_Common_emptyFC)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, ty$27), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h3, vty), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, v$27), ( vv ) => { const ctx$27 = Lib_Types_define(_$$0, _$$1.h1, vv, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(ctx$27, _$$1.h4), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Let(_$$1.h0, _$$1.h1, v$27, $$sc.h2), $$sc.h3)))); }))))))); case "RPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, Lib_Types_VU(_$$1.h1.h0)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, ty$27), ( vty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_extend(_$$0, _$$1.h1.h1, vty$27), _$$1.h3, Lib_Types_VU(_$$1.h1.h0)), ( ty2$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Pi(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, ty$27, ty2$27), Lib_Types_VU(_$$1.h1.h0))))))))); case "RU": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_UU(_$$1.h0), Lib_Types_VU(_$$1.h0))); case "RApp": switch (_$$1.h3) { case "Auto": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, "Auto", Prelude__$2C_(null, null, $$sc.h2, $$sc.h3))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { switch (tty$27.tag) { case "VPi": { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, tty$27.h4, tty$27.h5)); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal"), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal")), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, "Many", a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); case "Explicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_insert(_$$0, $$sc.h2, $$sc.h3), ( $$sc1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, $$sc1.h2, $$sc1.h3))))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { switch (tty$27.tag) { case "VPi": { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, tty$27.h4, tty$27.h5)); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal"), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal")), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, "Many", a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); case "Implicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(_$$0, _$$1.h1), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, "Implicit", Prelude__$2C_(null, null, $$sc.h2, $$sc.h3))))), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_forceMeta($$sc.h3.h3), ( tty$27 ) => { switch (tty$27.tag) { case "VPi": { const sc$$24 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(tty$27.h2, $$sc.h2); switch (sc$$24) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0, (((("IcitMismatch ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow($$sc.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(tty$27.h2))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, tty$27.h4, tty$27.h5)); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((("unify PI for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(tty$27))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal"), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_MkClosure(_$$0.h1, eta)), Lib_Elab_freshMeta(Lib_Types_extend(_$$0, ":ins", a), _$$1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal")), ( b ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_unifyCatch(_$$1.h0, _$$0, tty$27, Lib_Types_VPi(_$$1.h0, ":ins", $$sc.h2, "Many", a, b)), ( _1 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, a, b)))))))))); } }), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h2, $$sc1.h2), ( u ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, u), ( u$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, u$27, $$sc1.h3.h0), $$sc1.h3.h1), ( bappu ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_App(_$$1.h0, $$sc.h3.h2, u), bappu)))))))))))); } break; case "RLam": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_freshMeta(_$$0, _$$1.h1.h0, Lib_Types_VU(Lib_Common_emptyFC), "Normal"), ( eta ) => (Lib_Eval_eval(_$$0.h1, eta))), ( a ) => { const ctx$27 = Lib_Types_extend(_$$0, _$$1.h1.h1, a); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_infer(ctx$27, _$$1.h2), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("make lam for ") + (_$$1.h1.h1)) + (" scope ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0.h2), $$sc.h2))), Prelude_Lin(null)))) + (" : ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote((1) + (_$$0.h0), $$sc.h3), ( tyb ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Lam(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, $$sc.h2), Lib_Types_VPi(_$$1.h1.h0, _$$1.h1.h1, _$$1.h1.h2, _$$1.h1.h3, a, Lib_Types_MkClosure(_$$0.h1, tyb)))))))))); }); case "RVar": return Lib_Elab_infer_go(_$$0, _$$1, _$$1.h0, _$$1.h1, null, 0, _$$0.h2); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1), (("Implement infer ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$1))) + (""))), eta)))); } };
const Lib_Elab_infer_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_Elab_REC_infer_go, { tag: "Lib.Elab.infer.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_Elab_REC_infer_go = ( arg ) => { switch (arg.h6.tag) { case "_::_": { const sc$$14 = Prelude_jsEq(null, arg.h6.h1.h2, arg.h3); switch (sc$$14) { case "False": return { tag: "Lib.Elab.infer.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: (arg.h5) + (1),  h6: arg.h6.h2 }; case "True": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Bnd(arg.h2, arg.h5), arg.h6.h1.h3)) }; } break; } case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$9 = Lib_TopContext_lookupRaw(arg.h3, top); switch (sc$$9.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h2, (("") + (arg.h3)) + (" not in scope"))), eta)))); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("lookup ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$9.h1.h1))) + (" as ")) + (Lib_Types_Prelude_Show$20Lib_Types_Def$2Cshow(sc$$9.h1.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$9.h1.h2), ( vty ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Lib_Types_Ref(arg.h2, sc$$9.h1.h1), vty)))))); } }) }; } };
const Lib_Types_Prelude_Show$20Lib_Types_Def$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "PrimFn": return (((((("PrimFn ") + (_$$0.h0)) + (" ")) + (Prelude_showInt(Prelude_natToInt(_$$0.h1)))) + (" ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, _$$0.h2)))) + (""); case "PrimTCon": return "PrimTCon"; case "Fn": return (("Fn ") + (Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow(_$$0.h0))) + (""); case "DCon": return (((((("DCon ") + (Prelude_showInt(_$$0.h1))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h2))) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_ConInfo$2Cshow(_$$0.h0))) + (""); case "TCon": return (("TCon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, _$$0.h1)))) + (""); case "Axiom": return "axiom"; } };
const Lib_Types_Prelude_Show$20Lib_Types_ConInfo$2Cshow = ( _$$0 ) => { switch (_$$0) { case "EnumCon": return "[E]"; case "ZeroCon": return "[Z]"; case "SuccCon": return "[S]"; case "NormalCon": return ""; } };
const Lib_Types_extend = ( _$$0, _$$1, _$$2 ) => (Lib_Types_MkCtx((1) + (_$$0.h0), Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, _$$0.h0, Prelude_Lin(null)), _$$0.h1), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$1, _$$2), _$$0.h2), Prelude__$3A$3A_(null, "Bound", _$$0.h3), _$$0.h4));
const Lib_Types_MkCtx = ( h0, h1, h2, h3, h4 ) => ({ tag: "MkCtx",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_ = ( _$$0, _$$1 ) => { switch (_$$1) { case "Auto": switch (_$$0) { case "Auto": return "True"; default: return "False"; } break; case "Explicit": switch (_$$0) { case "Explicit": return "True"; default: return "False"; } break; case "Implicit": switch (_$$0) { case "Implicit": return "True"; default: return "False"; } break; } };
const Lib_Types_define = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_MkCtx((1) + (_$$0.h0), Prelude__$3A$3A_(null, _$$2, _$$0.h1), Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$1, _$$3), _$$0.h2), Prelude__$3A$3A_(null, "Defined", _$$0.h3), _$$0.h4));
const Lib_Elab_stringType = Lib_Common_QN(Lib_Common_primNS, "String");
const Lib_Elab_primType = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookup(_$$1, top); switch (sc$$3.tag) { case "Just": switch (sc$$3.h1.h3.tag) { case "PrimTCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_VRef(_$$0, sc$$3.h1.h1, Prelude_Lin(null))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, (("Primitive type ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" not in scope"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, (("Primitive type ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$1))) + (" not in scope"))), eta)))); } }));
const Lib_Elab_intType = Lib_Common_QN(Lib_Common_primNS, "Int");
const Lib_Types_LChar = ( h0 ) => ({ tag: "LChar",  h0: h0 });
const Lib_Elab_charType = Lib_Common_QN(Lib_Common_primNS, "Char");
const Lib_Eval_prvalCtx = ( ctx$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(ctx$$0.h0, _$$1), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), ctx$$0.h2), tm))), Prelude_Lin(null))))));
const Lib_Types_logM = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$0, top.h6), "GT")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, _$$1, ( msg ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn(msg)))))))));
const Lib_Elab_MkProb = ( h0, h1 ) => ({ tag: "MkProb",  h0: h0,  h1: h1 });
const Lib_Elab_buildTree = ( _$$0, _$$1 ) => { switch (_$$1.h0.tag) { case "_::_": switch (_$$1.h0.h1.h2.tag) { case "_::_": switch (_$$1.h1.tag) { case "VPi": { const l = Prelude_length$27(null, _$$0.h1); const nm = Lib_Elab_fresh(_$$0, _$$1.h1.h1); const ctx$27 = Lib_Types_extend(_$$0, nm, _$$1.h1.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_introClause(nm, _$$1.h1.h2, eta)), _$$1.h0), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$1.h0.h1.h0, l, Prelude_Lin(null)), _$$1.h1.h5.h0), _$$1.h1.h5.h1), ( vb ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Types_Lam(_$$1.h0.h1.h0, nm, _$$1.h1.h2, _$$1.h1.h3, eta)), Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, vb))))))); break; } default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0.h1.h0, (("Extra pattern variables ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow, _$$1.h0.h1.h2)))) + (""))), eta)))); } break; case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("buildTree ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$1.h0.h1.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$1.h0.h1.h3))) + (""))), ( _ ) => { const sc$$13 = Lib_Elab_findSplit(_$$1.h0.h1.h1); switch (sc$$13.tag) { case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((((((("SPLIT on ") + (sc$$13.h1.h2)) + (" because ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (" ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3)))) + (""))), ( _1 ) => { const sc$$21 = Lib_Elab_lookupName(_$$0, sc$$13.h1.h2); switch (sc$$21.tag) { case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_unlet(_$$0.h1, sc$$21.h1.h3), ( eta ) => (Lib_Eval_forceType(_$$0.h1, eta))), ( scty$27 ) => { switch (scty$27.tag) { case "VMeta": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_lookupMeta(scty$27.h1), ( meta ) => { switch (meta.tag) { case "OutOfScope": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, scty$27); case "Solved": return Lib_Eval_forceType(_$$0.h1, scty$27); case "Unsolved": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos, ( _2 ) => (Lib_Eval_forceType(_$$0.h1, scty$27))); } }), ( scty$271 ) => { switch (sc$$13.h1.h3.tag) { case "PatLit": { const tyname = Lib_Elab_litTyName(sc$$13.h1.h3.h1); switch (scty$271.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(scty$271.h1, tyname)), ( _2 ) => (Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))); } break; } case "PatCon": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("EXP ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_getConstructors(_$$0, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), scty$271), ( cons ) => { const matched = Lib_Elab_matchedConstructors(sc$$13.h1.h2, _$$1.h0); const sc$$39 = Prelude_partition(null, ( _$$5 ) => (Prelude_elem(null, Lib_Common_Prelude_Eq$20Lib_Common_QName, _$$5.h2, matched)), cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_filterM(null, ( eta ) => (Lib_Elab_checkCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$39.h3), ( miss$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((((("CONS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), cons))))) + (" matched ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, matched)))) + (" miss ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), sc$$39.h3)))) + (" miss' ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), miss$27)))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$39.h2), ( alts ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("GOTALTS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Lib_Types_Prelude_Show$20Lib_Types_CaseAlt, eta)), alts)))) + (""))), ( _4 ) => { const alts$27 = Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), alts); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, alts$27), 0), ( _5 ) => (Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (("no alts for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), eta)))))), ( _5 ) => { switch (miss$27.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), alts))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildDefault(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), miss$27)), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, alts$27, Prelude__$3A$3A_(null, $$sc, Prelude_Nil(null))))))); } }); }))))))); }))); default: return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), (("Internal error - tried to split on ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (""))), eta)))); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, scty$27), ( scty$271 ) => { switch (sc$$13.h1.h3.tag) { case "PatLit": { const tyname = Lib_Elab_litTyName(sc$$13.h1.h3.h1); switch (scty$271.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(scty$271.h1, tyname)), ( _2 ) => (Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (((("expected ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" and got ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(tyname))) + (""))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildLitCases(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, sc$$21.h1.h3), ( alts ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, alts)))))); } break; } case "PatCon": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("EXP ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$21.h1.h3))) + (" -> ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_getConstructors(_$$0, Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), scty$271), ( cons ) => { const matched = Lib_Elab_matchedConstructors(sc$$13.h1.h2, _$$1.h0); const sc$$39 = Prelude_partition(null, ( _$$5 ) => (Prelude_elem(null, Lib_Common_Prelude_Eq$20Lib_Common_QName, _$$5.h2, matched)), cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_filterM(null, ( eta ) => (Lib_Elab_checkCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$39.h3), ( miss$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((((("CONS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), cons))))) + (" matched ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, matched)))) + (" miss ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), sc$$39.h3)))) + (" miss' ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName, Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Tm, eta))), eta)), miss$27)))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase(_$$0, _$$1, sc$$13.h1.h2, scty$271, eta)), sc$$39.h2), ( alts ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("GOTALTS ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Lib_Types_Prelude_Show$20Lib_Types_CaseAlt, eta)), alts)))) + (""))), ( _4 ) => { const alts$27 = Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), alts); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, alts$27), 0), ( _5 ) => (Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$13.h1.h3.h0, (("no alts for ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(scty$271))) + (""))), eta)))))), ( _5 ) => { switch (miss$27.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), alts))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildDefault(_$$0, _$$1, sc$$13.h1.h3.h0, sc$$13.h1.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), miss$27)), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_Case(sc$$13.h1.h3.h0, sc$$21.h1.h2, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, alts$27, Prelude__$3A$3A_(null, $$sc, Prelude_Nil(null))))))); } }); }))))))); }))); default: return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(sc$$13.h1.h3), (("Internal error - tried to split on ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(sc$$13.h1.h3))) + (""))), eta)))); } }); } }); default: return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h0.h1.h0, (("Internal Error: can't find ") + (sc$$13.h1.h2)) + (" in environment"))), eta)))); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((("checkDone ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$1.h0.h1.h1)))) + (""))), ( _1 ) => (Lib_Elab_checkDone(_$$0, _$$1.h0.h1.h1, _$$1.h0.h1.h3, _$$1.h1))); } }); } break; case "Nil": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "no clauses")), eta)))); } };
const Lib_Elab_checkDone = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Elab_REC_checkDone, { tag: "Lib.Elab.checkDone",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Elab_REC_checkDone = ( arg ) => { switch (arg.h1.tag) { case "_::_": switch (arg.h1.h1.h3.tag) { case "PatWild": return { tag: "Lib.Elab.checkDone",  h0: arg.h0,  h1: arg.h1.h2,  h2: arg.h2,  h3: arg.h3 }; case "PatVar": { const ctx = Lib_Types_MkCtx(arg.h0.h0, arg.h0.h1, Lib_Elab_checkDone_rename(arg.h0, arg.h1, arg.h2, arg.h3, arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h1.h0, arg.h1.h1.h1, arg.h1.h1.h2, arg.h1.h1.h3, arg.h1.h1.h3.h0, arg.h1.h1.h3.h1, arg.h1.h1.h3.h2, null, arg.h0.h2), arg.h0.h3, arg.h0.h4); return { tag: "Lib.Elab.checkDone",  h0: ctx,  h1: arg.h1.h2,  h2: arg.h2,  h3: arg.h3 }; break; } default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(arg.h1.h1.h3), (((("stray constraint ") + (arg.h1.h1.h2)) + (" /? ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(arg.h1.h1.h3))) + (""))), eta)))) }; } break; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("DONE-> check body ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h2))) + (" at ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h3))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_logM(2, Lib_Elab_showCtx(arg.h0)), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, arg.h0.h1, ( val ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(Prelude_length$27(null, arg.h0.h1), val), ( ty ) => (Lib_Eval_eval(arg.h0.h1, ty))))), ( env$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, arg.h0.h2, ( $$case ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(Prelude_length$27(null, env$27), $$case.h3), ( nty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(env$27, nty), ( ty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, $$case.h2, ty$27)))))))), ( types$27 ) => { const ctx = Lib_Types_MkCtx(arg.h0.h0, env$27, types$27, arg.h0.h3, arg.h0.h4); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ("AFTER")), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_logM(2, Lib_Elab_showCtx(ctx)), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(Prelude_length$27(null, ctx.h1), arg.h3), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(ctx.h1, ty), ( ty1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("check at ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(ty1))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(ctx, arg.h2, ty1), ( got ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("DONE<- got ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), ctx.h2), got))), Prelude_Lin(null)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, got))))))))))))))); }))))))) }; } };
const Lib_Elab_showCtx = ( _$$0 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$5 ) => (Prelude_joinBy("\n", Prelude_reverse(null)(_$$5))), Lib_Elab_showCtx_isVar_go(_$$0, null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0.h2), 0, Prelude_reverse(null)(Prelude_zip(null, null, _$$0.h1, _$$0.h2)), Prelude_Nil(null))));
const Lib_Elab_showCtx_isVar_go = ( _, _1, _2, _$$3, _$$4, _$$5, _$$6 ) => { switch (_$$5.tag) { case "_::_": { const sc$$18 = Lib_Elab_showCtx_isVar(_, _1, _$$4, _$$5.h1.h2); switch (sc$$18) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h2), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( tty ) => (Lib_Elab_showCtx_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_(null, (((((("  ") + (_$$5.h1.h3.h2)) + (" = ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tm))), Prelude_Lin(null)))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tty))), Prelude_Lin(null)))) + (""), _$$6)))))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( tty ) => (Lib_Elab_showCtx_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_(null, (((("  ") + (_$$5.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, tty))), Prelude_Lin(null)))) + (""), _$$6)))); } break; } case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$6); } };
const Lib_Elab_showCtx_isVar = ( _, _1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "VVar": switch (_$$3.h2.tag) { case "Lin": return Prelude_jsEq(null, _$$2, _$$3.h1); default: return "False"; } break; default: return "False"; } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "PatLit": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PatLit", Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$0.h1), Prelude_Nil(null))))) + (")")); case "PatWild": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PatWild", Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude_Nil(null))))) + (")")); case "PatCon": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PatCon", Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow, _$$0.h3)), Prelude__$3A$3A_(null, Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Prelude_Prelude_Show$20Prim_String, _$$0.h4), Prelude_Nil(null)))))))) + (")")); case "PatVar": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PatVar", Prelude__$3A$3A_(null, Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, _$$0.h2, Prelude_Nil(null)))))) + (")")); } };
const Prelude_Prelude_Show$20Prim_String = Prelude_MkShow(null, Prelude_Prelude_Show$20Prim_String$2Cshow);
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case "PatLit": return _$$0.h0; case "PatWild": return _$$0.h0; case "PatCon": return _$$0.h0; case "PatVar": return _$$0.h0; } };
const Lib_Elab_checkDone_rename = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15 ) => { switch (_$$15.tag) { case "_::_": { const sc$$23 = Prelude_jsEq(null, _$$15.h1.h2, _9); switch (sc$$23) { case "False": return Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$15.h1.h2, _$$15.h1.h3), Lib_Elab_checkDone_rename(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15.h2)); case "True": return Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _13, _$$15.h1.h3), _$$15.h2); } break; } case "Nil": return Prelude_Nil(null); } };
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern = Prelude_MkShow(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow);
const Lib_Elab_buildDefault = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { const defclauses = Prelude_filter(null, ( eta ) => (Lib_Elab_buildDefault_isDefault(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, defclauses), 0), ( _ ) => (Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$2, (((("missing cases ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, _$$4)))) + (" on ")) + (_$$3)) + (""))), eta)))))), ( _ ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, Lib_Types_CaseDefault, Lib_Elab_buildTree(_$$0, Lib_Elab_MkProb(defclauses, _$$1.h1))))); };
const Lib_Elab_buildDefault_isDefault = ( _, _1, _2, _3, _4, _5, _$$6 ) => { const sc$$7 = Prelude_find(null, ( _$$5 ) => (Prelude_jsEq(null, _3, _$$5.h2)), _$$6.h1); switch (sc$$7.tag) { case "Nothing": return "True"; case "Just": switch (sc$$7.h1.h3.tag) { case "PatWild": return "True"; case "PatVar": return "True"; default: return "False"; } break; } };
const Lib_Types_Prelude_Show$20Lib_Types_CaseAlt$2Cshow = Lib_Types_showCaseAlt;
const Lib_Types_Prelude_Show$20Lib_Types_CaseAlt = Prelude_MkShow(null, Lib_Types_Prelude_Show$20Lib_Types_CaseAlt$2Cshow);
const Lib_Elab_buildCase = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((((("CASE ") + (_$$2)) + (" match ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2), _$$4.h3.h3))), Prelude_Lin(null)))) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), _$$4.h3.h3), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_extendPi(_$$0, vty, Prelude_Lin(null), Prelude_Lin(null)), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _1 ) => ((((("unify dcon cod with scrut\n  ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + ("\n  ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_catchError(null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_Just(null, eta)), Lib_Elab_unify($$sc.h2.h1, "UPattern", $$sc.h3.h2, _$$3)), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg(err))) + (""))), ( _2 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))))), ( $$sc1 ) => { switch ($$sc1.tag) { case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("scrut ") + (_$$2)) + (" constrained to ")) + (Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Lib_Types_Prelude_Show$20Lib_Types_Val, Lib_Elab_lookupDef(_$$0, _$$2)))) + (""))), ( _2 ) => { switch (_$$3.tag) { case "VRef": { const sc$$44 = Lib_Elab_lookupDef(_$$0, _$$2); switch (sc$$44.tag) { case "Just": switch (sc$$44.h1.tag) { case "VRef": { const sc$$50 = Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$44.h1.h1, _$$4.h2)); switch (sc$$50) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((("case ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" dotted ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$44.h1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_Prelude_Eq$20Prelude_Nat$2C_$3D$3D_(Prelude_length(null, $$sc.h3.h3.h2), Data_SnocList_snoclen(null, sc$$44.h1.h2))), ( _4 ) => (Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (((("") + (Prelude_showInt(Prelude_natToInt(Prelude_length(null, $$sc.h3.h3.h2))))) + (" vars /= ")) + (Prelude_showInt(Prelude_natToInt(Data_SnocList_snoclen(null, sc$$44.h1.h2))))) + (""))), eta)))))), ( _4 ) => { const lvl = (Prelude_length$27(null, $$sc.h2.h1)) - (Prelude_length$27(null, $$sc.h3.h3.h2)); const scons = Lib_Elab_buildCase_constrainSpine(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, lvl, Prelude__$3C$3E$3E_(null, sc$$44.h1.h2, Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateContext($$sc.h2, scons), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow, $$sc.h3.h3.h2)))) + (") clauses were"))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _7 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => ("and now:")), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, clauses, ( x ) => (Lib_Types_log(2, ( _9 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, clauses), 0), ( _10 ) => (Lib_Types_MkM(null, ( _11 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))); }))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because ")) + (_$$2)) + (" forced to ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$44.h1))) + (""))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); } break; } default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_tryError(null, Lib_Elab_unify($$sc.h2.h1, "UPattern", $$sc.h3.h2, _$$3)), ( $$sc2 ) => { switch ($$sc2.tag) { case "Right": { const sc$$52 = Prelude_findIndex$27(null, ( _$$5 ) => (Prelude_jsEq(null, _$$2, _$$5.h2)), $$sc.h2.h2); switch (sc$$52.tag) { case "Nothing": return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (("") + (_$$2)) + (" not is scope?"))), eta)))); case "Just": { const lvl = ((Prelude_length$27(null, $$sc.h2.h1)) - (sc$$52.h1)) - (1); const scon = Prelude__$2C_(null, null, lvl, Lib_Types_VRef(_$$0.h4, _$$4.h2, $$sc.h3.h3.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((("scty ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("UNIFY results ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc2.h2.h0)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("before types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc.h2.h2)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((("before env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, $$sc.h2.h1)))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _7 ) => ((("SC CONSTRAINT: ") + (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, scon))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateContext($$sc.h2, Prelude__$3A$3A_(null, scon, $$sc2.h2.h0)), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => ((("context types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), ctx$27.h2)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _9 ) => ((("context env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, ctx$27.h1)))) + (""))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _10 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _11 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow, $$sc.h3.h3.h2)))) + (") clauses were"))), ( _11 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _12 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _12 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _13 ) => ("and now:")), ( _13 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, clauses, ( x ) => (Lib_Types_log(2, ( _14 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _14 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, clauses), 0), ( _15 ) => (Lib_Types_MkM(null, ( _16 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _15 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))))))))))))))))); break; } } break; } case "Left": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); } }); } break; default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_tryError(null, Lib_Elab_unify($$sc.h2.h1, "UPattern", $$sc.h3.h2, _$$3)), ( $$sc2 ) => { switch ($$sc2.tag) { case "Right": { const sc$$50 = Prelude_findIndex$27(null, ( _$$5 ) => (Prelude_jsEq(null, _$$2, _$$5.h2)), $$sc.h2.h2); switch (sc$$50.tag) { case "Nothing": return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (("") + (_$$2)) + (" not is scope?"))), eta)))); case "Just": { const lvl = ((Prelude_length$27(null, $$sc.h2.h1)) - (sc$$50.h1)) - (1); const scon = Prelude__$2C_(null, null, lvl, Lib_Types_VRef(_$$0.h4, _$$4.h2, $$sc.h3.h3.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((("scty ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((("UNIFY results ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc2.h2.h0)))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("before types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), $$sc.h2.h2)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((("before env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, $$sc.h2.h1)))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _7 ) => ((("SC CONSTRAINT: ") + (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_Int, Lib_Types_Prelude_Show$20Lib_Types_Val, scon))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateContext($$sc.h2, Prelude__$3A$3A_(null, scon, $$sc2.h2.h0)), ( ctx$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => ((("context types: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Types_Prelude_Show$20Lib_Types_Val, eta)), ctx$27.h2)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _9 ) => ((("context env: ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, ctx$27.h1)))) + (""))), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _10 ) => ((((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" ty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow($$sc.h3.h2))) + (" scty ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _11 ) => ((((("(dcon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (") (vars ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow, $$sc.h3.h3.h2)))) + (") clauses were"))), ( _11 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$1.h0, ( x ) => (Lib_Types_log(2, ( _12 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _12 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), eta)), Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, null, null, null, _$$3.h1, $$sc.h3.h3.h2, eta)), _$$1.h0)), ( clauses ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _13 ) => ("and now:")), ( _13 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, clauses, ( x ) => (Lib_Types_log(2, ( _14 ) => ((("    ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow(x))) + (""))))), ( _14 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, clauses), 0), ( _15 ) => (Lib_Types_MkM(null, ( _16 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" splitting ")) + (_$$2)) + (""))), eta)))))), ( _15 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Lib_Types_CaseCons(_$$4.h2, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Elab_buildCase_constrainSpine_getName(_$$0, _$$1, _$$2, _$$3, _$$4, _$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, _$$4.h3.h0, _$$4.h3.h1, _$$4.h3.h2, _$$4.h3.h3, null, null, eta)), $$sc.h3.h3.h2), tm))))))))))))))))))))))))))))))))))); break; } } break; } case "Left": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _3 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))); } }); } break; } default: return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(_$$3), (("case split on non-inductive ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$3))) + (""))), eta)))); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }))))))))));
const Lib_Elab_buildCase_constrainSpine_getName = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _$$15 ) => (_$$15.h0);
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Clause$2Cshow = ( _$$0 ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Common_Prelude_Show$20Lib_Common_FC, Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_MkShow(null, ( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_Prelude_Show$20Prim_String, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern, eta)), _$$2)))), Prelude_MkShow(null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Prelude_MkShow(null, ( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow, _$$2)))), Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta))), eta))), Prelude__$2C_(null, null, _$$0.h0, Prelude__$2C_(null, null, _$$0.h1, Prelude__$2C_(null, null, _$$0.h2, _$$0.h3)))));
const Lib_Common_Prelude_Show$20Lib_Common_FC = Prelude_MkShow(null, Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow);
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint_rewriteClause = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _$$18, _$$19, _$$20 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _$$18, _$$19, _$$20.h1, Prelude_Nil(null)), ( $$sc ) => { switch ($$sc.tag) { case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Lib_Syntax_MkClause(_$$20.h0, $$sc.h1, _$$20.h2, _$$20.h3))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }));
const Lib_Syntax_MkClause = ( h0, h1, h2, h3 ) => ({ tag: "MkClause",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _$$17, _$$18, _$$19, _$$20 ) => (bouncer(Lib_Elab_REC_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint, { tag: "Lib.Elab.buildCase.constrainSpine.getName.makeConstr.rewriteConstraint",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _8,  h9: _9,  h10: _10,  h11: _11,  h12: _12,  h13: _13,  h14: _14,  h15: _15,  h16: _16,  h17: _$$17,  h18: _$$18,  h19: _$$19,  h20: _$$20 }));
const Lib_Elab_REC_buildCase_constrainSpine_getName_makeConstr_rewriteConstraint = ( arg ) => { switch (arg.h19.tag) { case "_::_": { const sc$$28 = Prelude_jsEq(null, arg.h19.h1.h2, arg.h2); switch (sc$$28) { case "False": return { tag: "Lib.Elab.buildCase.constrainSpine.getName.makeConstr.rewriteConstraint",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: arg.h12,  h13: arg.h13,  h14: arg.h14,  h15: arg.h15,  h16: arg.h16,  h17: arg.h17,  h18: arg.h18,  h19: arg.h19.h2,  h20: Prelude__$3A$3A_(null, arg.h19.h1, arg.h20) }; case "True": switch (arg.h19.h1.h3.tag) { case "PatLit": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h19.h1.h3.h0, (("Literal ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(arg.h19.h1.h3.h1))) + (" in constructor split"))), eta)))) }; case "PatWild": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Prelude__$3A$3A_(null, arg.h19.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h19.h2, arg.h20)))) }; case "PatCon": { const sc$$35 = Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(arg.h19.h1.h3.h2, arg.h7); switch (sc$$35) { case "False": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$37 = Lib_TopContext_lookup(arg.h19.h1.h3.h2, top); switch (sc$$37.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h19.h1.h3.h0, (("Internal Error: DCon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h19.h1.h3.h2))) + (" not found"))), eta)))); case "Just": switch (sc$$37.h1.h3.tag) { case "DCon": { const sc$$48 = Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$37.h1.h3.h2, arg.h17)); switch (sc$$48) { case "False": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); case "True": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h19.h1.h3.h0, (((("Constructor is ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$37.h1.h3.h2))) + (" expected ")) + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h17))) + (""))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h19.h1.h3.h0, (("Internal Error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h19.h1.h3.h2))) + (" is not a DCon"))), eta)))); } break; } }) }; case "True": switch (arg.h19.h1.h3.h4.tag) { case "Nothing": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h10, arg.h11, arg.h12, arg.h13, arg.h14, arg.h15, arg.h19.h1.h3.h0, arg.h18, arg.h19.h1.h3.h3), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, rest, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h19.h2, arg.h20)))))) }; case "Just": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h10, arg.h11, arg.h12, arg.h13, arg.h14, arg.h15, arg.h19.h1.h3.h0, arg.h18, arg.h19.h1.h3.h3), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h2, Lib_Syntax_PatVar(arg.h19.h1.h3.h0, arg.h19.h1.h3.h1, arg.h19.h1.h3.h4.h1)), Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, rest, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h19.h2, arg.h20))))))) }; } break; } break; } case "PatVar": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Prelude__$3A$3A_(null, arg.h19.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h19.h2, arg.h20)))) }; } break; } break; } case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, arg.h20)) }; } };
const Lib_Syntax_PatVar = ( h0, h1, h2 ) => ({ tag: "PatVar",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_buildCase_constrainSpine_getName_makeConstr = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17, _$$18 ) => { switch (_$$18.tag) { case "_::_": switch (_$$17.tag) { case "_::_": switch (_$$17.h1.h1) { case "Explicit": { const sc$$28 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(Lib_Syntax_getIcit(_$$18.h1), "Explicit"); switch (sc$$28) { case "False": return Lib_Types_MkM(null, ( _16 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_.h4, (("mismatch between Explicit and ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(Lib_Syntax_getIcit(_$$18.h1)))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, _$$18.h2), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$17.h1.h0, _$$18.h1), rest)))); } break; } default: { const sc$$28 = Prelude_not(Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(Lib_Syntax_getIcit(_$$18.h1), _$$17.h1.h1)); switch (sc$$28) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, _$$18.h2), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$17.h1.h0, _$$18.h1), rest)))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude__$3A$3A_(null, _$$18.h1, _$$18.h2)), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$17.h1.h0, Lib_Syntax_PatWild(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(_$$18.h1), _$$17.h1.h1)), rest)))); } break; } } break; case "Nil": return Lib_Types_MkM(null, ( _16 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Pattern$2CgetFC(_$$18.h1), "too many patterns")), eta)))); } break; case "Nil": switch (_$$17.tag) { case "_::_": switch (_$$17.h1.h1) { case "Auto": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude_Nil(null)), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$17.h1.h0, Lib_Syntax_PatWild(Lib_Common_emptyFC, "Auto")), rest)))); case "Explicit": return Lib_Types_MkM(null, ( _16 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$16, "not enough patterns")), eta)))); case "Implicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildCase_constrainSpine_getName_makeConstr(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _$$16, _$$17.h2, Prelude_Nil(null)), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$17.h1.h0, Lib_Syntax_PatWild(Lib_Common_emptyFC, "Implicit")), rest)))); } break; case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)); } break; } };
const Lib_Syntax_PatWild = ( h0, h1 ) => ({ tag: "PatWild",  h0: h0,  h1: h1 });
const Lib_Syntax_getIcit = ( _$$0 ) => { switch (_$$0.tag) { case "PatLit": return "Explicit"; case "PatWild": return _$$0.h1; case "PatCon": return _$$0.h1; case "PatVar": return _$$0.h1; } };
const Lib_Elab_Prelude_Show$20Lib_Elab_Bind$2Cshow = ( _$$0 ) => ((((("") + (_$$0.h0)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h1))) + (""));
const Lib_Elab_updateContext = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_updateContext, { tag: "Lib.Elab.updateContext",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_updateContext = ( arg ) => { switch (arg.h1.tag) { case "_::_": { const ix = Prelude_intToNat(((Prelude_length$27(null, arg.h0.h1)) - (arg.h1.h1.h2)) - (1)); const sc$$11 = Prelude_getAt(null, ix, arg.h0.h1); switch (sc$$11.tag) { case "Nothing": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(arg.h1.h1.h3), "INTERNAL ERROR: bad index in updateContext")), eta)))) }; case "Just": switch (sc$$11.h1.tag) { case "VVar": switch (sc$$11.h1.h2.tag) { case "Lin": { const sc$$18 = Prelude_not(Prelude_jsEq(null, sc$$11.h1.h1, arg.h1.h1.h2)); switch (sc$$18) { case "False": { const ctx$27 = Lib_Types_MkCtx(arg.h0.h0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Elab_substVal(arg.h1.h1.h2, arg.h1.h1.h3, eta)), arg.h0.h1), arg.h0.h2, Lib_Elab_updateContext_replaceV(arg.h0, arg.h1, arg.h1.h0, arg.h1.h1, arg.h1.h2, arg.h1.h1.h0, arg.h1.h1.h1, arg.h1.h1.h2, arg.h1.h1.h3, null, null, ix, "Defined", arg.h0.h3), arg.h0.h4); return { tag: "Lib.Elab.updateContext",  h0: ctx$27,  h1: arg.h1.h2 }; break; } case "True": return { tag: "Lib.Elab.updateContext",  h0: arg.h0,  h1: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, sc$$11.h1.h1, arg.h1.h1.h3), arg.h1.h2) }; } break; } default: return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(Lib_Types_getValFC(arg.h1.h1.h3), (((("need to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1.h1.h3))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$11.h1))) + (" or something")), ( _ ) => (Lib_Elab_updateContext(arg.h0, arg.h1.h2))) }; } break; default: return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(Lib_Types_getValFC(arg.h1.h1.h3), (((("need to unify ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h1.h1.h3))) + (" and ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(sc$$11.h1))) + (" or something")), ( _ ) => (Lib_Elab_updateContext(arg.h0, arg.h1.h2))) }; } break; } break; } case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, arg.h0) }; } };
const Lib_Elab_updateContext_replaceV = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, a$$10, _$$11, _$$12, _$$13 ) => { switch (_$$13.tag) { case "_::_": switch (_$$11) { case 0: return Prelude__$3A$3A_(null, _$$12, _$$13.h2); default: { const x = (_$$11) - (1); return Prelude__$3A$3A_(null, _$$13.h1, Lib_Elab_updateContext_replaceV(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, null, x, _$$12, _$$13.h2)); break; } } break; case "Nil": return Prelude_Nil(null); } };
const Lib_Elab_substVal = ( _$$0, _$$1, _$$2 ) => (Lib_Elab_substVal_go(_$$0, _$$1, _$$2, null, _$$2));
const Lib_Elab_substVal_go = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.tag) { case "VLet": return Lib_Types_VLet(_$$4.h0, _$$4.h1, Lib_Elab_substVal_go(_, _1, _2, _3, _$$4.h2), _$$4.h3); case "VPi": return Lib_Types_VPi(_$$4.h0, _$$4.h1, _$$4.h2, _$$4.h3, Lib_Elab_substVal_go(_, _1, _2, _3, _$$4.h4), _$$4.h5); case "VMeta": return Lib_Types_VMeta(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(null, null, ( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); case "VRef": return Lib_Types_VRef(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(null, null, ( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); case "VVar": { const sc$$8 = Prelude_jsEq(null, _$$4.h1, _); switch (sc$$8) { case "False": return Lib_Types_VVar(_$$4.h0, _$$4.h1, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(null, null, ( eta ) => (Lib_Elab_substVal_go(_, _1, _2, _3, eta)), _$$4.h2)); case "True": return _1; } break; } default: return _$$4; } };
const Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "_:<_": return Prelude__$3A$3C_(null, Prelude_Prelude_Functor$20Prelude_SnocList$2Cmap(null, null, _$$2, _$$3.h1), _$$2(_$$3.h2)); case "Lin": return Prelude_Lin(null); } };
const Lib_Types_tryError = ( a$$0, _$$1 ) => (Lib_Types_catchError(null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_Right(null, null, eta)), _$$1), ( _$$5 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Left(null, null, _$$5)))));
const Lib_Elab_buildCase_constrainSpine = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _$$14, _$$15 ) => { switch (_$$15.tag) { case "_::_": return Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$14, _$$15.h1), Lib_Elab_buildCase_constrainSpine(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, (1) + (_$$14), _$$15.h2)); case "Nil": return Prelude_Nil(null); } };
const Lib_Elab_lookupDef = ( _$$0, _$$1 ) => (Lib_Elab_lookupDef_go(_$$0, _$$1, null, 0, _$$0.h2, _$$0.h1));
const Lib_Elab_lookupDef_go = ( _, _1, _2, _$$3, _$$4, _$$5 ) => (bouncer(Lib_Elab_REC_lookupDef_go, { tag: "Lib.Elab.lookupDef.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4,  h5: _$$5 }));
const Lib_Elab_REC_lookupDef_go = ( arg ) => { switch (arg.h5.tag) { case "_::_": switch (arg.h4.tag) { case "_::_": { const sc$$16 = Prelude_jsEq(null, arg.h4.h1.h2, arg.h1); switch (sc$$16) { case "False": return { tag: "Lib.Elab.lookupDef.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: (1) + (arg.h3),  h4: arg.h4.h2,  h5: arg.h5.h2 }; case "True": return { tag: "return",  h0: Prelude_Just(null, arg.h5.h1) }; } break; } default: return { tag: "return",  h0: Prelude_Nothing(null) }; } break; default: return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Elab_extendPi = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$1.tag) { case "VPi": { const nm = Lib_Elab_fresh(_$$0, _$$1.h1); const ctx$27 = Lib_Types_extend(_$$0, nm, _$$1.h4); const v = Lib_Types_VVar(Lib_Common_emptyFC, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, v, _$$1.h5.h0), _$$1.h5.h1), ( tyb ) => (Lib_Elab_extendPi(ctx$27, tyb, Prelude__$3A$3C_(null, _$$2, Lib_Elab_MkBind(nm, _$$1.h2, _$$1.h4)), Prelude__$3A$3C_(null, _$$3, Lib_Types_VVar(_$$1.h0, Prelude_length$27(null, _$$0.h1), Prelude_Lin(null)))))); break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, _$$0, Prelude__$2C_(null, null, _$$1, Prelude__$2C_(null, null, Prelude__$3C$3E$3E_(null, _$$2, Prelude_Nil(null)), _$$3)))); } };
const Lib_Elab_MkBind = ( h0, h1, h2 ) => ({ tag: "MkBind",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_fresh = ( ctx$$0, _$$1 ) => ((_$$1) + (("$") + (Prelude_showInt(Prelude_length$27(null, ctx$$0.h1)))));
const Lib_Types_Prelude_Show$20Lib_Types_Tm = Prelude_MkShow(null, Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow);
const Lib_Common_Prelude_Show$20Lib_Common_QName = Prelude_MkShow(null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow);
const Lib_Elab_checkCase = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), _$$4.h3.h3), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_extendPi(_$$0, vty, Prelude_Lin(null), Prelude_Lin(null)), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_catchError(null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude_Just(null, eta)), Lib_Elab_unify($$sc.h2.h1, "UPattern", $$sc.h3.h2, _$$3)), ( err ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg(err))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)))))), ( $$sc1 ) => { switch ($$sc1.tag) { case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_tryError(null, Lib_Elab_unify($$sc.h2.h1, "UPattern", $$sc.h3.h2, _$$3)), ( $$sc2 ) => { switch ($$sc2.tag) { case "Right": { const sc$$37 = Lib_Elab_lookupDef(_$$0, _$$2); switch (sc$$37.tag) { case "Just": switch (sc$$37.h1.tag) { case "VRef": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$37.h1.h1, _$$4.h2)); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"); } break; } case "Left": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("SKIP ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$4.h2))) + (" because unify error ")) + (Lib_Types_errorMsg($$sc2.h2))) + (""))), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"))); } }); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"); } }))))));
const Lib_Types_filterM = ( a$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, _$$1(_$$2.h1), ( check ) => { switch (check) { case "False": return Lib_Types_filterM(null, _$$1, _$$2.h2); case "True": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$3A$3A_(null, _$$2.h1, eta)), Lib_Types_filterM(null, _$$1, _$$2.h2)); } }); case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nil(null)); } };
const Prelude_partition = ( a$$0, _$$1, _$$2 ) => (Prelude_partition_go(a$$0, _$$1, _$$2, null, _$$2, Prelude_Nil(null), Prelude_Nil(null)));
const Prelude_partition_go = ( _, _1, _2, _3, _$$4, _$$5, _$$6 ) => (bouncer(Prelude_REC_partition_go, { tag: "Prelude.partition.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _$$4,  h5: _$$5,  h6: _$$6 }));
const Prelude_REC_partition_go = ( arg ) => { switch (arg.h4.tag) { case "_::_": { const sc$$10 = arg.h1(arg.h4.h1); switch (sc$$10) { case "False": return { tag: "Prelude.partition.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: arg.h5,  h6: Prelude__$3A$3A_(null, arg.h4.h1, arg.h6) }; case "True": return { tag: "Prelude.partition.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4.h2,  h5: Prelude__$3A$3A_(null, arg.h4.h1, arg.h5),  h6: arg.h6 }; } break; } case "Nil": return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h5, arg.h6) }; } };
const Lib_Elab_matchedConstructors = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_matchedConstructors, { tag: "Lib.Elab.matchedConstructors",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_matchedConstructors = ( arg ) => { switch (arg.h1.tag) { case "_::_": { const sc$$9 = Prelude_find(null, ( _$$5 ) => (Prelude_jsEq(null, arg.h0, _$$5.h2)), arg.h1.h1.h1); switch (sc$$9.tag) { case "Just": switch (sc$$9.h1.h3.tag) { case "PatCon": return { tag: "return",  h0: Prelude__$3A$3A_(null, sc$$9.h1.h3.h2, Lib_Elab_matchedConstructors(arg.h0, arg.h1.h2)) }; default: return { tag: "Lib.Elab.matchedConstructors",  h0: arg.h0,  h1: arg.h1.h2 }; } break; default: return { tag: "Lib.Elab.matchedConstructors",  h0: arg.h0,  h1: arg.h1.h2 }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_Elab_getConstructors = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.tag) { case "VRef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_getConstructors_lookupTCon(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, null, _$$2.h1), ( $$sc ) => (Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_getConstructors_lookupTCon_lookupDCon(_$$0, _$$1, _$$2, _$$2.h0, _$$2.h1, _$$2.h2, null, null, eta)), $$sc))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_vprint(_$$0, _$$2), ( tms ) => (Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("Can't split - not VRef: ") + (tms)) + (""))), eta)))))); } };
const Lib_Elab_vprint = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(Prelude_length$27(null, _$$0.h1), _$$1), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0.h2), tm))), Prelude_Lin(null))))));
const Lib_Elab_getConstructors_lookupTCon_lookupDCon = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$10 = Lib_TopContext_lookup(_$$8, top); switch (sc$$10.tag) { case "Nothing": return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_3, (("Internal Error: DCon ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$8))) + (" not found"))), eta)))); case "Just": switch (sc$$10.h1.h3.tag) { case "DCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, sc$$10.h1.h1, Prelude__$2C_(null, null, sc$$10.h1.h3.h1, sc$$10.h1.h2))); default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_3, (("Internal Error: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$8))) + (" is not a DCon"))), eta)))); } break; } }));
const Lib_Elab_getConstructors_lookupTCon = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$9 = Lib_TopContext_lookup(_4, top); switch (sc$$9.tag) { case "Just": switch (sc$$9.h1.h3.tag) { case "TCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$9.h1.h3.h1); default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_1, (("Not a type constructor: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_4))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_1, (("Not a type constructor: ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_4))) + (""))), eta)))); } }));
const Lib_Elab_buildLitCases = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => { const lits = Prelude_nub(null, Lib_Types_Prelude_Eq$20Lib_Types_Literal, Lib_Elab_getLits(_$$3, _$$1.h0)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Elab_buildLitCase(_$$0, _$$1, _$$2, _$$3, _$$4, eta)), lits), ( alts ) => { const defclauses = Prelude_filter(null, ( eta ) => (Lib_Elab_buildLitCases_isDefault(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, defclauses), 0), ( _ ) => (Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$2, (("no default for literal slot on ") + (_$$3)) + (""))), eta)))))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(_$$0, Lib_Elab_MkProb(defclauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, alts, Prelude__$3A$3A_(null, Lib_Types_CaseDefault(tm), Prelude_Nil(null)))))))); }); };
const Lib_Elab_buildLitCases_isDefault = ( _, _1, _2, _3, _4, _5, _$$6 ) => { const sc$$7 = Prelude_find(null, ( _$$5 ) => (Prelude_jsEq(null, _3, _$$5.h2)), _$$6.h1); switch (sc$$7.tag) { case "Nothing": return "True"; case "Just": switch (sc$$7.h1.h3.tag) { case "PatWild": return "True"; case "PatVar": return "True"; default: return "False"; } break; } };
const Lib_Elab_buildLitCase = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => { const sc$$8 = Prelude_findIndex$27(null, ( _$$51 ) => (Prelude_jsEq(null, _$$3, _$$51.h2)), _$$0.h2); switch (sc$$8.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (("") + (_$$3)) + (" not is scope?"))), eta)))); case "Just": { const lvl = ((Prelude_length$27(null, _$$0.h1)) - (sc$$8.h1)) - (1); const scon = Prelude__$2C_(null, null, lvl, Lib_Types_VLit(_$$2, _$$5)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateContext(_$$0, Prelude__$3A$3A_(null, scon, Prelude_Nil(null))), ( ctx$27 ) => { const clauses = Prelude_mapMaybe(null, null, ( eta ) => (Lib_Elab_buildLitCase_rewriteConstraint_rewriteClause(_$$0, _$$1, _$$2, _$$3, _$$4, _$$5, null, null, eta)), _$$1.h0); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_jsEq(null, Prelude_length$27(null, clauses), 0), ( _ ) => (Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h4, (((("Missing case for ") + (Lib_Types_Prelude_Show$20Lib_Types_Literal$2Cshow(_$$5))) + (" splitting ")) + (_$$3)) + (""))), eta)))))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(ctx$27, Lib_Elab_MkProb(clauses, _$$1.h1)), ( tm ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_CaseLit(_$$5, tm)))))); }); break; } } };
const Lib_Elab_buildLitCase_rewriteConstraint_rewriteClause = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (Prelude_Prelude_Monad$20Prelude_Maybe$2Cbind(null, null, Lib_Elab_buildLitCase_rewriteConstraint(_, _1, _2, _3, _4, _5, _6, _$$8.h1, Prelude_Nil(null)), ( cons ) => (Prelude_Just(null, Lib_Syntax_MkClause(_$$8.h0, cons, _$$8.h2, _$$8.h3)))));
const Lib_Elab_buildLitCase_rewriteConstraint = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (bouncer(Lib_Elab_REC_buildLitCase_rewriteConstraint, { tag: "Lib.Elab.buildLitCase.rewriteConstraint",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8 }));
const Lib_Elab_REC_buildLitCase_rewriteConstraint = ( arg ) => { switch (arg.h7.tag) { case "_::_": { const sc$$16 = Prelude_jsEq(null, arg.h7.h1.h2, arg.h3); switch (sc$$16) { case "False": return { tag: "Lib.Elab.buildLitCase.rewriteConstraint",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7.h2,  h8: Prelude__$3A$3A_(null, arg.h7.h1, arg.h8) }; case "True": switch (arg.h7.h1.h3.tag) { case "PatLit": { const sc$$20 = Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(arg.h7.h1.h3.h1, arg.h5); switch (sc$$20) { case "False": return { tag: "return",  h0: Prelude_Nothing(null) }; case "True": return { tag: "return",  h0: Prelude_Just(null, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h7.h2, arg.h8)) }; } break; } case "PatWild": return { tag: "return",  h0: Prelude_Just(null, Prelude__$3A$3A_(null, arg.h7.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h7.h2, arg.h8))) }; case "PatCon": return { tag: "return",  h0: Prelude_Nothing(null) }; case "PatVar": return { tag: "return",  h0: Prelude_Just(null, Prelude__$3A$3A_(null, arg.h7.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h7.h2, arg.h8))) }; } break; } break; } case "Nil": return { tag: "return",  h0: Prelude_Just(null, arg.h8) }; } };
const Prelude_Prelude_Monad$20Prelude_Maybe$2Cbind = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$2.tag) { case "Nothing": return Prelude_Nothing(null); case "Just": return _$$3(_$$2.h1); } };
const Lib_Elab_getLits = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_getLits, { tag: "Lib.Elab.getLits",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_getLits = ( arg ) => { switch (arg.h1.tag) { case "_::_": { const sc$$9 = Prelude_find(null, ( _$$5 ) => (Prelude_jsEq(null, arg.h0, _$$5.h2)), arg.h1.h1.h1); switch (sc$$9.tag) { case "Just": switch (sc$$9.h1.h3.tag) { case "PatLit": return { tag: "return",  h0: Prelude__$3A$3A_(null, sc$$9.h1.h3.h1, Lib_Elab_getLits(arg.h0, arg.h1.h2)) }; default: return { tag: "Lib.Elab.getLits",  h0: arg.h0,  h1: arg.h1.h2 }; } break; default: return { tag: "Lib.Elab.getLits",  h0: arg.h0,  h1: arg.h1.h2 }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_Types_Prelude_Eq$20Lib_Types_Literal = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Lib_Types_Prelude_Eq$20Lib_Types_Literal$2C_$3D$3D_(eta, eta1))));
const Prelude_nub = ( a$$0, _$$1, _$$2 ) => (bouncer(Prelude_REC_nub, { tag: "Prelude.nub",  h0: a$$0,  h1: _$$1,  h2: _$$2 }));
const Prelude_REC_nub = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$6 = Prelude_elem(null, arg.h1, arg.h2.h1, arg.h2.h2); switch (sc$$6) { case "False": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h2.h1, Prelude_nub(null, arg.h1, arg.h2.h2)) }; case "True": return { tag: "Prelude.nub",  h0: null,  h1: arg.h1,  h2: arg.h2.h2 }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_Elab_litTyName = ( _$$0 ) => { switch (_$$0.tag) { case "LChar": return Lib_Elab_charType; case "LInt": return Lib_Elab_intType; case "LString": return Lib_Elab_stringType; } };
const Lib_Elab_solveAutos_isAuto_run = ( _, _1, _$$2 ) => { switch (_$$2.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_trySolveAuto(_$$2.h1), ( res ) => { switch (res) { case "False": return Lib_Elab_solveAutos_isAuto_run(_, _1, _$$2.h2); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "True"); } }); case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "False"); } };
const Lib_Elab_solveAutos_isAuto = ( _, _$$1 ) => { switch (_$$1.tag) { case "Unsolved": switch (_$$1.h4) { case "AutoSolve": return "True"; default: return "False"; } break; default: return "False"; } };
const Lib_Elab_solveAutos = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const autos = Prelude_filter(null, ( eta ) => (Lib_Elab_solveAutos_isAuto(null, eta)), Prelude_mapMaybe(null, null, ( _$$5 ) => (Data_SortedMap_lookupMap$27(null, null, _$$5, top.h5.h0)), top.h5.h1)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos_isAuto_run(null, null, autos), ( res ) => { switch (res) { case "False": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "True": return Lib_Elab_solveAutos; } }); });
const Lib_Elab_lookupName = ( _$$0, _$$1 ) => (Lib_Elab_lookupName_go(_$$0, _$$1, null, 0, _$$0.h2));
const Lib_Elab_lookupName_go = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Elab_REC_lookupName_go, { tag: "Lib.Elab.lookupName.go",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Elab_REC_lookupName_go = ( arg ) => { switch (arg.h4.tag) { case "_::_": { const sc$$12 = Prelude_jsEq(null, arg.h4.h1.h2, arg.h1); switch (sc$$12) { case "False": return { tag: "Lib.Elab.lookupName.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: (1) + (arg.h3),  h4: arg.h4.h2 }; case "True": return { tag: "return",  h0: Prelude_Just(null, Prelude__$2C_(null, null, Lib_Types_Bnd(Lib_Common_emptyFC, arg.h3), arg.h4.h1.h3)) }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Elab_findSplit = ( _$$0 ) => (bouncer(Lib_Elab_REC_findSplit, { tag: "Lib.Elab.findSplit",  h0: _$$0 }));
const Lib_Elab_REC_findSplit = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1.h3.tag) { case "PatLit": return { tag: "return",  h0: Prelude_Just(null, arg.h0.h1) }; case "PatCon": return { tag: "return",  h0: Prelude_Just(null, arg.h0.h1) }; default: return { tag: "Lib.Elab.findSplit",  h0: arg.h0.h2 }; } break; case "Nil": return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Elab_introClause = ( _$$0, _$$1, _$$2 ) => { switch (_$$2.h2.tag) { case "_::_": { const sc$$10 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, Lib_Syntax_getIcit(_$$2.h2.h1)); switch (sc$$10) { case "False": { const sc$$11 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, "Implicit"); switch (sc$$11) { case "False": { const sc$$12 = Lib_Types_Prelude_Eq$20Lib_Types_Icit$2C_$3D$3D_(_$$1, "Auto"); switch (sc$$12) { case "False": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$2.h0, (((((("Explicit arg and ") + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(Lib_Syntax_getIcit(_$$2.h2.h1)))) + (" pattern ")) + (_$$0)) + ("  ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Pattern$2Cshow(_$$2.h2.h1))) + (""))), eta)))); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, Lib_Syntax_PatWild(_$$2.h0, "Auto")), _$$2.h1), Prelude__$3A$3A_(null, _$$2.h2.h1, _$$2.h2.h2), _$$2.h3)); } break; } case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, Lib_Syntax_PatWild(_$$2.h0, "Implicit")), _$$2.h1), Prelude__$3A$3A_(null, _$$2.h2.h1, _$$2.h2.h2), _$$2.h3)); } break; } case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, _$$2.h2.h1), _$$2.h1), _$$2.h2.h2, _$$2.h3)); } break; } case "Nil": switch (_$$1) { case "Auto": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, Lib_Syntax_PatWild(_$$2.h0, "Auto")), _$$2.h1), Prelude_Nil(null), _$$2.h3)); case "Implicit": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(_$$2.h0, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, Lib_Syntax_PatWild(_$$2.h0, "Implicit")), _$$2.h1), Prelude_Nil(null), _$$2.h3)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$2.h0, "Clause size doesn't match")), eta)))); } break; } };
const Lib_Elab_mkPat = ( _$$0 ) => { switch (_$$0.h2.tag) { case "RAs": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_mkPat(Prelude__$2C_(null, null, _$$0.h2.h2, _$$0.h3)), ( pat ) => { switch (pat.tag) { case "PatCon": switch (pat.h4.tag) { case "Nothing": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatCon(pat.h0, pat.h1, pat.h2, pat.h3, Prelude_Just(null, _$$0.h2.h1))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(pat.h0, (("Double as pattern ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2.h2))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0.h2.h0, (("Can't put as on non-constructor ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2.h2))) + (""))), eta)))); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$6 = Lib_Elab_splitArgs(_$$0.h2, Prelude_Nil(null)); switch (sc$$6.h2.tag) { case "RImplicit": switch (sc$$6.h3.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatWild(sc$$6.h2.h0, _$$0.h3)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$6.h2.h0, "implicit pat can't be applied to arguments")), eta)))); } break; case "RLit": switch (sc$$6.h3.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatLit(sc$$6.h2.h0, sc$$6.h2.h1)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$6.h2.h0, "lit cannot be applied to arguments")), eta)))); } break; case "RVar": { const sc$$13 = Lib_TopContext_lookupRaw(sc$$6.h2.h1, top); switch (sc$$13.tag) { case "Just": switch (sc$$13.h1.h3.tag) { case "DCon": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Lib_Elab_mkPat, sc$$6.h3), ( bpat ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatCon(sc$$6.h2.h0, _$$0.h3, sc$$13.h1.h1, bpat, Prelude_Nothing(null))))); default: switch (sc$$6.h3.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatVar(sc$$6.h2.h0, _$$0.h3, sc$$6.h2.h1)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), "patvar applied to args")), eta)))); } break; } break; default: switch (sc$$6.h3.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_PatVar(sc$$6.h2.h0, _$$0.h3, sc$$6.h2.h1)); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), "patvar applied to args")), eta)))); } break; } break; } default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$6.h2), (("expected pat var or constructor, got ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(sc$$6.h2))) + (""))), eta)))); } }); } };
const Lib_Syntax_PatCon = ( h0, h1, h2, h3, h4 ) => ({ tag: "PatCon",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Syntax_PatLit = ( h0, h1 ) => ({ tag: "PatLit",  h0: h0,  h1: h1 });
const Lib_Elab_splitArgs = ( _$$0, _$$1 ) => (bouncer(Lib_Elab_REC_splitArgs, { tag: "Lib.Elab.splitArgs",  h0: _$$0,  h1: _$$1 }));
const Lib_Elab_REC_splitArgs = ( arg ) => { switch (arg.h0.tag) { case "RApp": return { tag: "Lib.Elab.splitArgs",  h0: arg.h0.h1,  h1: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h0.h2, arg.h0.h3), arg.h1) }; default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h0, arg.h1) }; } };
const Lib_Elab_undo = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "_::_": switch (_$$1.h1.tag) { case "DoArrow": switch (_$$1.h1.h1.tag) { case "RVar": switch (_$$1.h1.h3.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$13 = Lib_TopContext_lookupRaw(_$$1.h1.h1.h1, top); switch (sc$$13.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, "Explicit"), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h1.h0, _$$1.h1.h1.h1, "Explicit", "Many"), xs$27), "Explicit")))); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), Prelude_Nil(null)))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, "Explicit"), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", "Explicit", "Many"), rest), "Explicit")))))); } }); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), _$$1.h1.h3))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, "Explicit"), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", "Explicit", "Many"), rest), "Explicit")))))); } break; default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RCase(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "$sc"), Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(_$$1.h1.h1, xs$27), _$$1.h1.h3))), ( rest ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h2, "Explicit"), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "$sc", "Explicit", "Many"), rest), "Explicit")))))); } break; case "DoLet": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Syntax_RLet(_$$1.h1.h0, _$$1.h1.h1, Lib_Syntax_RImplicit(_$$1.h1.h0), _$$1.h1.h2, eta)), Lib_Elab_undo(_$$1.h1.h0, _$$1.h2)); case "DoExpr": switch (_$$1.h2.tag) { case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$1.h1.h1); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_undo(_$$1.h1.h0, _$$1.h2), ( xs$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RApp(_$$1.h1.h0, Lib_Syntax_RVar(_$$1.h1.h0, "_>>=_"), _$$1.h1.h1, "Explicit"), Lib_Syntax_RLam(_$$1.h1.h0, Lib_Types_BI(_$$1.h1.h0, "_", "Explicit", "Many"), xs$27), "Explicit")))); } break; } break; case "Nil": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, "do block must end in expression")), eta)))); } };
const Lib_Types_BI = ( h0, h1, h2, h3 ) => ({ tag: "BI",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Syntax_RLam = ( h0, h1, h2 ) => ({ tag: "RLam",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_RApp = ( h0, h1, h2, h3 ) => ({ tag: "RApp",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Syntax_RImplicit = ( h0 ) => ({ tag: "RImplicit",  h0: h0 });
const Lib_Syntax_RLet = ( h0, h1, h2, h3, h4 ) => ({ tag: "RLet",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Syntax_MkAlt = ( h0, h1 ) => ({ tag: "MkAlt",  h0: h0,  h1: h1 });
const Lib_Syntax_RCase = ( h0, h1, h2 ) => ({ tag: "RCase",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_collectDecl = ( _$$0 ) => (bouncer(Lib_Elab_REC_collectDecl, { tag: "Lib.Elab.collectDecl",  h0: _$$0 }));
const Lib_Elab_REC_collectDecl = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1.tag) { case "FunDef": switch (arg.h0.h2.tag) { case "_::_": switch (arg.h0.h2.h1.tag) { case "FunDef": { const sc$$13 = Prelude_jsEq(null, arg.h0.h1.h1, arg.h0.h2.h1.h1); switch (sc$$13) { case "False": return { tag: "return",  h0: Prelude__$3A$3A_(null, Lib_Syntax_FunDef(arg.h0.h1.h0, arg.h0.h1.h1, arg.h0.h1.h2), Lib_Elab_collectDecl(arg.h0.h2)) }; case "True": return { tag: "Lib.Elab.collectDecl",  h0: Prelude__$3A$3A_(null, Lib_Syntax_FunDef(arg.h0.h1.h0, arg.h0.h1.h1, Prelude_Prelude_Concat$20$28Prelude_List$20BND$3A0$29$2C_$2B$2B_(null, arg.h0.h1.h2, arg.h0.h2.h1.h2)), arg.h0.h2.h2) }; } break; } default: return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } break; default: return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } break; default: return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h0.h1, Lib_Elab_collectDecl(arg.h0.h2)) }; } break; case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_Syntax_FunDef = ( h0, h1, h2 ) => ({ tag: "FunDef",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Elab_checkWhere = ( _$$0, _$$1, _$$2, _$$3 ) => { switch (_$$1.tag) { case "_::_": switch (_$$1.h1.tag) { case "TypeSig": switch (_$$1.h1.h1.tag) { case "_::_": switch (_$$1.h1.h1.h2.tag) { case "Nil": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(_$$0, _$$1.h1.h2, Lib_Types_VU(_$$1.h1.h0)), ( funTy ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _ ) => ((((("where clause ") + (_$$1.h1.h1.h1)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h2), _$$0.h2), funTy))), Prelude_Lin(null)))) + (""))), ( _ ) => { switch (_$$1.h2.tag) { case "_::_": switch (_$$1.h2.h1.tag) { case "FunDef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_jsEq(null, _$$1.h1.h1.h1, _$$1.h2.h1.h1)), ( _1 ) => (Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h2.h1.h0, (("Expected def for ") + (_$$1.h1.h1.h1)) + (""))), eta)))))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Lib_Elab_makeClause, _$$1.h2.h1.h2), ( clauses$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(_$$0.h1, funTy), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((((("") + (_$$1.h1.h1.h1)) + (" vty is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(vty))) + (""))), ( _2 ) => { const ctx$27 = Lib_Types_extend(_$$0, _$$1.h1.h1.h1, vty); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(Lib_Types_MkCtx(ctx$27.h0, ctx$27.h1, ctx$27.h2, ctx$27.h3, _$$1.h2.h1.h0), Lib_Elab_MkProb(clauses$27, vty)), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(ctx$27.h1, tm), ( vtm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_checkWhere(ctx$27, _$$1.h2.h2, _$$2, _$$3), ( ty$27 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Types_LetRec(_$$1.h1.h0, _$$1.h1.h1.h1, funTy, tm, ty$27)))))))); }))))))))); default: return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h2.h1), "expected function definition")), eta)))); } break; default: return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1.h1.h0, "expected function definition after this signature")), eta)))); } }))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(_$$1.h1), "expected type signature")), eta)))); } break; default: return Lib_Elab_check(_$$0, _$$2, _$$3); } };
const Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC = ( _$$0 ) => { switch (_$$0.tag) { case "Record": return _$$0.h0; case "Instance": return _$$0.h0; case "Class": return _$$0.h0; case "PMixFix": return _$$0.h0; case "PFunc": return _$$0.h0; case "PType": return _$$0.h0; case "ShortData": return _$$0.h0; case "Data": return _$$0.h0; case "DCheck": return _$$0.h0; case "FunDef": return _$$0.h0; case "TypeSig": return _$$0.h0; } };
const Lib_Elab_makeClause = ( _$$0 ) => { const sc$$5 = Lib_Elab_splitArgs(_$$0.h2, Prelude_Nil(null)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Lib_Elab_mkPat, sc$$5.h3), ( pats ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_MkClause(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$0.h2), Prelude_Nil(null), pats, _$$0.h3)))); };
const Lib_Elab_updateRec = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_updateRec_doClause_collect_getTele(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, _$$3, _$$4), ( $$sc ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_foldlM(null, null, null, Lib_Types_Prelude_Monad$20Lib_Types_M, ( eta ) => (( eta1 ) => (Lib_Elab_updateRec_doClause(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta, eta1))), $$sc.h3, _$$2), ( args$27 ) => { const tm = Prelude_foldl(null, null, ( acc ) => (( tm ) => (Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(tm), acc, tm, "Explicit"))), Lib_Syntax_RVar(_$$1, $$sc.h2.h1), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$21 ) => (_$$21.h3), args$27)); let tm1; switch (_$$3.tag) { case "Nothing": { tm1 = Lib_Syntax_RLam(_$$1, Lib_Types_BI(_$$1, "$ru", "Explicit", "Many"), tm); break; } case "Just": { tm1 = tm; break; } } return Lib_Elab_check(_$$0, tm1, _$$4); }))));
const Lib_Elab_updateRec_doClause = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case "ModifyField": return Lib_Elab_updateRec_doClause_go(_, _1, _2, _3, _4, _5, _$$6, _$$7, _$$7.h0, _$$7.h1, _$$7.h2, null, _$$6); case "AssignField": return Lib_Elab_updateRec_doClause_go$27(_, _1, _2, _3, _4, _5, _$$6, _$$7, _$$7.h0, _$$7.h1, _$$7.h2, null, _$$6); } };
const Lib_Elab_updateRec_doClause_go$27 = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { switch (_$$12.tag) { case "_::_": { const sc$$16 = Prelude_jsEq(null, _$$12.h1.h2, _9); switch (sc$$16) { case "False": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$3A$3A_(null, _$$12.h1, eta)), Lib_Elab_updateRec_doClause_go$27(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12.h2)); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _9, _10), _$$12.h2)); } break; } case "Nil": return Lib_Types_MkM(null, ( _12 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_8, (((("") + (_9)) + (" is not a field of ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_4))) + (""))), eta)))); } };
const Lib_Elab_updateRec_doClause_go = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12 ) => { switch (_$$12.tag) { case "_::_": { const sc$$16 = Prelude_jsEq(null, _$$12.h1.h2, _9); switch (sc$$16) { case "False": return Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Prelude__$3A$3A_(null, _$$12.h1, eta)), Lib_Elab_updateRec_doClause_go(_, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _$$12.h2)); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _9, Lib_Syntax_RApp(_8, _10, _$$12.h1.h3, "Explicit")), _$$12.h2)); } break; } case "Nil": return Lib_Types_MkM(null, ( _12 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_8, (((("") + (_9)) + (" is not a field of ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_4))) + (""))), eta)))); } };
const Lib_Elab_updateRec_doClause_collect_getTele = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (bouncer(Lib_Elab_REC_updateRec_doClause_collect_getTele, { tag: "Lib.Elab.updateRec.doClause.collect.getTele",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8,  h9: _$$9 }));
const Lib_Elab_REC_updateRec_doClause_collect_getTele = ( arg ) => { switch (arg.h9.tag) { case "VPi": switch (arg.h8.tag) { case "Nothing": return { tag: "Lib.Elab.updateRec.doClause.collect.getTele",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Prelude_Just(null, Lib_Syntax_RVar(arg.h1, "$ru")),  h9: arg.h9.h4 }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a record type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) }; } break; case "VRef": switch (arg.h8.tag) { case "Nothing": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a pi type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) }; case "Just": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$16 = Lib_TopContext_lookup(arg.h9.h1, top); switch (sc$$16.tag) { case "Just": switch (sc$$16.h1.h3.tag) { case "TCon": switch (sc$$16.h1.h3.h1.tag) { case "_::_": switch (sc$$16.h1.h3.h1.h2.tag) { case "Nil": { const sc$$30 = Lib_TopContext_lookup(sc$$16.h1.h3.h1.h1, top); switch (sc$$30.tag) { case "Just": switch (sc$$30.h1.h3.tag) { case "DCon": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, sc$$16.h1.h3.h1.h1, Lib_Elab_updateRec_doClause_collect(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h8.h1, sc$$30.h1.h2))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$16.h1.h3.h1.h1))) + (" not a dcon"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$16.h1.h3.h1.h1))) + (" not a dcon"))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" is not a record"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(arg.h9.h0, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(arg.h9.h1))) + (" not in scope"))), eta)))); } }) }; } break; default: switch (arg.h8.tag) { case "Nothing": return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a pi type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC(arg.h9), (("Expected a record type, got ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(arg.h9))) + (""))), eta)))) }; } break; } };
const Lib_Elab_updateRec_doClause_collect = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => { switch (_$$8.tag) { case "Pi": return Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$8.h1, Lib_Syntax_RApp(_1, Lib_Syntax_RVar(_1, (".") + (_$$8.h1)), _$$7, "Explicit")), Lib_Elab_updateRec_doClause_collect(_, _1, _2, _3, _4, _5, _6, _$$7, _$$8.h5)); default: return Prelude_Nil(null); } };
const Lib_Util_splitTele_go = ( _, _$$1, _$$2 ) => (bouncer(Lib_Util_REC_splitTele_go, { tag: "Lib.Util.splitTele.go",  h0: _,  h1: _$$1,  h2: _$$2 }));
const Lib_Util_splitTele = ( eta ) => (Lib_Util_splitTele_go(null, Prelude_Nil(null), eta));
const Lib_Util_REC_splitTele_go = ( arg ) => { switch (arg.h2.tag) { case "Pi": return { tag: "Lib.Util.splitTele.go",  h0: arg.h0,  h1: Prelude__$3A$3A_(null, Lib_Util_MkBinder(arg.h2.h0, arg.h2.h1, arg.h2.h2, arg.h2.h3, arg.h2.h4), arg.h1),  h2: arg.h2.h5 }; default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h2, Prelude_reverse(null)(arg.h1)) }; } };
const Lib_Util_MkBinder = ( h0, h1, h2, h3, h4 ) => ({ tag: "MkBinder",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_ProcessDecl_dumpEnv = ( _$$0 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$5 ) => (Prelude_joinBy("\n", Prelude_reverse(null)(_$$5))), Lib_ProcessDecl_dumpEnv_isVar_go(_$$0, null, null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( _$$2 ) => (_$$2.h2), _$$0.h2), 0, Prelude_reverse(null)(Prelude_zip(null, null, _$$0.h1, _$$0.h2)), Prelude_Nil(null))));
const Lib_ProcessDecl_dumpEnv_isVar_go = ( _, _1, _2, _$$3, _$$4, _$$5, _$$6 ) => { switch (_$$5.tag) { case "_::_": { const sc$$18 = Lib_ProcessDecl_dumpEnv_isVar(_, _1, _$$4, _$$5.h1.h2); switch (sc$$18) { case "False": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h2), ( v$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( ty$27 ) => (Lib_ProcessDecl_dumpEnv_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_(null, (((((("  ") + (_$$5.h1.h3.h2)) + (" = ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, v$27))), Prelude_Lin(null)))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, ty$27))), Prelude_Lin(null)))) + (""), _$$6)))))); case "True": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_quote(_.h0, _$$5.h1.h3.h3), ( ty$27 ) => (Lib_ProcessDecl_dumpEnv_isVar_go(_, _1, _2, _$$3, (1) + (_$$4), _$$5.h2, Prelude__$3A$3A_(null, (((("  ") + (_$$5.h1.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, _$$3, ty$27))), Prelude_Lin(null)))) + (""), _$$6)))); } break; } case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$6); } };
const Lib_ProcessDecl_dumpEnv_isVar = ( _, _1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "VVar": switch (_$$3.h2.tag) { case "Lin": return Prelude_jsEq(null, _$$2, _$$3.h1); default: return "False"; } break; default: return "False"; } };
const Serialize_dumpModule = ( _$$0, _$$1, _$$2 ) => { const fn = (("build/") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (".newtmod"); const defs = Data_SortedMap_listValues(null, null, _$$2.h1); const ops = Data_SortedMap_toList(null, null, _$$2.h3); const mctx = Data_SortedMap_toList(null, null, _$$2.h2.h0); return Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Serialize_dumpModFile(fn, Prelude__$2C_(null, null, _$$2.h0, Prelude__$2C_(null, null, defs, Prelude__$2C_(null, null, ops, mctx))))); };
const Serialize_dumpModFile = (fn,a) => (w) => {
  let fs = require('fs')
  try {
    let {EncFile} = require('./serializer')
    let enc = EncFile.encode(a)
    fs.writeFileSync(fn, enc)
  } catch (e) {}
  return Prelude_MkIORes(null, Prelude_MkUnit, w)
};
const Lib_Types_MkModCtx = ( h0, h1, h2, h3 ) => ({ tag: "MkModCtx",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Main_processModule_tryProcessDecl = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_tryError(null, Lib_ProcessDecl_processDecl(_$$8, _$$9)), ( $$sc ) => { switch ($$sc.tag) { case "Left": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn(Lib_Common_showError(_$$7, $$sc.h2))), ( _7 ) => (Lib_TopContext_addError($$sc.h2))); default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } }));
const Lib_TopContext_addError = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Data_IORef_modifyIORef(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M, Lib_Types_Prelude_HasIO$20Lib_Types_M, top.h7, ( eta ) => (Prelude__$3A$3A_(null, _$$0, eta))))));
const Lib_ProcessDecl_processDecl = ( _$$0, _$$1 ) => { switch (_$$1.tag) { case "Record": return Lib_ProcessDecl_processRecord(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case "Instance": return Lib_ProcessDecl_processInstance(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case "Class": return Lib_ProcessDecl_processClass(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3); case "PMixFix": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "PFunc": return Lib_ProcessDecl_processPrimFn(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3, _$$1.h4); case "PType": return Lib_ProcessDecl_processPrimType(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case "ShortData": return Lib_ProcessDecl_processShortData(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case "Data": return Lib_ProcessDecl_processData(_$$0, _$$1.h0, _$$1.h1, _$$1.h2, _$$1.h3); case "DCheck": return Lib_ProcessDecl_processCheck(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case "FunDef": return Lib_ProcessDecl_processDef(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); case "TypeSig": return Lib_ProcessDecl_processTypeSig(_$$0, _$$1.h0, _$$1.h1, _$$1.h2); } };
const Lib_ProcessDecl_processTypeSig = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(_$$1, eta)), _$$2), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$3, Lib_Types_VU(_$$1)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _2 ) => ((((("TypeSig ") + (Prelude_joinBy(" ", _$$2))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), ty))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => ("MkUnit"), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$2, ( nm ) => (Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm), _$$1, ty, Lib_Types_Axiom, Prelude_Nil(null))))))))))))))));
const Lib_Types_Axiom = { tag: "Axiom" };
const Lib_TopContext_setDef = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$6 = Data_SortedMap_lookupMap$27(null, null, _$$0, top.h4); switch (sc$$6.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => { const defs = Data_SortedMap_updateMap(null, null, _$$0, Lib_Types_MkEntry(_$$1, _$$0, _$$2, _$$3, _$$4), top.h4); return Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, defs, tc.h5, tc.h6, tc.h7, tc.h8)); }); case "Just": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" is already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$6.h1.h0))) + (""))), eta)))); } }));
const Lib_Types_MkEntry = ( h0, h1, h2, h3, h4 ) => ({ tag: "MkEntry",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_ProcessDecl_checkAlreadyDef = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$3 = Lib_TopContext_lookupRaw(_$$1, top); switch (sc$$3.tag) { case "Nothing": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "Just": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$0, (((("") + (_$$1)) + (" is already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$3.h1.h0))) + (""))), eta)))); } }));
const Lib_ProcessDecl_processDef = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("Def ") + (_$$2)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$8 = Lib_TopContext_lookupRaw(_$$2, top); switch (sc$$8.tag) { case "Nothing": return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("No declaration for ") + (_$$2)) + (""))), eta)))); case "Just": switch (sc$$8.h1.h3.tag) { case "Axiom": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _2 ) => ((((("check ") + (_$$2)) + (" at ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$8.h1.h2))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$8.h1.h2), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((((("") + (_$$2)) + (" vty is ")) + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(vty))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Lib_Elab_makeClause, _$$3), ( clauses$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_buildTree(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), sc$$8.h1.h0), Lib_Elab_MkProb(clauses$27, vty)), ( tm ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos, ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((((("Add def ") + (_$$2)) + (" ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), tm))), Prelude_Lin(null)))) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$8.h1.h2))), Prelude_Lin(null)))) + (""))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), sc$$8.h1.h0, sc$$8.h1.h2, Lib_Types_Fn(tm)), ( _6 ) => { const name = Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(Lib_Common_QN(_$$0, _$$2)); const sc$$26 = Prelude__$7C$7C_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, Lib_ProcessDecl_complexity(tm), 15), "LT"), Prelude__$7C$7C_(Prelude_jsEq(null, name, "Prelude.Prelude.Monad Prelude.IO,bind"), Prelude_jsEq(null, name, "Prelude._>>=_"))); switch (sc$$26) { case "False": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "True": return Lib_TopContext_setFlag(Lib_Common_QN(_$$0, _$$2), sc$$8.h1.h0, "Inline"); } }))))))))))))))); default: return Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (((("") + (_$$2)) + (" already defined at ")) + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(sc$$8.h1.h0))) + (""))), eta)))); } break; } }))))));
const Lib_TopContext_setFlag = ( _$$0, _$$1, _$$2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$4 = Data_SortedMap_lookupMap$27(null, null, _$$0, top.h4); switch (sc$$4.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" not declared"))), eta)))); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => { const defs = Data_SortedMap_updateMap(null, null, _$$0, Lib_Types_MkEntry(sc$$4.h1.h0, _$$0, sc$$4.h1.h2, sc$$4.h1.h3, Prelude__$3A$3A_(null, _$$2, sc$$4.h1.h4)), tc.h4); return Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, defs, tc.h5, tc.h6, tc.h7, tc.h8)); }); } }));
const Lib_ProcessDecl_complexity = ( _$$0 ) => { switch (_$$0.tag) { case "Lit": return 0; case "Case": switch (_$$0.h2.tag) { case "_::_": switch (_$$0.h2.h1.tag) { case "CaseCons": switch (_$$0.h2.h2.tag) { case "Nil": return ((1) + (Lib_ProcessDecl_complexity(_$$0.h1))) + (Lib_ProcessDecl_complexity(_$$0.h2.h1.h2)); default: return 100; } break; default: return 100; } break; default: return 100; } break; case "UU": return 0; case "App": return Lib_ProcessDecl_complexity_go(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, _$$0.h1, Lib_ProcessDecl_complexity(_$$0.h2)); case "Lam": return (1) + (Lib_ProcessDecl_complexity(_$$0.h4)); case "Meta": return 1; case "Ref": return 1; case "Bnd": return 1; default: return 100; } };
const Lib_ProcessDecl_complexity_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (bouncer(Lib_ProcessDecl_REC_complexity_go, { tag: "Lib.ProcessDecl.complexity.go",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _$$5,  h6: _$$6 }));
const Lib_ProcessDecl_REC_complexity_go = ( arg ) => { switch (arg.h5.tag) { case "App": return { tag: "Lib.ProcessDecl.complexity.go",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5.h1,  h6: (arg.h6) + (Lib_ProcessDecl_complexity(arg.h5.h2)) }; case "Meta": return { tag: "return",  h0: 1 }; default: return { tag: "return",  h0: (arg.h6) + (Lib_ProcessDecl_complexity(arg.h5)) }; } };
const Lib_TopContext_updateDef = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$5 = Data_SortedMap_lookupMap$27(null, null, _$$0, top.h4); switch (sc$$5.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (" not declared"))), eta)))); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => { const defs = Data_SortedMap_updateMap(null, null, _$$0, Lib_Types_MkEntry(sc$$5.h1.h0, _$$0, _$$2, _$$3, sc$$5.h1.h4), tc.h4); return Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, defs, tc.h5, tc.h6, tc.h7, tc.h8)); }); } }));
const Lib_ProcessDecl_processCheck = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("----- DCheck")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_info(_$$1, (((("check ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$2))) + (" at ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$3))) + ("")), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$3, Lib_Types_VU(_$$1)), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("  got type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), ty$27))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), ty$27), ( vty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$2, vty), ( res ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("  got ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), res))), Prelude_Lin(null)))) + (""))), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), res), ( eta ) => (Lib_Eval_quote(Prelude_length$27(null, Prelude_Nil(null)), eta))), ( norm ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("  NF ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), norm))), Prelude_Lin(null)))) + (""))))))))))))))))))))));
const Lib_ProcessDecl_processData = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("Data ") + (_$$2)) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$3, Lib_Types_VU(_$$1)), ( tyty ) => { const sc$$12 = Lib_TopContext_lookupRaw(_$$2, top); switch (sc$$12.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_Axiom, Prelude_Nil(null)), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, _$$31, ( _$$11 ) => (_$$11))), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$4, ( x ) => { switch (x.tag) { case "TypeSig": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h0, eta)), x.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), x.h0), x.h2, Lib_Types_VU(x.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), dty))), Prelude_Lin(null)))) + (""))), ( _5 ) => { const sc$$22 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse(null)(Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$22.h3)); const sc$$28 = Lib_Util_funArgs(sc$$22.h2); switch (sc$$28.h2.tag) { case "Ref": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$28.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$22.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$22.h2))), Prelude_Lin(null)))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( nm$27 ) => (Lib_Types_MkEntry(x.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon("NormalCon", Lib_Elab_getArity(dty), sc$$28.h2.h1), Prelude_Nil(null))), x.h1)))); default: return Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$28.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$28.h2))), Prelude_Lin(null)))) + (""))), eta)))); } }))))))); default: return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x), "expected constructor declaration")), eta)))); } })), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))); case "Just": switch (sc$$12.h1.h3.tag) { case "Axiom": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), tyty), ( tyty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$12.h1.h2), ( type$27 ) => (Lib_Elab_unifyCatch(_$$1, Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), tyty$27, type$27))))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, _$$31, ( _$$11 ) => (_$$11))), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$4, ( x ) => { switch (x.tag) { case "TypeSig": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h0, eta)), x.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), x.h0), x.h2, Lib_Types_VU(x.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), dty))), Prelude_Lin(null)))) + (""))), ( _5 ) => { const sc$$22 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse(null)(Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$22.h3)); const sc$$28 = Lib_Util_funArgs(sc$$22.h2); switch (sc$$28.h2.tag) { case "Ref": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$28.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$22.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$22.h2))), Prelude_Lin(null)))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( nm$27 ) => (Lib_Types_MkEntry(x.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon("NormalCon", Lib_Elab_getArity(dty), sc$$28.h2.h1), Prelude_Nil(null))), x.h1)))); default: return Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$28.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$28.h2))), Prelude_Lin(null)))) + (""))), eta)))); } }))))))); default: return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x), "expected constructor declaration")), eta)))); } })), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_MkM(null, ( _2 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("") + (_$$2)) + (" already declared"))), eta)))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => (Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, _$$31, ( _$$11 ) => (_$$11))), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$4, ( x ) => { switch (x.tag) { case "TypeSig": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_checkAlreadyDef(x.h0, eta)), x.h1), ( _3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _4 ) => ((((("check dcon ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" ")) + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(x.h2))) + (""))), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), x.h0), x.h2, Lib_Types_VU(x.h0)), ( dty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((((("dty ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, x.h1)))) + (" is ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), dty))), Prelude_Lin(null)))) + (""))), ( _5 ) => { const sc$$22 = Lib_Util_splitTele(dty); const tnames = Prelude_reverse(null)(Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_ProcessDecl_processData_binderName(_$$0, _$$1, _$$2, _$$3, _$$4, null, eta)), sc$$22.h3)); const sc$$28 = Lib_Util_funArgs(sc$$22.h2); switch (sc$$28.h2.tag) { case "Ref": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(sc$$28.h2.h1, Lib_Common_QN(_$$0, _$$2))), ( _6 ) => (Lib_Types_MkM(null, ( _7 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$22.h2), (((("Constructor codomain is ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$22.h2))), Prelude_Lin(null)))) + (" rather than ")) + (_$$2)) + (""))), eta)))))), ( _6 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( nm$27 ) => (Lib_Types_MkEntry(x.h0, Lib_Common_QN(_$$0, nm$27), dty, Lib_Types_DCon("NormalCon", Lib_Elab_getArity(dty), sc$$28.h2.h1), Prelude_Nil(null))), x.h1)))); default: return Lib_Types_MkM(null, ( _6 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_Lib_Common_HasFC$20Lib_Types_Tm$2CgetFC(sc$$28.h2), (((("expected ") + (_$$2)) + (" got ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, tnames, sc$$28.h2))), Prelude_Lin(null)))) + (""))), eta)))); } }))))))); default: return Lib_Types_MkM(null, ( _3 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Decl$2CgetFC(x), "expected constructor declaration")), eta)))); } })), ( entries ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_solveAutos, ( _3 ) => { const entries1 = Lib_ProcessDecl_populateConInfo(entries); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, entries1, ( $$case ) => (Lib_TopContext_setDef($$case.h1, $$case.h0, $$case.h2, $$case.h3, $$case.h4))), ( _4 ) => { const cnames = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( x ) => (x.h1), entries1); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _5 ) => ((((("setDef ") + (_$$2)) + ("  TCon ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, cnames)))) + (""))), ( _5 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(tyty)); return Lib_TopContext_updateDef(Lib_Common_QN(_$$0, _$$2), _$$1, tyty, Lib_Types_TCon(arity, cnames)); }); }); }))))); } break; } }))))))));
const Lib_Types_TCon = ( h0, h1 ) => ({ tag: "TCon",  h0: h0,  h1: h1 });
const Lib_Util_piArity = ( _$$0 ) => { switch (_$$0.tag) { case "Pi": return (1) + (Lib_Util_piArity(_$$0.h5)); default: return 0; } };
const Lib_ProcessDecl_populateConInfo = ( _$$0 ) => { const sc$$5 = Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Prelude_Prelude_Applicative$20Prelude_Maybe, ( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum(_$$0, null, null, eta)), _$$0); switch (sc$$5.tag) { case "Nothing": switch (_$$0.tag) { case "_::_": switch (_$$0.h2.tag) { case "_::_": switch (_$$0.h2.h2.tag) { case "Nil": { const sc$$15 = Prelude_find(null, ( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero_isSucc(_$$0, null, null, null, null, eta)), _$$0); switch (sc$$15.tag) { case "Just": { const sc$$18 = Prelude_find(null, ( eta ) => (Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero(_$$0, null, null, null, eta)), _$$0); switch (sc$$18.tag) { case "Just": return Prelude__$3A$3A_(null, Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$18.h1, "ZeroCon"), Prelude__$3A$3A_(null, Lib_ProcessDecl_populateConInfo_setInfo(_$$0, null, sc$$15.h1, "SuccCon"), Prelude_Nil(null))); default: return _$$0; } break; } default: return _$$0; } break; } default: return _$$0; } break; default: return _$$0; } break; default: return _$$0; } break; case "Just": return sc$$5.h1; } };
const Lib_ProcessDecl_populateConInfo_setInfo = ( _, _1, _$$2, _$$3 ) => { switch (_$$2.h3.tag) { case "DCon": return Lib_Types_MkEntry(_$$2.h0, _$$2.h1, _$$2.h2, Lib_Types_DCon(_$$3, _$$2.h3.h1, _$$2.h3.h2), _$$2.h4); default: return _$$2; } };
const Lib_Types_DCon = ( h0, h1, h2 ) => ({ tag: "DCon",  h0: h0,  h1: h1,  h2: h2 });
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero = ( _, _1, _2, _3, _$$4 ) => { switch (_$$4.h3.tag) { case "DCon": switch (_$$4.h3.h1) { case 0: return "True"; default: return "False"; } break; default: return "False"; } };
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum_isZero_isSucc = ( _, _1, _2, _3, _4, _$$5 ) => { switch (_$$5.h2.tag) { case "Pi": switch (_$$5.h2.h4.tag) { case "Ref": switch (_$$5.h2.h5.tag) { case "Ref": switch (_$$5.h3.tag) { case "DCon": switch (_$$5.h3.h1) { case 1: return Lib_Common_Prelude_Eq$20Lib_Common_QName$2C_$3D$3D_(_$$5.h2.h4.h1, _$$5.h2.h5.h1); default: return "False"; } break; default: return "False"; } break; default: return "False"; } break; default: return "False"; } break; default: return "False"; } };
const Lib_ProcessDecl_populateConInfo_setInfo_checkEnum = ( _, _1, _2, _$$3 ) => { switch (_$$3.h3.tag) { case "DCon": switch (_$$3.h3.h1) { case 0: return Prelude_Just(null, Lib_Types_MkEntry(_$$3.h0, _$$3.h1, _$$3.h2, Lib_Types_DCon("EnumCon", 0, _$$3.h3.h2), _$$3.h4)); default: return Prelude_Nothing(null); } break; default: return Prelude_Nothing(null); } };
const Prelude_Prelude_Applicative$20Prelude_Maybe$2C_$3C$2A$3E_ = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$2.tag) { case "Nothing": return Prelude_Nothing(null); case "Just": return Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, _$$2.h1, _$$3); } };
const Prelude_Prelude_Applicative$20Prelude_Maybe = Prelude_MkApplicative(null, ( a ) => (( _$$1 ) => (Prelude_Just(null, _$$1))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Prelude_Prelude_Applicative$20Prelude_Maybe$2C_$3C$2A$3E_(null, null, eta, eta1))))));
const Lib_Elab_getArity = ( _$$0 ) => { switch (_$$0.tag) { case "Pi": return (1) + (Lib_Elab_getArity(_$$0.h5)); default: return 0; } };
const Lib_ProcessDecl_processData_binderName = ( _, _1, _2, _3, _4, _5, _$$6 ) => (_$$6.h1);
const Lib_ProcessDecl_processShortData = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processShortData_mkPi_getArgs(_$$0, _$$1, _$$2, _$$3, null, null, _$$2, Prelude_Nil(null)), ( $$sc ) => { const ty = Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_ProcessDecl_processShortData_mkPi(_$$0, _$$1, _$$2, _$$3, null, eta, eta1))), Lib_Syntax_RU(_$$1), $$sc.h3); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl(_$$0, _$$1, _$$2, _$$3, null, null, null, $$sc.h3, Prelude_Nil(null), eta)), _$$3), ( cons ) => { const dataDecl = Lib_Syntax_Data(_$$1, $$sc.h2, ty, cons); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("SHORTDATA")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(dataDecl))), Prelude_Lin(null)))) + (""))), ( _1 ) => (Lib_ProcessDecl_processDecl(_$$0, dataDecl))))); }); }));
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty = ( _$$0 ) => { switch (_$$0.tag) { case "Record": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("record"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_prettyBind, _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude__$3A$3A_(null, Prelude_maybe(null, null, Lib_Prettier_empty, ( nm$27 ) => (Lib_Prettier_Seq(Lib_Prettier_Text("constructor"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(nm$27)))), _$$0.h3), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty, _$$0.h4)))))))); case "Instance": return Lib_Prettier_Text("TODO pretty Instance"); case "Class": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("class"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_prettyBind, _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty, _$$0.h3))))))); case "PMixFix": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text(Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow(_$$0.h3)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(Prelude_showInt(_$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Prettier_text, _$$0.h1)))); case "PFunc": switch (_$$0.h2.tag) { case "Nil": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("pfunc"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Text(_$$0.h4)))))); default: return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("pfunc"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("uses"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Prettier_text, _$$0.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":="))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Text(_$$0.h4)))))); } break; case "PType": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("ptype"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Prelude_maybe(null, null, Lib_Prettier_empty, ( ty ) => (Lib_Prettier_Seq(Lib_Prettier_Text(":"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(ty)))), _$$0.h2))); case "ShortData": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("data"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_folddoc(( a ) => (( b ) => (Lib_Prettier_Seq(a, Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("|"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), b)))))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty, _$$0.h2)))); case "Data": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("data"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Prettier_Seq(Lib_Prettier_Text("where"), Lib_Prettier_Seq(Lib_Prettier_line, Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty, _$$0.h3))))))); case "DCheck": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("#check"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2))); case "FunDef": return Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier__$3C$2F$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty_prettyPair(_$$0, _$$0.h0, _$$0.h1, _$$0.h2, null, eta)), _$$0.h2)); case "TypeSig": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_folddoc(( eta ) => (( eta1 ) => (Lib_Prettier_Prelude_Semigroup$20Lib_Prettier_Doc$2C_$3C$2B$3E_(eta, eta1))), Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Prettier_text, _$$0.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Nest(2, Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h2)))); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc = ( _, _1, _2, _$$3, _$$4 ) => { switch (_$$4.tag) { case "RUpdateRec": return Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("TODO RUpdateRec"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("}"))); case "RAs": return Lib_Prettier_Seq(Lib_Prettier_Text(_$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text("@("), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text(")")))); case "RWhere": return Lib_Prettier_Text("TODO pretty where"); case "RIf": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("if"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h1))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("then"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2))))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("else"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h3)))))); case "RDo": return Lib_Prettier_Text("TODO - RDo"); case "RHole": return Lib_Prettier_Text("?"); case "RImplicit": return Lib_Prettier_Text("_"); case "RCase": return Lib_Prettier_Text("TODO - RCase"); case "RLit": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Types_Literal$2Cpretty(_$$4.h1); case "RAnn": return Lib_Prettier_Text("TODO - RAnn"); case "RLet": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text("let"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(_$$4.h1))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h3))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Prettier_Seq(Lib_Prettier_Text("in"), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h4)))))); case "RPi": switch (_$$4.h1.h1) { case "_": switch (_$$4.h1.h2) { case "Explicit": switch (_$$4.h1.h3) { case "Many": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h3)))); default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; default: return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 1, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$4.h1.h3)) + (_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, _$$3, _$$4.h2)))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("->"))), Lib_Prettier_Seq(Lib_Prettier_Alt(Lib_Prettier_Text(" "), Lib_Prettier_line), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 1, _$$4.h3)))); } break; case "RU": return Lib_Prettier_Text("U"); case "RApp": switch (_$$4.h3) { case "Auto": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("{{"))), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text("}}")))); case "Explicit": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 3, _$$4.h2)))); case "Implicit": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 2, _$$4.h1), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("{"))), Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2), Lib_Prettier_Text("}")))); } break; case "RLam": return Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par(_, _1, _$$3, 0, Lib_Prettier_Seq(Lib_Prettier_Text("\\"), Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_wrap(_$$4.h1.h2, Lib_Prettier_Text(_$$4.h1.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("=>"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(_, _1, _2, 0, _$$4.h2))))); case "RVar": return Lib_Prettier_Text(_$$4.h1); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty = ( eta ) => (Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par_asDoc(null, null, null, 0, eta));
const Lib_Syntax_wrap = ( _$$0, _$$1 ) => { switch (_$$0) { case "Auto": return Lib_Prettier_Seq(Lib_Prettier_Text("{{"), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text("}}"))); case "Explicit": return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text(")"))); case "Implicit": return Lib_Prettier_Seq(Lib_Prettier_Text("{"), Lib_Prettier_Seq(_$$1, Lib_Prettier_Text("}"))); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty_bindDoc_par = ( _, _1, _$$2, _$$3, _$$4 ) => { const sc$$5 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, _$$3, _$$2), "LT"); switch (sc$$5) { case "False": return _$$4; case "True": return Lib_Prettier_Seq(Lib_Prettier_Text("("), Lib_Prettier_Seq(_$$4, Lib_Prettier_Text(")"))); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Types_Literal$2Cpretty = ( _$$0 ) => { switch (_$$0.tag) { case "LChar": return Lib_Prettier_Text(Prelude_jsShow(null, _$$0.h0)); case "LInt": return Lib_Prettier_Text(Prelude_showInt(_$$0.h0)); case "LString": return Lib_Prettier_Text(_$$0.h0); } };
const Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty_prettyPair = ( _, _1, _2, _3, _4, _$$5 ) => (Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$5.h2), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text("="))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$5.h3))));
const Lib_Prettier_empty = Lib_Prettier_Empty;
const Prelude_maybe = ( a$$0, b$$1, _$$2, _$$3, _$$4 ) => { switch (_$$4.tag) { case "Nothing": return _$$2; case "Just": return _$$3(_$$4.h1); } };
const Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow = ( _$$0 ) => { switch (_$$0) { case "Infix": return "infix"; case "InfixR": return "infixr"; case "InfixL": return "infixl"; } };
const Lib_Syntax_prettyBind = ( _$$0 ) => (Lib_Syntax_wrap(_$$0.h2.h2, Lib_Prettier_Seq(Lib_Prettier_Seq(Lib_Prettier_Text((Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h2.h3)) + (_$$0.h2.h1)), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Prettier_Text(":"))), Lib_Prettier_Seq(Lib_Prettier_Text(" "), Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$0.h3)))));
const Lib_Syntax_Data = ( h0, h1, h2, h3 ) => ({ tag: "Data",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_ProcessDecl_REC_processShortData_mkPi_getArgs_mkDecl, { tag: "Lib.ProcessDecl.processShortData.mkPi.getArgs.mkDecl",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_ProcessDecl_REC_processShortData_mkPi_getArgs_mkDecl = ( arg ) => { switch (arg.h9.tag) { case "RApp": return { tag: "Lib.ProcessDecl.processShortData.mkPi.getArgs.mkDecl",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Prelude__$3A$3A_(null, arg.h9.h2, arg.h8),  h9: arg.h9.h1 }; case "RVar": { const base = Prelude_foldr(null, null, ( ty ) => (( acc ) => (Lib_Syntax_RPi(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), Lib_Types_BI(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), "_", "Explicit", "Many"), ty, acc))), arg.h2, arg.h8); const ty = Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl_mkPi(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, arg.h9, arg.h9.h0, arg.h9.h1, null, eta, eta1))), base, arg.h7); return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Lib_Syntax_TypeSig(arg.h9.h0, Prelude__$3A$3A_(null, arg.h9.h1, Prelude_Nil(null)), ty)) }; break; } default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h9), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h9))) + (""))), eta)))) }; } };
const Lib_Syntax_TypeSig = ( h0, h1, h2 ) => ({ tag: "TypeSig",  h0: h0,  h1: h1,  h2: h2 });
const Lib_ProcessDecl_processShortData_mkPi_getArgs_mkDecl_mkPi = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _$$13, _$$14 ) => (Lib_Syntax_RPi(_$$13.h2, Lib_Types_BI(_$$13.h2, _$$13.h3, "Implicit", "Zero"), Lib_Syntax_RU(_$$13.h2), _$$14));
const Lib_Syntax_RU = ( h0 ) => ({ tag: "RU",  h0: h0 });
const Lib_Syntax_RPi = ( h0, h1, h2, h3 ) => ({ tag: "RPi",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Prelude_foldr = ( a$$0, b$$1, _$$2, _$$3, _$$4 ) => { switch (_$$4.tag) { case "_::_": return _$$2(_$$4.h1)(Prelude_foldr(null, null, _$$2, _$$3, _$$4.h2)); case "Nil": return _$$3; } };
const Lib_ProcessDecl_processShortData_mkPi = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (Lib_Syntax_RPi(_$$5.h2, Lib_Types_BI(_$$5.h2, _$$5.h3, "Explicit", "Zero"), Lib_Syntax_RU(_$$5.h2), _$$6));
const Lib_ProcessDecl_processShortData_mkPi_getArgs = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_ProcessDecl_REC_processShortData_mkPi_getArgs, { tag: "Lib.ProcessDecl.processShortData.mkPi.getArgs",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_ProcessDecl_REC_processShortData_mkPi_getArgs = ( arg ) => { switch (arg.h6.tag) { case "RApp": switch (arg.h6.h2.tag) { case "RVar": return { tag: "Lib.ProcessDecl.processShortData.mkPi.getArgs",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6.h1,  h7: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h6.h2.h0, arg.h6.h2.h1), arg.h7) }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h6), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h6))) + (""))), eta)))) }; } break; case "RVar": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, arg.h6.h1, arg.h7)) }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(arg.h6), (("Expected contructor application, got: ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(arg.h6))) + (""))), eta)))) }; } };
const Lib_ProcessDecl_processPrimType = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), Prelude_maybe(null, null, Lib_Syntax_RU(_$$1), ( _$$11 ) => (_$$11), _$$3), Lib_Types_VU(_$$1)), ( ty$27 ) => { const arity = Prelude_natToInt(Lib_Util_piArity(ty$27)); return Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, ty$27, Lib_Types_PrimTCon(arity), Prelude_Nil(null)); }))));
const Lib_Types_PrimTCon = ( h0 ) => ({ tag: "PrimTCon",  h0: h0 });
const Lib_ProcessDecl_processPrimFn = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$4, Lib_Types_VU(_$$1)), ( ty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), ty), ( eta ) => (Lib_Eval_quote(Prelude_length$27(null, Prelude_Nil(null)), eta))), ( ty$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ((((((("pfunc ") + (_$$2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), ty$27))), Prelude_Lin(null)))) + (" = ")) + (_$$5)) + (""))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, _$$3, ( name ) => { const sc$$11 = Lib_TopContext_lookupRaw(name, top); switch (sc$$11.tag) { case "Nothing": return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("") + (name)) + (" not in scope"))), eta)))); case "Just": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, sc$$11.h1.h1); } }), ( used$27 ) => { const arity = Lib_Util_piArity(ty$27); return Lib_TopContext_setDef(Lib_Common_QN(_$$0, _$$2), _$$1, ty$27, Lib_Types_PrimFn(_$$5, arity, used$27), Prelude_Nil(null)); }))))))))));
const Lib_Types_PrimFn = ( h0, h1, h2 ) => ({ tag: "PrimFn",  h0: h0,  h1: h1,  h2: h2 });
const Lib_ProcessDecl_processClass = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("Class ") + (_$$2)) + (""))), ( _1 ) => { const fields = Lib_ProcessDecl_getSigs(_$$4); const dcName = (("Mk") + (_$$2)) + (""); const tcType = Lib_ProcessDecl_teleToPi(_$$3, Lib_Syntax_RU(_$$1)); const tail = Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi_mkApp(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, eta, eta1))), Lib_Syntax_RVar(_$$1, _$$2), _$$3); const dcType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, eta, eta1))), tail, fields)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _2 ) => ((("tcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(tcType))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _3 ) => ((("dcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(dcType))), Prelude_Lin(null)))) + (""))), ( _3 ) => { const decl = Lib_Syntax_Data(_$$1, _$$2, tcType, Prelude__$3A$3A_(null, Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(null, dcName, Prelude_Nil(null)), dcType), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _4 ) => ("Decl:")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, decl), ( _6 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => ("MkUnit"), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, fields, ( $$case ) => { const funType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Lib_Syntax_RPi($$case.h2, Lib_Types_BI($$case.h2, "_", "Auto", "Many"), tail, $$case.h3.h3)); const autoPat = Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_ProcessDecl_processClass_makeLHS_mkAutoApp(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, eta, eta1))), Lib_Syntax_RVar(_$$1, dcName), fields); const lhs = Lib_ProcessDecl_processClass_makeLHS(_$$0, _$$1, _$$2, _$$3, _$$4, null, Lib_Syntax_RVar($$case.h2, $$case.h3.h2), _$$3); const lhs1 = Lib_Syntax_RApp(_$$1, lhs, autoPat, "Auto"); const decl1 = Lib_Syntax_FunDef($$case.h2, $$case.h3.h2, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, lhs1, Lib_Syntax_RVar($$case.h2, $$case.h3.h2)), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _7 ) => ((((("") + ($$case.h3.h2)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(funType))), Prelude_Lin(null)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _8 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl1))), Prelude_Lin(null)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, Lib_Syntax_TypeSig($$case.h2, Prelude__$3A$3A_(null, $$case.h3.h2, Prelude_Nil(null)), funType)), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setFlag(Lib_Common_QN(_$$0, $$case.h3.h2), $$case.h2, "Inline"), ( _10 ) => (Lib_ProcessDecl_processDecl(_$$0, decl1))))))))); })))))))); }))); }))));
const Lib_ProcessDecl_processClass_makeLHS = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case "_::_": return Lib_Syntax_RApp(_$$7.h1.h2.h0, Lib_ProcessDecl_processClass_makeLHS(_, _1, _2, _3, _4, _5, _$$6, _$$7.h2), Lib_Syntax_RVar(_$$7.h1.h2.h0, _$$7.h1.h2.h1), "Implicit"); case "Nil": return _$$6; } };
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8 ) => (Lib_Syntax_RApp(_$$8.h2, _$$7, Lib_Syntax_RVar(_$$8.h2, _$$8.h3.h2), "Explicit"));
const Lib_ProcessDecl_impTele = ( _$$0 ) => (Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_ProcessDecl_impTele_foo(_$$0, null, eta)), _$$0));
const Lib_ProcessDecl_impTele_foo = ( _, _1, _$$2 ) => (Prelude__$2C_(null, null, Lib_Types_BI(_$$2.h2.h0, _$$2.h2.h1, "Implicit", "Zero"), _$$2.h3));
const Lib_ProcessDecl_teleToPi = ( _$$0, _$$1 ) => { switch (_$$0.tag) { case "_::_": return Lib_Syntax_RPi(_$$0.h1.h2.h0, _$$0.h1.h2, _$$0.h1.h3, Lib_ProcessDecl_teleToPi(_$$0.h2, _$$1)); case "Nil": return _$$1; } };
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => (Lib_Syntax_RPi(_$$8.h2, Lib_Types_BI(_$$8.h2, _$$8.h3.h2, "Explicit", "Many"), _$$8.h3.h3, _$$9));
const Lib_ProcessDecl_processClass_makeLHS_mkAutoApp_mkPi_mkApp = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10 ) => (Lib_Syntax_RApp(_$$10.h2.h0, _$$9, Lib_Syntax_RVar(_$$10.h2.h0, _$$10.h2.h1), _$$10.h2.h2));
const Lib_ProcessDecl_getSigs = ( _$$0 ) => (bouncer(Lib_ProcessDecl_REC_getSigs, { tag: "Lib.ProcessDecl.getSigs",  h0: _$$0 }));
const Lib_ProcessDecl_REC_getSigs = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1.tag) { case "TypeSig": switch (arg.h0.h1.h1.tag) { case "_::_": return { tag: "return",  h0: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, arg.h0.h1.h0, Prelude__$2C_(null, null, arg.h0.h1.h1.h1, arg.h0.h1.h2)), Lib_ProcessDecl_getSigs(arg.h0.h2)) }; case "Nil": return { tag: "Lib.ProcessDecl.getSigs",  h0: arg.h0.h2 }; } break; default: return { tag: "Lib.ProcessDecl.getSigs",  h0: arg.h0.h2 }; } break; case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_ProcessDecl_processInstance = ( _$$0, _$$1, _$$2, _$$3 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ((("Instance ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(_$$2))), Prelude_Lin(null)))) + (""))), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const tyFC = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Elab_check(Lib_Types_MkCtx(0, Prelude_Nil(null), Prelude_Nil(null), Prelude_Nil(null), _$$1), _$$2, Lib_Types_VU(_$$1)), ( vty ) => { const sc$$13 = Lib_Util_splitTele(vty); const env = Lib_ProcessDecl_processInstance_getFields_tenv(_$$0, _$$1, _$$2, _$$3, null, null, Prelude_length(null, sc$$13.h3)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _2 ) => ((("codomain ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$13.h2))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _3 ) => ((("tele is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Util_Prelude_Show$20Lib_Util_Binder$2Cshow, sc$$13.h3)))) + (""))), ( _3 ) => { const instname = Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$13.h2))), Prelude_Lin(null)); const sigDecl = Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(null, instname, Prelude_Nil(null)), _$$2); const sc$$23 = Lib_TopContext_lookupRaw(instname, top); switch (sc$$23.tag) { case "Nothing": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, sigDecl), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setFlag(Lib_Common_QN(_$$0, instname), _$$1, "Hint"), ( _5 ) => (Lib_TopContext_addHint(Lib_Common_QN(_$$0, instname)))))), ( _4 ) => { const sc$$24 = Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, Lib_Elab_collectDecl, _$$3); switch (sc$$24.tag) { case "Just": { const sc$$27 = Lib_Util_funArgs(sc$$13.h2); switch (sc$$27.h2.tag) { case "Ref": { const sc$$34 = Lib_TopContext_lookup(sc$$27.h2.h1, top); switch (sc$$34.tag) { case "Just": switch (sc$$34.h1.h3.tag) { case "TCon": switch (sc$$34.h1.h3.h1.tag) { case "_::_": switch (sc$$34.h1.h3.h1.h2.tag) { case "Nil": { const sc$$49 = Lib_TopContext_lookup(sc$$34.h1.h3.h1.h1, top); switch (sc$$49.tag) { case "Just": switch (sc$$49.h1.h3.tag) { case "DCon": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$49.h1.h2), ( $$sc ) => { switch ($$sc.tag) { case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("dcty ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$49.h1.h2))), Prelude_Lin(null)))) + (""))), ( _5 ) => { const sc$$69 = Lib_Util_funArgs(sc$$13.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((("traverse ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_showTm, sc$$69.h3))))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(env, eta)), sc$$69.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _7 ) => ((("args' is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, args$27)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_$$0, _$$1, _$$2, _$$3, null, null, null, null, $$sc, args$27), ( appty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processInstance_getFields(_$$0, _$$1, _$$2, _$$3, null, appty, env, Prelude_Nil(null)), ( conTele ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, conTele, ( $$case ) => { switch ($$case.h2) { case "Explicit": { const ty$27 = Prelude_foldr(null, null, ( x ) => (( acc ) => (Lib_Types_Pi(x.h0, x.h1, x.h2, x.h3, x.h4, acc))), $$case.h4, sc$$13.h3); const nm$27 = (((("") + (instname)) + (",")) + ($$case.h1)) + (""); const sc$$88 = Prelude_find(null, ( x ) => { switch (x.tag) { case "FunDef": return Prelude_jsEq(null, x.h1, $$case.h1); default: return "False"; } }, sc$$24.h1); switch (sc$$88.tag) { case "Just": switch (sc$$88.h1.tag) { case "FunDef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm$27), sc$$88.h1.h0, ty$27, Lib_Types_Axiom, Prelude_Nil(null)), ( _8 ) => { const decl = Lib_Syntax_FunDef(sc$$88.h1.h0, nm$27, sc$$88.h1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _9 ) => ("***")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _10 ) => ((((("") + (nm$27)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), ty$27))), Prelude_Lin(null)))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _11 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, decl)))))))); }); default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))); } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), defs), ( decl ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _8 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))), ( _8 ) => { const decl = Lib_Syntax_FunDef(_$$1, instname, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, Lib_Syntax_RVar(_$$1, instname), Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS(_$$0, _$$1, _$$2, _$$3, null, null, null, instname, conTele, Lib_Syntax_RVar(_$$1, sc$$34.h1.h3.h1.h1.h1))), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _9 ) => ("SIGDECL")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _10 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(sigDecl))), Prelude_Lin(null)))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _11 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))))); }))))))))))))); }); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC($$sc), "dcty not Pi")), eta)))); } }); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, sc$$34.h1.h3.h1)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, sc$$34.h1.h3.h1)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$13.h2))), Prelude_Lin(null)))) + (" doesn't appear to be a TCon application"))), eta)))); } break; } default: return Lib_Types_log(2, ( _5 ) => ((("Forward declaration ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(sigDecl))) + (""))); } }); case "Just": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"), ( _4 ) => { const sc$$24 = Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, Lib_Elab_collectDecl, _$$3); switch (sc$$24.tag) { case "Just": { const sc$$27 = Lib_Util_funArgs(sc$$13.h2); switch (sc$$27.h2.tag) { case "Ref": { const sc$$34 = Lib_TopContext_lookup(sc$$27.h2.h1, top); switch (sc$$34.tag) { case "Just": switch (sc$$34.h1.h3.tag) { case "TCon": switch (sc$$34.h1.h3.h1.tag) { case "_::_": switch (sc$$34.h1.h3.h1.h2.tag) { case "Nil": { const sc$$49 = Lib_TopContext_lookup(sc$$34.h1.h3.h1.h1, top); switch (sc$$49.tag) { case "Just": switch (sc$$49.h1.h3.tag) { case "DCon": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude_Nil(null), sc$$49.h1.h2), ( $$sc ) => { switch ($$sc.tag) { case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _5 ) => ((("dcty ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$49.h1.h2))), Prelude_Lin(null)))) + (""))), ( _5 ) => { const sc$$69 = Lib_Util_funArgs(sc$$13.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _6 ) => ((("traverse ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_showTm, sc$$69.h3))))) + (""))), ( _6 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, ( eta ) => (Lib_Eval_eval(env, eta)), sc$$69.h3), ( args$27 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _7 ) => ((("args' is ") + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow, args$27)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_$$0, _$$1, _$$2, _$$3, null, null, null, null, $$sc, args$27), ( appty ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processInstance_getFields(_$$0, _$$1, _$$2, _$$3, null, appty, env, Prelude_Nil(null)), ( conTele ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, conTele, ( $$case ) => { switch ($$case.h2) { case "Explicit": { const ty$27 = Prelude_foldr(null, null, ( x ) => (( acc ) => (Lib_Types_Pi(x.h0, x.h1, x.h2, x.h3, x.h4, acc))), $$case.h4, sc$$13.h3); const nm$27 = (((("") + (instname)) + (",")) + ($$case.h1)) + (""); const sc$$88 = Prelude_find(null, ( x ) => { switch (x.tag) { case "FunDef": return Prelude_jsEq(null, x.h1, $$case.h1); default: return "False"; } }, sc$$24.h1); switch (sc$$88.tag) { case "Just": switch (sc$$88.h1.tag) { case "FunDef": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_setDef(Lib_Common_QN(_$$0, nm$27), sc$$88.h1.h0, ty$27, Lib_Types_Axiom, Prelude_Nil(null)), ( _8 ) => { const decl = Lib_Syntax_FunDef(sc$$88.h1.h0, nm$27, sc$$88.h1.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _9 ) => ("***")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _10 ) => ((((("") + (nm$27)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), ty$27))), Prelude_Lin(null)))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _11 ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, decl)))))))); }); default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_$$1, (("no definition for ") + ($$case.h1)) + (""))), eta)))); } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }), ( defs ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, Prelude_mapMaybe(null, null, ( _$$11 ) => (_$$11), defs), ( decl ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(2, ( _8 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _8 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))), ( _8 ) => { const decl = Lib_Syntax_FunDef(_$$1, instname, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, Lib_Syntax_RVar(_$$1, instname), Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS(_$$0, _$$1, _$$2, _$$3, null, null, null, instname, conTele, Lib_Syntax_RVar(_$$1, sc$$34.h1.h3.h1.h1.h1))), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _9 ) => ("SIGDECL")), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _10 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(sigDecl))), Prelude_Lin(null)))) + (""))), ( _10 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _11 ) => (Lib_Prettier_layout(Lib_Prettier_best(80, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _11 ) => (Lib_ProcessDecl_processDecl(_$$0, decl))))))); }))))))))))))); }); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Types_getValFC($$sc), "dcty not Pi")), eta)))); } }); default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("can't find constructor ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$34.h1.h3.h1.h1))) + (""))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, sc$$34.h1.h3.h1)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (((("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" has multiple constructors ")) + (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow, sc$$34.h1.h3.h1)))) + (""))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } break; default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(sc$$27.h2.h1))) + (" is not a type constructor"))), eta)))); } break; } default: return Lib_Types_MkM(null, ( _5 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(tyFC, (("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Types_pprint$27(0, Prelude_Nil(null), sc$$13.h2))), Prelude_Lin(null)))) + (" doesn't appear to be a TCon application"))), eta)))); } break; } default: return Lib_Types_log(2, ( _5 ) => ((("Forward declaration ") + (Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow(sigDecl))) + (""))); } }); } }))); }); }))))));
const Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow = ( _$$0 ) => { switch (_$$0.tag) { case "Record": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Record", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta)), _$$0.h2)), Prelude__$3A$3A_(null, Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Prelude_Prelude_Show$20Prim_String, _$$0.h3), Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow, _$$0.h4)), Prelude_Nil(null)))))))) + (")")); case "Instance": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Instance", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Prelude_Prelude_Show$20Prim_String, Prelude_Prelude_Functor$20Prelude_Maybe$2Cmap(null, null, ( _$$2 ) => (Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow, _$$2))), _$$0.h2)), Prelude_Nil(null)))))) + (")")); case "Class": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Class", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, "...", Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow, _$$0.h3))), Prelude_Nil(null))))))) + (")")); case "PMixFix": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PMixFix", Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$0.h1)), Prelude__$3A$3A_(null, Prelude_showInt(_$$0.h2), Prelude__$3A$3A_(null, Lib_Common_Prelude_Show$20Lib_Common_Fixity$2Cshow(_$$0.h3), Prelude_Nil(null))))))) + (")")); case "PFunc": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PFunc", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$0.h2)), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h3), Prelude__$3A$3A_(null, _$$0.h4, Prelude_Nil(null)))))))) + (")")); case "PType": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "PType", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Prelude_Prelude_Show$20$28Prelude_Maybe$20BND$3A1$29$2Cshow(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, _$$0.h2), Prelude_Nil(null)))))) + (")")); case "ShortData": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "ShortData", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow, _$$0.h2)), Prelude_Nil(null)))))) + (")")); case "Data": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "Data", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Decl$2Cshow, _$$0.h3)), Prelude_Nil(null))))))) + (")")); case "DCheck": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "DCheck", Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h1), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); case "FunDef": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "FunDef", Prelude__$3A$3A_(null, _$$0.h1, Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Prelude_Prelude_Show$20$28Prelude__$D7_$20BND$3A3$20BND$3A2$29$2Cshow(null, null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw, eta)), _$$0.h2)), Prelude_Nil(null)))))) + (")")); case "TypeSig": return ("(") + ((Prelude_joinBy(" ", Prelude__$3A$3A_(null, "TypeSig", Prelude__$3A$3A_(null, Prelude_joinBy(", ", Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, Prelude_Prelude_Show$20Prim_String$2Cshow, _$$0.h1)), Prelude__$3A$3A_(null, Lib_Syntax_Prelude_Show$20Lib_Syntax_Raw$2Cshow(_$$0.h2), Prelude_Nil(null)))))) + (")")); } };
const Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo = Prelude_MkShow(null, Lib_Syntax_Prelude_Show$20Lib_Types_BindInfo$2Cshow);
const Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS = ( _, _1, _2, _3, _4, _5, _6, _$$7, _$$8, _$$9 ) => (bouncer(Lib_ProcessDecl_REC_processInstance_getFields_tenv_mkRHS, { tag: "Lib.ProcessDecl.processInstance.getFields.tenv.mkRHS",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7,  h8: _$$8,  h9: _$$9 }));
const Lib_ProcessDecl_REC_processInstance_getFields_tenv_mkRHS = ( arg ) => { switch (arg.h8.tag) { case "_::_": switch (arg.h8.h1.h2) { case "Explicit": return { tag: "Lib.ProcessDecl.processInstance.getFields.tenv.mkRHS",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2,  h9: Lib_Syntax_RApp(arg.h8.h1.h0, arg.h9, Lib_Syntax_RVar(arg.h8.h1.h0, (((("") + (arg.h7)) + (",")) + (arg.h8.h1.h1)) + ("")), "Explicit") }; default: return { tag: "Lib.ProcessDecl.processInstance.getFields.tenv.mkRHS",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2,  h9: arg.h9 }; } break; case "Nil": return { tag: "return",  h0: arg.h9 }; } };
const Lib_ProcessDecl_processInstance_getFields = ( _, _1, _2, _3, _4, _$$5, _$$6, _$$7 ) => { switch (_$$5.tag) { case "VPi": switch (_$$5.h2) { case "Explicit": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( eta ) => (Lib_Util_MkBinder(_$$5.h0, _$$5.h1, "Explicit", _$$5.h3, eta)), Lib_Eval_quote(Prelude_length$27(null, _$$6), _$$5.h4)), ( bnd ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$5.h0, Prelude_length$27(null, _$$6), Prelude_Lin(null)), _$$5.h5.h0), _$$5.h5.h1), ( appsc ) => (Lib_ProcessDecl_processInstance_getFields(_, _1, _2, _3, _4, appsc, _$$6, Prelude__$3A$3A_(null, bnd, _$$7)))))); default: return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, Lib_Types_VVar(_$$5.h0, Prelude_length$27(null, _$$6), Prelude_Lin(null)), _$$5.h5.h0), _$$5.h5.h1), ( appsc ) => (Lib_ProcessDecl_processInstance_getFields(_, _1, _2, _3, _4, appsc, _$$6, _$$7))); } break; default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_reverse(null)(_$$7)); } };
const Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9 ) => { switch (_$$9.tag) { case "_::_": switch (_$$8.tag) { case "VPi": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Eval_eval(Prelude__$3A$3A_(null, _$$9.h1, _$$8.h5.h0), _$$8.h5.h1), ( bx ) => (Lib_ProcessDecl_processInstance_getFields_tenv_mkRHS_apply(_, _1, _2, _3, _4, _5, _6, _7, bx, _$$9.h2))); default: return Lib_Types_MkM(null, ( _8 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(_1, (("expected pi type ") + (Lib_Types_Prelude_Show$20Lib_Types_Val$2Cshow(_$$8))) + (""))), eta)))); } break; case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, _$$8); } };
const Lib_Types_showTm = Lib_Types_Prelude_Show$20Lib_Types_Tm$2Cshow;
const Lib_TopContext_addHint = ( _$$0 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const sc$$2 = Lib_TopContext_lookup(_$$0, top); switch (sc$$2.tag) { case "Nothing": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "Just": { const sc$$5 = Lib_TopContext_typeName(sc$$2.h1.h2); switch (sc$$5.tag) { case "Nothing": return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(sc$$2.h1.h0, (("can't find tcon name for ") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (""))), eta)))); case "Just": { const xs = Prelude_fromMaybe(null, Prelude_Nil(null), Data_SortedMap_lookupMap$27(null, null, sc$$5.h1, top.h2)); const hints = Data_SortedMap_updateMap(null, null, sc$$5.h1, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, _$$0, sc$$2.h1.h2), xs), top.h2); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_putTop(Lib_Types_MkTop(top.h0, top.h1, hints, top.h3, top.h4, top.h5, top.h6, top.h7, top.h8)), ( _ ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"))); break; } } break; } } }));
const Lib_TopContext_typeName = ( _$$0 ) => (bouncer(Lib_TopContext_REC_typeName, { tag: "Lib.TopContext.typeName",  h0: _$$0 }));
const Lib_TopContext_REC_typeName = ( arg ) => { switch (arg.h0.tag) { case "Pi": switch (arg.h0.h2) { case "Explicit": return { tag: "return",  h0: Prelude_Nothing(null) }; default: return { tag: "Lib.TopContext.typeName",  h0: arg.h0.h5 }; } break; case "App": return { tag: "Lib.TopContext.typeName",  h0: arg.h0.h1 }; case "Ref": return { tag: "return",  h0: Prelude_Just(null, arg.h0.h1) }; default: return { tag: "return",  h0: Prelude_Nothing(null) }; } };
const Lib_Util_Prelude_Show$20Lib_Util_Binder$2Cshow = ( _$$0 ) => ((((((("[") + (Lib_Types_Prelude_Show$20Lib_Types_Quant$2Cshow(_$$0.h3))) + ("")) + (_$$0.h1)) + (" ")) + (Lib_Types_Prelude_Show$20Lib_Types_Icit$2Cshow(_$$0.h2))) + (" : ...]"));
const Lib_ProcessDecl_processInstance_getFields_tenv = ( _, _1, _2, _3, _4, _5, _$$6 ) => { switch (_$$6) { case 0: return Prelude_Nil(null); default: { const x = (_$$6) - (1); return Prelude__$3A$3A_(null, Lib_Types_VVar(Lib_Common_emptyFC, Prelude_natToInt(x), Prelude_Lin(null)), Lib_ProcessDecl_processInstance_getFields_tenv(_, _1, _2, _3, _4, _5, x)); break; } } };
const Lib_ProcessDecl_processRecord = ( _$$0, _$$1, _$$2, _$$3, _$$4, _$$5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _ ) => ("-----")), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _1 ) => ("Record")), ( _1 ) => { const fields = Lib_ProcessDecl_getSigs(_$$5); const dcName = Prelude_fromMaybe(null, (("Mk") + (_$$2)) + (""), _$$4); const tcType = Lib_ProcessDecl_teleToPi(_$$3, Lib_Syntax_RU(_$$1)); const tail = Prelude_foldl(null, null, ( acc ) => (( bi ) => (Lib_Syntax_RApp(bi.h2.h0, acc, Lib_Syntax_RVar(bi.h2.h0, bi.h2.h1), bi.h2.h2))), Lib_Syntax_RVar(_$$1, _$$2), _$$3); const dcType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Prelude_foldr(null, null, ( x ) => (( acc ) => (Lib_Syntax_RPi(x.h2, Lib_Types_BI(x.h2, x.h3.h2, "Explicit", "Many"), x.h3.h3, acc))), tail, fields)); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _2 ) => ((("tcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(tcType))), Prelude_Lin(null)))) + (""))), ( _2 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _3 ) => ((("dcon type ") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(dcType))), Prelude_Lin(null)))) + (""))), ( _3 ) => { const decl = Lib_Syntax_Data(_$$1, _$$2, tcType, Prelude__$3A$3A_(null, Lib_Syntax_TypeSig(_$$1, Prelude__$3A$3A_(null, dcName, Prelude_Nil(null)), dcType), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _4 ) => ("Decl:")), ( _4 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _5 ) => (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(decl))), Prelude_Lin(null)))), ( _5 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, decl), ( _6 ) => (Lib_Types_Prelude_Functor$20Lib_Types_M$2Cmap(null, null, ( _$$31 ) => ("MkUnit"), Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Types_Prelude_Applicative$20Lib_Types_M, null, null, fields, ( $$case ) => { const funType = Lib_ProcessDecl_teleToPi(Lib_ProcessDecl_impTele(_$$3), Lib_Syntax_RPi($$case.h2, Lib_Types_BI($$case.h2, "_", "Explicit", "Many"), tail, $$case.h3.h3)); const autoPat = Prelude_foldl(null, null, ( acc ) => (( x ) => (Lib_Syntax_RApp(x.h2, acc, Lib_Syntax_RVar(x.h2, x.h3.h2), "Explicit"))), Lib_Syntax_RVar(_$$1, dcName), fields); const pname = (".") + ($$case.h3.h2); const lhs = Prelude_foldl(null, null, ( acc ) => (( x ) => (Lib_Syntax_RApp(x.h2.h0, acc, Lib_Syntax_RVar(x.h2.h0, x.h2.h1), "Implicit"))), Lib_Syntax_RVar($$case.h2, pname), _$$3); const lhs1 = Lib_Syntax_RApp(_$$1, lhs, autoPat, "Explicit"); const pdecl = Lib_Syntax_FunDef($$case.h2, pname, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, lhs1, Lib_Syntax_RVar($$case.h2, $$case.h3.h2)), Prelude_Nil(null))); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _7 ) => ((((("") + (pname)) + (" : ")) + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Raw$2Cpretty(funType))), Prelude_Lin(null)))) + (""))), ( _7 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_log(1, ( _8 ) => ((("") + (Lib_Prettier_layout(Lib_Prettier_best(90, 0, Lib_Prettier_noAlt(Lib_Syntax_Lib_Prettier_Pretty$20Lib_Syntax_Decl$2Cpretty(pdecl))), Prelude_Lin(null)))) + (""))), ( _8 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, Lib_Syntax_TypeSig($$case.h2, Prelude__$3A$3A_(null, pname, Prelude_Nil(null)), funType)), ( _9 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_ProcessDecl_processDecl(_$$0, pdecl), ( _10 ) => (Lib_TopContext_setFlag(Lib_Common_QN(_$$0, pname), $$case.h2, "Inline"))))))))); })))))))); }))); }))));
const Main_importHints = ( _$$0 ) => { switch (_$$0.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(null, Lib_Types_Prelude_Eq$20Lib_Types_EFlag, "Hint", _$$0.h1.h4), ( _ ) => (Lib_TopContext_addHint(_$$0.h1.h1))), ( _ ) => (Main_importHints(_$$0.h2))); case "Nil": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); } };
const Main_parseDecls = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Main_REC_parseDecls, { tag: "Main.parseDecls",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Main_REC_parseDecls = ( arg ) => { switch (arg.h2.tag) { case "_::_": { const sc$$8 = Lib_Parser_Impl_partialParse(null, arg.h0, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseDecl), arg.h1, arg.h2); switch (sc$$8.tag) { case "Right": return { tag: "Main.parseDecls",  h0: arg.h0,  h1: sc$$8.h2.h3.h2,  h2: sc$$8.h2.h3.h3,  h3: Prelude__$3A$3C_(null, arg.h3, sc$$8.h2.h2) }; case "Left": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn(Lib_Common_showError("", sc$$8.h2.h2))), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_TopContext_addError(sc$$8.h2.h2), ( _1 ) => (Main_parseDecls(arg.h0, arg.h1, Main_parseDecls_recover(arg.h0, arg.h1, arg.h2, arg.h3, arg.h2.h0, arg.h2.h1, arg.h2.h2, null, sc$$8.h2.h3), arg.h3))))) }; } break; } case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Prelude__$3C$3E$3E_(null, arg.h3, Prelude_Nil(null)), arg.h1)) }; } };
const Main_parseDecls_recover = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8 ) => (bouncer(Main_REC_parseDecls_recover, { tag: "Main.parseDecls.recover",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _7,  h8: _$$8 }));
const Main_REC_parseDecls_recover = ( arg ) => { switch (arg.h8.tag) { case "_::_": { const sc$$12 = Prelude__$26$26_(Prelude_jsEq(null, arg.h8.h1.h2.h1, 0), Prelude_not(Lib_Token_Prelude_Eq$20Lib_Token_Bounds$2C_$3D$3D_(arg.h8.h1.h2, arg.h5.h2))); switch (sc$$12) { case "False": return { tag: "Main.parseDecls.recover",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8.h2 }; case "True": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h8.h1, arg.h8.h2) }; } break; } case "Nil": return { tag: "return",  h0: Prelude_Nil(null) }; } };
const Lib_Token_Prelude_Eq$20Lib_Token_Bounds$2C_$3D$3D_ = ( _$$0, _$$1 ) => (Prelude__$26$26_(Prelude_jsEq(null, _$$0.h0, _$$1.h0), Prelude__$26$26_(Prelude_jsEq(null, _$$0.h1, _$$1.h1), Prelude__$26$26_(Prelude_jsEq(null, _$$0.h2, _$$1.h2), Prelude_jsEq(null, _$$0.h3, _$$1.h3)))));
const Lib_Syntax_Record = ( h0, h1, h2, h3, h4 ) => ({ tag: "Record",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Parser_Impl_OK = ( h0, h1, h2, h3, h4 ) => ({ tag: "OK",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Parser_Impl_P = ( h0, h1 ) => ({ tag: "P",  h0: h0,  h1: h1 });
const Lib_Parser_Impl_keyword$27 = ( _$$0 ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( _$$3 ) => ("MkUnit"), Lib_Parser_Impl_satisfy(( t ) => (Prelude__$26$26_(Prelude_jsEq(null, t.h1.h1, _$$0), Prelude__$7C$7C_(Prelude_jsEq(null, Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0), Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow("Keyword")), Prelude__$7C$7C_(Prelude_jsEq(null, Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0), Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow("Symbol")), Prelude_jsEq(null, Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0), Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow("Number")))))), (("Expected ") + (_$$0)) + (""))));
const Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow = ( _$$0 ) => { switch (_$$0) { case "EndInterp": return "EndInterp"; case "StartInterp": return "StartInterp"; case "EndQuote": return "EndQuote"; case "StartQuote": return "StartQuote"; case "EOI": return "EOI"; case "RBrace": return "RBrace"; case "Semi": return "Semi"; case "LBrace": return "LBrace"; case "Projection": return "Projection"; case "Pragma": return "Pragma"; case "Comment": return "Comment"; case "Space": return "Space"; case "Symbol": return "Symbol"; case "JSLit": return "JSLit"; case "StringKind": return "String"; case "Character": return "Character"; case "Number": return "Number"; case "MixFix": return "MixFix"; case "Keyword": return "Keyword"; case "UIdent": return "UIdent"; case "Ident": return "Ident"; } };
const Lib_Parser_Impl_satisfy = ( _$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { switch (toks.tag) { case "_::_": { const sc$$10 = _$$0(toks.h1); switch (sc$$10) { case "False": return Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(col.h0, toks, (((((("") + (_$$1)) + (" at ")) + (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(toks.h1.h1.h0))) + (":")) + (toks.h1.h1.h1)) + ("")), toks, com, ops); case "True": return Lib_Parser_Impl_OK(null, toks.h1.h1.h1, toks.h2, "True", ops); } break; } case "Nil": return Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(col.h0, toks, (("") + (_$$1)) + (" at EOF")), toks, com, ops); } })))));
const Lib_Parser_Impl_perror = ( _$$0, _$$1, _$$2 ) => { switch (_$$1.tag) { case "_::_": return Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, _$$1.h1.h2.h0, _$$1.h1.h2.h1)), _$$2); case "Nil": return Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, 0, 0)), _$$2); } };
const Lib_Parser_Impl_Fail = ( h0, h1, h2, h3, h4, h5 ) => ({ tag: "Fail",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4,  h5: h5 });
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Result$2Cmap(null, null, _$$2, _$$3.h1(toks)(com)(ops)(col))))))));
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Result$2Cmap = ( a$$0, b$$1, _$$2, _$$3 ) => { switch (_$$3.tag) { case "Fail": return Lib_Parser_Impl_Fail(null, _$$3.h1, _$$3.h2, _$$3.h3, _$$3.h4, _$$3.h5); case "OK": return Lib_Parser_Impl_OK(null, _$$2(_$$3.h1), _$$3.h2, _$$3.h3, _$$3.h4); } };
const Lib_Parser_Impl_indented = ( a$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( indent ) => { switch (toks.tag) { case "_::_": { const sc$$12 = Prelude__$2C_(null, null, toks.h1.h2.h0, toks.h1.h2.h1); const sc$$17 = Prelude__$7C$7C_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$12.h3, indent.h1.h3), "GT"), Prelude_jsEq(null, sc$$12.h2, indent.h1.h2)); switch (sc$$17) { case "False": return Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(indent.h0, toks, "unexpected outdent"), toks, com, ops); case "True": return _$$1.h1(toks)(com)(ops)(indent); } break; } case "Nil": return _$$1.h1(toks)(com)(ops)(indent); } })))));
const Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_ = ( a$$0, _$$1, _$$2 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$11 = _$$1.h1(toks)("False")(ops)(col); switch (sc$$11.tag) { case "Fail": switch (sc$$11.h1) { case "True": return Lib_Parser_Impl_Fail(null, "True", sc$$11.h2, sc$$11.h3, sc$$11.h4, sc$$11.h5); default: switch (sc$$11.h4) { case "False": return _$$2.h1(toks)(com)(sc$$11.h5)(col); case "True": return Lib_Parser_Impl_Fail(null, sc$$11.h1, sc$$11.h2, sc$$11.h3, "True", sc$$11.h5); } break; } break; case "OK": return Lib_Parser_Impl_OK(null, sc$$11.h1, sc$$11.h2, com, sc$$11.h4); } })))));
const Lib_Parser_arrow = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("->")), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("")));
const Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_ = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$12 = _$$2.h1(toks)(com)(ops)(col); switch (sc$$12.tag) { case "Fail": return Lib_Parser_Impl_Fail(null, sc$$12.h1, sc$$12.h2, sc$$12.h3, sc$$12.h4, sc$$12.h5); case "OK": { const sc$$18 = _$$3.h1(sc$$12.h2)(sc$$12.h3)(sc$$12.h4)(col); switch (sc$$18.tag) { case "Fail": return Lib_Parser_Impl_Fail(null, sc$$18.h1, sc$$18.h2, sc$$18.h3, sc$$18.h4, sc$$18.h5); case "OK": return Lib_Parser_Impl_OK(null, sc$$12.h1(sc$$18.h1), sc$$18.h2, sc$$18.h3, sc$$18.h4); } break; } } })))));
const Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser = Prelude_MkApplicative(null, ( a ) => (( _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, _$$1, toks, com, ops)))))))), ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, eta, eta1))))));
const Prelude_MkFunctor = ( h0, h1 ) => ({ tag: "MkFunctor",  h0: h0,  h1: h1 });
const Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser = Prelude_MkFunctor(null, ( a ) => (( b ) => (( eta ) => (( eta1 ) => (Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, eta, eta1))))));
const Prelude__$2A$3E_ = ( f$$0, a$$1, b$$2, _$$3, _$$4, _$$5, _$$6 ) => (Prelude__$3C$2A$3E_(null, _$$4)(null)(null)(Prelude_map(null, _$$3)(null)(null)(( _$$31 ) => (( _$$1 ) => (_$$1)))(_$$5))(_$$6));
const Prelude_map = ( m$$0, _$$1 ) => (( a ) => (( b ) => (_$$1.h1(null)(null))));
const Lib_Parser_optional = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (Prelude_Just(null, eta)), _$$1), Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_Nothing(null), toks, com, ops))))))));
const Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind = ( a$$0, b$$1, _$$2, _$$3 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$10 = _$$2.h1(toks)(com)(ops)(col); switch (sc$$10.tag) { case "Fail": return Lib_Parser_Impl_Fail(null, sc$$10.h1, sc$$10.h2, sc$$10.h3, sc$$10.h4, sc$$10.h5); case "OK": return Lib_Parser_Impl_runP(null, _$$3(sc$$10.h1))(sc$$10.h2)(sc$$10.h3)(sc$$10.h4)(col); } })))));
const Lib_Parser_Impl_runP = ( a$$0, _$$1 ) => (_$$1.h1);
const Lib_Parser_term_apply = ( _, _$$1, _$$2 ) => { switch (_$$2.tag) { case "_::_": return Lib_Syntax_RApp(_$$2.h1.h2, _$$1, Lib_Parser_term_apply(_, _$$2.h1.h3, _$$2.h2), "Explicit"); case "Nil": return _$$1; } };
const Lib_Parser_Impl_fail = ( a$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(col.h0, toks, _$$1), toks, com, ops)))))));
const Lib_Parser_pratt = ( _$$0, _$$1, _$$2, _$$3, _$$4 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_pratt_projectHead_runProject_runRule_runPrefix(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, null, _$$2, _$$3, _$$4), ( $$sc ) => { const sc$$15 = Lib_Parser_pratt_projectHead(_$$0, _$$1, _$$2, _$$3, _$$4, null, $$sc.h2, $$sc.h3); const spine = Lib_Parser_pratt_projectHead_runProject(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, sc$$15.h3); switch (spine.tag) { case "_::_": switch (spine.h1.h2) { case "Explicit": switch (spine.h1.h3.h3.tag) { case "RVar": { const sc$$35 = Prelude_jsEq(null, spine.h1.h3.h3.h1, _$$2); switch (sc$$35) { case "False": { const sc$$36 = Data_SortedMap_lookupMap$27(null, null, spine.h1.h3.h3.h1, _$$0); switch (sc$$36.tag) { case "Nothing": { const sc$$38 = Prelude_isPrefixOf(".", spine.h1.h3.h3.h1); switch (sc$$38) { case "False": return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2), sc$$15.h2, spine.h1.h3.h3, "Explicit"), spine.h2); case "True": return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(spine.h1.h3.h3), spine.h1.h3.h3, sc$$15.h2, "Explicit"), spine.h2); } break; } case "Just": switch (sc$$36.h1.h3) { case "False": { const sc$$44 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$36.h1.h1, _$$1), "LT"); switch (sc$$44) { case "False": return Lib_Parser_pratt_projectHead_runProject_runRule(_$$0, _$$1, _$$2, _$$3, _$$4, null, null, null, sc$$36.h1.h1, sc$$36.h1.h2, _$$2, sc$$36.h1.h4, Lib_Syntax_RApp(spine.h1.h3.h2, Lib_Syntax_RVar(spine.h1.h3.h2, sc$$36.h1.h0), sc$$15.h2, "Explicit"), spine.h2); case "True": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, sc$$15.h2, spine), toks, com, ops)))))); } break; } default: return Lib_Parser_Impl_fail(null, "expected operator"); } break; } break; } case "True": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, sc$$15.h2, spine), toks, com, ops)))))); } break; } default: return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2), sc$$15.h2, spine.h1.h3.h3, spine.h1.h2), spine.h2); } break; default: return Lib_Parser_pratt(_$$0, _$$1, _$$2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(sc$$15.h2), sc$$15.h2, spine.h1.h3.h3, spine.h1.h2), spine.h2); } break; case "Nil": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, sc$$15.h2, Prelude_Nil(null)), toks, com, ops)))))); } }));
const Lib_Parser_pratt_projectHead_runProject_runRule = ( _, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11, _$$12, _$$13 ) => { switch (_$$11.tag) { case "_::_": switch (_$$11.h1) { case "": switch (_$$11.h2.tag) { case "Nil": { let pr; switch (_$$9) { case "InfixR": { pr = _$$8; break; } default: { pr = (_$$8) + (1); break; } } switch (_$$13.tag) { case "_::_": return Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_pratt(_, pr, _$$10, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => (Lib_Parser_pratt(_, _1, _$$10, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12), _$$12, $$sc.h2, "Explicit"), $$sc.h3))); default: return Lib_Parser_Impl_fail(null, "trailing operator"); } break; } default: switch (_$$13.tag) { case "_::_": return Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_pratt(_, 0, _$$11.h1, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => { switch ($$sc.h3.tag) { case "_::_": switch ($$sc.h3.h1.h3.h3.tag) { case "RVar": { const sc$$49 = Prelude_jsEq(null, $$sc.h3.h1.h3.h3.h1, _$$11.h1); switch (sc$$49) { case "False": return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); case "True": return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11.h2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12), _$$12, $$sc.h2, "Explicit"), $$sc.h3.h2); } break; } default: return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); } break; default: return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); } }); case "Nil": return Lib_Parser_Impl_fail(null, "short"); } break; } break; default: switch (_$$13.tag) { case "_::_": return Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_pratt(_, 0, _$$11.h1, _$$13.h1.h3.h3, _$$13.h2), ( $$sc ) => { switch ($$sc.h3.tag) { case "_::_": switch ($$sc.h3.h1.h3.h3.tag) { case "RVar": { const sc$$49 = Prelude_jsEq(null, $$sc.h3.h1.h3.h3.h1, _$$11.h1); switch (sc$$49) { case "False": return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); case "True": return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, _$$8, _$$9, _$$10, _$$11.h2, Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$12), _$$12, $$sc.h2, "Explicit"), $$sc.h3.h2); } break; } default: return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); } break; default: return Lib_Parser_Impl_fail(null, (("expected ") + (_$$11.h1)) + ("")); } }); case "Nil": return Lib_Parser_Impl_fail(null, "short"); } break; } break; case "Nil": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, _$$12, _$$13), toks, com, ops)))))); } };
const Prelude_isPrefixOf = (pfx, s) => s.startsWith(pfx) ? Prelude_True : Prelude_False;
const Lib_Parser_pratt_projectHead_runProject = ( _, _1, _2, _3, _4, _5, _6, _$$7 ) => (bouncer(Lib_Parser_REC_pratt_projectHead_runProject, { tag: "Lib.Parser.pratt.projectHead.runProject",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _6,  h7: _$$7 }));
const Lib_Parser_REC_pratt_projectHead_runProject = ( arg ) => { switch (arg.h7.tag) { case "_::_": switch (arg.h7.h1.h2) { case "Explicit": switch (arg.h7.h2.tag) { case "_::_": switch (arg.h7.h2.h1.h2) { case "Explicit": switch (arg.h7.h2.h1.h3.h3.tag) { case "RVar": { const sc$$32 = Prelude_isPrefixOf(".", arg.h7.h2.h1.h3.h3.h1); switch (sc$$32) { case "False": return { tag: "return",  h0: Prelude__$3A$3A_(null, arg.h7.h1, Prelude__$3A$3A_(null, arg.h7.h2.h1, arg.h7.h2.h2)) }; case "True": return { tag: "Lib.Parser.pratt.projectHead.runProject",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: Prelude__$3A$3A_(null, Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, arg.h7.h1.h3.h2, Lib_Syntax_RApp(arg.h7.h2.h1.h3.h3.h0, Lib_Syntax_RVar(arg.h7.h2.h1.h3.h3.h0, arg.h7.h2.h1.h3.h3.h1), arg.h7.h1.h3.h3, "Explicit"))), arg.h7.h2.h2) }; } break; } default: return { tag: "return",  h0: arg.h7 }; } break; default: return { tag: "return",  h0: arg.h7 }; } break; default: return { tag: "return",  h0: arg.h7 }; } break; default: return { tag: "return",  h0: arg.h7 }; } break; default: return { tag: "return",  h0: arg.h7 }; } };
const Lib_Parser_pratt_projectHead = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => (bouncer(Lib_Parser_REC_pratt_projectHead, { tag: "Lib.Parser.pratt.projectHead",  h0: _,  h1: _1,  h2: _2,  h3: _3,  h4: _4,  h5: _5,  h6: _$$6,  h7: _$$7 }));
const Lib_Parser_REC_pratt_projectHead = ( arg ) => { switch (arg.h7.tag) { case "_::_": switch (arg.h7.h1.h2) { case "Explicit": switch (arg.h7.h1.h3.h3.tag) { case "RVar": { const sc$$21 = Prelude_isPrefixOf(".", arg.h7.h1.h3.h3.h1); switch (sc$$21) { case "False": return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h6, arg.h7) }; case "True": return { tag: "Lib.Parser.pratt.projectHead",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: Lib_Syntax_RApp(arg.h7.h1.h3.h3.h0, Lib_Syntax_RVar(arg.h7.h1.h3.h3.h0, arg.h7.h1.h3.h3.h1), arg.h6, "Explicit"),  h7: arg.h7.h2 }; } break; } default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h6, arg.h7) }; } break; default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h6, arg.h7) }; } break; default: return { tag: "return",  h0: Prelude__$2C_(null, null, arg.h6, arg.h7) }; } };
const Lib_Parser_pratt_projectHead_runProject_runRule_runPrefix = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11 ) => { switch (_$$10.tag) { case "RVar": { const sc$$14 = Data_SortedMap_lookupMap$27(null, null, _$$10.h1, _); switch (sc$$14.tag) { case "Just": switch (sc$$14.h1.h3) { case "True": return Lib_Parser_pratt_projectHead_runProject_runRule(_, _1, _2, _3, _4, _5, _6, _7, sc$$14.h1.h1, sc$$14.h1.h2, _$$9, sc$$14.h1.h4, Lib_Syntax_RVar(_$$10.h0, sc$$14.h1.h0), _$$11); default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, _3, _$$11), toks, com, ops)))))); } break; default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, _3, _$$11), toks, com, ops)))))); } break; } default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, _$$10, _$$11), toks, com, ops)))))); } };
const Lib_Syntax_RUpdateRec = ( h0, h1, h2 ) => ({ tag: "RUpdateRec",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_ModifyField = ( h0, h1, h2 ) => ({ tag: "ModifyField",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_AssignField = ( h0, h1, h2 ) => ({ tag: "AssignField",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_dbraces = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("{{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, _$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("}}")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, t, toks, com, ops)))))))))))));
const Lib_Parser_braces = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, _$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("}")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, t, toks, com, ops)))))))))))));
const Lib_Parser_Impl_getPos = Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( indent ) => { switch (toks.tag) { case "_::_": return Lib_Parser_Impl_OK(null, Lib_Common_MkFC(indent.h0, Prelude__$2C_(null, null, toks.h1.h2.h0, toks.h1.h2.h1)), toks, com, ops); case "Nil": return Lib_Parser_Impl_OK(null, Lib_Common_emptyFC, toks, com, ops); } }))));
const Lib_Parser_Impl_many = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_some(null, _$$1), Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_Nil(null), toks, com, ops))))))));
const Lib_Parser_Impl_some = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, _$$1, ( x ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, _$$1), ( xs ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$3A$3A_(null, x, xs), toks, com, ops)))))))))));
const Lib_Parser_Impl_getOps = Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, ops, toks, com, ops))))));
const Lib_Syntax_RIf = ( h0, h1, h2, h3 ) => ({ tag: "RIf",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_parseIfThen = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("if")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( a ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("then")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( b ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("else")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( c ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RIf(fc, a, b, c), toks, com, ops))))))))))))))))))));
const Lib_Syntax_DoExpr = ( h0, h1 ) => ({ tag: "DoExpr",  h0: h0,  h1: h1 });
const Lib_Syntax_DoArrow = ( h0, h1, h2, h3 ) => ({ tag: "DoArrow",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_caseAlt = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, "MkUnit", toks, com, ops)))))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=>")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( t ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_MkAlt(pat, t), toks, com, ops))))))))))))));
const Lib_Parser_Impl_sameLevel = ( a$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( indent ) => { switch (toks.tag) { case "_::_": { const sc$$12 = Prelude__$2C_(null, null, toks.h1.h2.h0, toks.h1.h2.h1); const sc$$24 = Prelude_jsEq(null, sc$$12.h3, indent.h1.h3); switch (sc$$24) { case "False": { const sc$$25 = Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, indent.h1.h3, sc$$12.h3), "LT"); switch (sc$$25) { case "False": return Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(indent.h0, toks, "unexpected indent"), toks, com, ops); case "True": return Lib_Parser_Impl_Fail(null, "False", Lib_Parser_Impl_perror(indent.h0, toks, "unexpected indent"), toks, com, ops); } break; } case "True": return _$$1.h1(toks)(com)(ops)(Lib_Common_MkFC(indent.h0, Prelude__$2C_(null, null, sc$$12.h2, indent.h1.h3))); } break; } case "Nil": return _$$1.h1(toks)(com)(ops)(indent); } })))));
const Lib_Parser_Impl_startBlock = ( a$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( indent ) => { switch (toks.tag) { case "_::_": { const sc$$12 = Prelude__$2C_(null, null, toks.h1.h2.h0, toks.h1.h2.h1); return _$$1.h1(toks)(com)(ops)(Lib_Common_MkFC(indent.h0, Prelude__$2C_(null, null, sc$$12.h2, Prelude_ite(null, Prelude_not(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, sc$$12.h3, indent.h1.h3), "GT")), (indent.h1.h3) + (1), sc$$12.h3)))); break; } case "Nil": return _$$1.h1(toks)(com)(ops)(indent); } })))));
const Lib_Parser_doArrow = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( left ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("<-"))), ( $$sc ) => { switch ($$sc.tag) { case "Just": return Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( right ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_DoArrow(fc, left, right, alts), toks, com, ops)))))))))); default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_DoExpr(fc, left), toks, com, ops)))))); } })))));
const Lib_Syntax_DoLet = ( h0, h1, h2 ) => ({ tag: "DoLet",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_Impl_token$27 = ( _$$0 ) => (Lib_Parser_Impl_satisfy(( t ) => (Prelude_jsEq(null, Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(t.h1.h0), Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(_$$0))), (("Expected a ") + (Lib_Token_Prelude_Show$20Lib_Token_Kind$2Cshow(_$$0))) + (" token")));
const Lib_Parser_ident = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Ident")), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("MixFix")));
const Lib_Parser_doLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( tm ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_DoLet(fc, nm, tm), toks, com, ops))))))))))))))));
const Lib_Syntax_RDo = ( h0, h1 ) => ({ tag: "RDo",  h0: h0,  h1: h1 });
const Lib_Parser_Impl_try = ( a$$0, _$$1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { const sc$$8 = _$$1.h1(toks)(com)(ops)(col); switch (sc$$8.tag) { case "Fail": return Lib_Parser_Impl_Fail(null, sc$$8.h1, sc$$8.h2, sc$$8.h3, "False", sc$$8.h5); default: return sc$$8; } })))));
const Lib_Parser_doCaseLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_try(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("("))))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( bodyFC ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Syntax_RDo(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_some(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_doStmt))), ( body ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_DoExpr(fc, Lib_Syntax_RCase(fc, sc, Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(pat, body), alts))), toks, com, ops))))))))))))))))))))))));
const Lib_Parser_doStmt = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_doCaseLet, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_doLet, Lib_Parser_doArrow));
const Prelude__$3C$2A_ = ( f$$0, a$$1, b$$2, _$$3, _$$4, _$$5 ) => (Prelude__$3C$2A$3E_(null, _$$3)(null)(null)(Prelude__$3C$2A$3E_(null, _$$3)(null)(null)(Prelude_return(null, _$$3)(null)(( _$$2 ) => (( _$$31 ) => (_$$2))))(_$$4))(_$$5));
const Lib_Parser_doExpr = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Syntax_RDo(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("do"))), Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_some(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_doStmt))));
const Lib_Parser_lamExpr_mkLam = ( _, _$$1, _$$2 ) => (Lib_Syntax_RLam(_$$1.h2, Lib_Types_BI(_$$1.h2, _$$1.h3.h3.h2, _$$1.h3.h2, "Many"), _$$2));
const Lib_Parser_uident = Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("UIdent"));
const Lib_Parser_pLamArg_impArg_autoArg_expArg = ( _, _1, _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_parenWrap(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), ( _3 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, nm, ty)), toks, com, ops)))))))))));
const Lib_Parser_parenWrap = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("(")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, _$$1, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, t, toks, com, ops)))))))))))));
const Lib_Parser_pLamArg_impArg_autoArg = ( _, _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_dbraces(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), ( _2 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, "Auto", Prelude__$2C_(null, null, nm, ty)), toks, com, ops)))))))))));
const Lib_Parser_pLamArg_impArg = ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_braces(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_uident)), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, "Implicit", Prelude__$2C_(null, null, nm, ty)), toks, com, ops)))))))))));
const Lib_Parser_pLamArg = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_pLamArg_impArg(null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_pLamArg_impArg_autoArg(null, null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_pLamArg_impArg_autoArg_expArg(null, null, null), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( x ) => (Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, x, Prelude_Nothing(null)))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_uident)), Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("_")), Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, "_", Prelude_Nothing(null))), toks, com, ops)))))))))));
const Lib_Parser_addPos = ( a$$0, _$$1 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Prelude__$2C_(null, null, eta, eta1))), Lib_Parser_Impl_getPos), _$$1));
const Lib_Parser_lamExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( pos ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("\\")), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(""))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_some(null, Lib_Parser_addPos(null, Lib_Parser_pLamArg)), ( args ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=>")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_Parser_lamExpr_mkLam(null, eta, eta1))), scope, args), toks, com, ops))))))))))))))));
const Lib_Parser_caseLamExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_try(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("\\")), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(""))), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("case")))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_some(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_caseAlt))), ( alts ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RLam(fc, Lib_Types_BI(fc, "$case", "Explicit", "Many"), Lib_Syntax_RCase(fc, Lib_Syntax_RVar(fc, "$case"), alts)), toks, com, ops))))))))))));
const Lib_Parser_letExpr_mkLet = ( _, _$$1, _$$2 ) => (Lib_Syntax_RLet(_$$2.h3.h2, _$$2.h2, Prelude_fromMaybe(null, Lib_Syntax_RImplicit(_$$2.h3.h2), _$$2.h3.h3.h2), _$$2.h3.h3.h3, _$$1));
const Lib_Parser_letExpr_mkLet_letAssign = ( _, _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_ident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), Lib_Parser_typeExpr)), ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( t ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, name, Prelude__$2C_(null, null, fc, Prelude__$2C_(null, null, ty, t))), toks, com, ops)))))))))))))))));
const Lib_Parser_letExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_some(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_letExpr_mkLet_letAssign(null, null)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_keyword$27("in"), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Parser_letExpr_mkLet(null, eta, eta1))), scope, Prelude_reverse(null)(alts)), toks, com, ops))))))))))))));
const Lib_Parser_caseLet = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_try(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("let")), ( _ ) => (Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("("))))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( pat ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("|")), Lib_Parser_caseAlt)))), ( alts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("in")), ( _3 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( body ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RCase(fc, sc, Prelude__$3A$3A_(null, Lib_Syntax_MkAlt(pat, body), alts)), toks, com, ops))))))))))))))))))))))));
const Lib_Parser_caseExpr = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("case")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("of")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_some(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_caseAlt))), ( alts ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RCase(fc, sc, alts), toks, com, ops))))))))))))))));
const Prelude__$3C$$_ = ( f$$0, a$$1, b$$2, _$$3, _$$4, _$$5 ) => (Prelude_map(null, _$$3)(null)(null)(( _$$31 ) => (_$$4))(_$$5));
const Lib_Parser_updateClause = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "True", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":="))), Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "False", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("$=")))), ( op ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( tm ) => { switch (op) { case "True": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_AssignField(fc, nm, tm), toks, com, ops)))))); default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_ModifyField(fc, nm, tm), toks, com, ops)))))); } })))))));
const Lib_Parser_Impl_sepBy = ( s$$0, a$$1, _$$2, _$$3 ) => (Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Prelude__$3A$3A_(null, eta, eta1))), _$$3), Lib_Parser_Impl_many(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, _$$2, _$$3))));
const Lib_Syntax_RHole = ( h0 ) => ({ tag: "RHole",  h0: h0 });
const Prelude_strIndex = (s, ix) => s[ix];
const Lib_Syntax_RLit = ( h0, h1 ) => ({ tag: "RLit",  h0: h0,  h1: h1 });
const Lib_Parser_charLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Character")), ( v ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RLit(fc, Lib_Types_LChar(Prelude_strIndex(v, 0))), toks, com, ops))))))))));
const Lib_Parser_stringLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("StringKind")), ( t ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RLit(fc, Lib_Types_LString(t)), toks, com, ops))))))))));
const Lib_Parser_interpString_append = ( _, _$$1, _$$2 ) => { const fc = Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1); return Lib_Syntax_RApp(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(_$$1), Lib_Syntax_RApp(fc, Lib_Syntax_RVar(fc, "_++_"), _$$1, "Explicit"), _$$2, "Explicit"); };
const Lib_Parser_interp = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("StartInterp")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( tm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("EndInterp")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, tm, toks, com, ops))))))))))));
const Lib_Parser_interpString = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( _$$3 ) => ("MkUnit"), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("StartQuote"))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( part ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_stringLit, Lib_Parser_interp)), ( parts ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( _$$3 ) => ("MkUnit"), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("EndQuote"))), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Lib_Parser_interpString_append(null, eta, eta1))), part, parts), toks, com, ops))))))))))))));
const Prelude_stringToInt = (s) => {
  let rval = Number(s)
  if (isNaN(rval)) throw new Error(s + " is NaN")
  return rval
};
const Lib_Parser_intLit = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Number")), ( t ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RLit(fc, Lib_Types_LInt(Prelude_stringToInt(t))), toks, com, ops))))))))));
const Lib_Parser_lit = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_intLit, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_interpString, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_stringLit, Lib_Parser_charLit)));
const Lib_Syntax_RAs = ( h0, h1, h2 ) => ({ tag: "RAs",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_asAtom = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("@")), Lib_Parser_parenWrap(null, Lib_Parser_typeExpr))), ( asPat ) => { switch (asPat.tag) { case "Nothing": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RVar(fc, nm), toks, com, ops)))))); case "Just": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RAs(fc, nm, asPat.h1), toks, com, ops)))))); } })))));
const Lib_Parser_recordUpdate = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("[")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_sepBy(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(";")), Lib_Parser_updateClause), ( clauses ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("]")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_atom), ( tm ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RUpdateRec(fc, clauses, tm), toks, com, ops))))))))))))))));
const Lib_Parser_atom = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, "MkUnit", toks, com, ops)))))), ( _ ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, Lib_Syntax_RU, Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("U"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_asAtom, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Syntax_RVar(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_uident), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Lib_Syntax_RVar(eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Projection"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_lit, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, Lib_Syntax_RImplicit, Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("_"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, Lib_Syntax_RHole, Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("?"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parenWrap(null, Lib_Parser_typeExpr), Lib_Parser_recordUpdate))))))))));
const Lib_Parser_pArg = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( x ) => (Prelude__$2C_(null, null, "Implicit", Prelude__$2C_(null, null, fc, x))), Lib_Parser_braces(null, Lib_Parser_typeExpr)), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( x ) => (Prelude__$2C_(null, null, "Auto", Prelude__$2C_(null, null, fc, x))), Lib_Parser_dbraces(null, Lib_Parser_typeExpr)), Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( x ) => (Prelude__$2C_(null, null, "Explicit", Prelude__$2C_(null, null, fc, x))), Lib_Parser_atom)))));
const Lib_Parser_parseOp = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getOps, ( ops ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_atom, ( hd ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_pArg), ( rest ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_pratt(ops, 0, "", hd, rest), ( $$sc ) => { switch ($$sc.h3.tag) { case "Nil": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops1 ) => (( col ) => (Lib_Parser_Impl_OK(null, $$sc.h2, toks, com, ops1)))))); default: return Lib_Parser_Impl_fail(null, "extra stuff"); } })))))))));
const Lib_Parser_term$27 = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_caseExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_caseLet, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_letExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_caseLamExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_lamExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_doExpr, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseIfThen, Lib_Parser_parseOp)))))));
const Lib_Parser_term = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term$27, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (Prelude__$2C_(null, null, eta, eta1))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("$"))), Lib_Parser_term$27)), ( rest ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Parser_term_apply(null, t, rest), toks, com, ops))))))))));
const Lib_Parser_forAll_mkPi = ( _, _$$1, _$$2 ) => (Lib_Syntax_RPi(_$$1.h2, Lib_Types_BI(_$$1.h2, _$$1.h3, "Implicit", "Zero"), Lib_Syntax_RImplicit(_$$1.h2), _$$2));
const Lib_Parser_varname = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_uident, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("_")), Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, "_", toks, com, ops)))))))));
const Lib_Parser_forAll = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("forall")), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(""))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_some(null, Lib_Parser_addPos(null, Lib_Parser_varname)), ( all ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(".")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_Parser_forAll_mkPi(null, eta, eta1))), scope, all), toks, com, ops))))))))))))));
const Lib_Parser_binders_mkBind = ( _, _$$1, _$$2 ) => (Lib_Syntax_RPi(_$$1.h2.h0, _$$1.h2, _$$1.h3, _$$2));
const Lib_Parser_ebind_makeBind = ( _, _$$1, _$$2, _$$3 ) => (Prelude__$2C_(null, null, Lib_Types_BI(_$$3.h2, _$$3.h3, "Explicit", _$$1), _$$2));
const Lib_Parser_quantity = Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (Prelude_fromMaybe(null, "Many", eta)), Lib_Parser_optional(null, Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "Zero", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("0")))));
const Lib_Parser_ebind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("(")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_quantity, ( quant ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_try(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_some(null, Lib_Parser_addPos(null, Lib_Parser_varname)), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")))), ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(")")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Parser_ebind_makeBind(null, quant, ty, eta)), $$sc), toks, com, ops))))))))))))))));
const Lib_Parser_ibind_makeBind = ( _, _$$1, _$$2, _$$3 ) => (Prelude__$2C_(null, null, Lib_Types_BI(_$$3.h2, _$$3.h3, "Implicit", _$$1), Prelude_fromMaybe(null, Lib_Syntax_RImplicit(_$$3.h2), _$$2)));
const Lib_Parser_ibind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_quantity, ( quant ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_some(null, Lib_Parser_addPos(null, Lib_Parser_varname)), ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), Lib_Parser_typeExpr)), ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("}")), ( _1 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Parser_ibind_makeBind(null, quant, ty, eta)), $$sc), toks, com, ops))))))))))))))));
const Lib_Parser_abind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("{{")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_try(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_addPos(null, Lib_Parser_varname), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":"))))), ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("}}")), ( _1 ) => { switch (name.tag) { case "Nothing": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, Lib_Types_BI(Lib_Syntax_Lib_Common_HasFC$20Lib_Syntax_Raw$2CgetFC(ty), "_", "Auto", "Many"), ty), Prelude_Nil(null)), toks, com, ops)))))); case "Just": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, Lib_Types_BI(name.h1.h2, name.h1.h3, "Auto", "Many"), ty), Prelude_Nil(null)), toks, com, ops)))))); } })))))));
const Lib_Parser_binders = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_abind, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ibind, Lib_Parser_ebind))), ( binds ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_arrow, ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( scope ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_foldr(null, null, ( eta ) => (( eta1 ) => (Lib_Parser_binders_mkBind(null, eta, eta1))), scope, Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, binds, ( _$$1 ) => (_$$1))), toks, com, ops))))))))))));
const Lib_Parser_typeExpr = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_binders, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_forAll, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_term, ( exp ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_arrow, Lib_Parser_typeExpr)), ( scope ) => { switch (scope.tag) { case "Nothing": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, exp, toks, com, ops)))))); case "Just": return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_RPi(fc, Lib_Types_BI(fc, "_", "Explicit", "Many"), exp, scope.h1), toks, com, ops)))))); } })))))));
const Lib_Parser_parseSig = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Syntax_TypeSig(eta, eta1, eta2)))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_try(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_some(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_uident, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Projection"))))), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":"))))), Lib_Parser_typeExpr);
const Lib_Parser_nakedBind_makeBind = ( _, _$$1 ) => (Prelude__$2C_(null, null, Lib_Types_BI(_$$1.h2, _$$1.h3, "Explicit", "Many"), Lib_Syntax_RImplicit(_$$1.h2)));
const Lib_Parser_nakedBind = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_some(null, Lib_Parser_addPos(null, Lib_Parser_varname)), ( $$sc ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( eta ) => (Lib_Parser_nakedBind_makeBind(null, eta)), $$sc), toks, com, ops))))))));
const Lib_Parser_parseRecord = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("record")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ebind, Lib_Parser_nakedBind)), ( teles ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("constructor")), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_uident, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("MixFix"))))), ( cname ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_Record(fc, name, Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, teles, ( _$$1 ) => (_$$1)), cname, decls), toks, com, ops))))))))))))))))))));
const Lib_Syntax_Instance = ( h0, h1, h2 ) => ({ tag: "Instance",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Syntax_RWhere = ( h0, h1, h2 ) => ({ tag: "RWhere",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_getName = ( _$$0 ) => (bouncer(Lib_Parser_REC_getName, { tag: "Lib.Parser.getName",  h0: _$$0 }));
const Lib_Parser_REC_getName = ( arg ) => { switch (arg.h0.tag) { case "RApp": return { tag: "Lib.Parser.getName",  h0: arg.h0.h1 }; case "RVar": return { tag: "return",  h0: Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, arg.h0.h1, toks, com, ops)))))) }; default: return { tag: "return",  h0: Lib_Parser_Impl_fail(null, "bad LHS") }; } };
const Lib_Parser_parseDef = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( t ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_getName(t), ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( body ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( wfc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseSig, Lib_Parser_parseDef))))))), ( w ) => { const body1 = Prelude_maybe(null, null, body, ( decls ) => (Lib_Syntax_RWhere(wfc, decls, body)), w); return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_FunDef(fc, nm, Prelude__$3A$3A_(null, Prelude__$2C_(null, null, t, body1), Prelude_Nil(null))), toks, com, ops)))))); })))))))))))));
const Lib_Parser_parseInstance = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("instance")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("where"))), ( $$sc ) => { switch ($$sc.tag) { case "Just": return Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseDef))), ( decls ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_Instance(fc, ty, Prelude_Just(null, decls)), toks, com, ops)))))))); default: return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_Instance(fc, ty, Prelude_Nothing(null)), toks, com, ops)))))); } })))))));
const Lib_Syntax_Class = ( h0, h1, h2, h3 ) => ({ tag: "Class",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_parseClass = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("class")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ebind, Lib_Parser_nakedBind)), ( teles ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("where")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_Class(fc, name, Prelude_Prelude_Monad$20Prelude_List$2Cbind(null, null, teles, ( _$$1 ) => (_$$1)), decls), toks, com, ops))))))))))))))))));
const Lib_Syntax_ShortData = ( h0, h1, h2 ) => ({ tag: "ShortData",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parseShortData = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("data")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( lhs ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("=")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_sepBy(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("|")), Lib_Parser_typeExpr), ( sigs ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_ShortData(fc, lhs, sigs), toks, com, ops))))))))))))))));
const Lib_Parser_parseData = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_try(null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Prelude__$2A$3E_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("data")), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_uident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("MixFix"))))), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")))), ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("where")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_startBlock(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseSig))), ( decls ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_Data(fc, name, ty, decls), toks, com, ops))))))))))))))));
const Lib_Syntax_DCheck = ( h0, h1, h2 ) => ({ tag: "DCheck",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parseNorm = Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser$2C_$3C$2A$3E_(null, null, Prelude__$3C$2A_(null, null, null, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser$2Cmap(null, null, ( eta ) => (( eta1 ) => (( eta2 ) => (Lib_Syntax_DCheck(eta, eta1, eta2)))), Lib_Parser_Impl_getPos), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("#check"))), Lib_Parser_typeExpr), Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":"))), Lib_Parser_typeExpr);
const Lib_Syntax_PFunc = ( h0, h1, h2, h3, h4 ) => ({ tag: "PFunc",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Lib_Parser_parsePFunc = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("pfunc")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_ident, ( nm ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("uses")), ( _1 ) => (Lib_Parser_parenWrap(null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_uident, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_ident, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("MixFix"))))))))), ( used ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_typeExpr, ( ty ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":=")), ( _2 ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("JSLit")), ( src ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_PFunc(fc, nm, Prelude_fromMaybe(null, Prelude_Nil(null), used), ty, src), toks, com, ops))))))))))))))))))))));
const Lib_Syntax_PType = ( h0, h1, h2 ) => ({ tag: "PType",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Parser_parsePType = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("ptype")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_uident, ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_optional(null, Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27(":")), ( _1 ) => (Lib_Parser_typeExpr))), ( ty ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_PType(fc, $$sc, ty), toks, com, ops))))))))))))));
const Lib_Syntax_PMixFix = ( h0, h1, h2, h3 ) => ({ tag: "PMixFix",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Parser_Impl_addOp = ( _$$0, _$$1, _$$2 ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => { const parts = Prelude_split(_$$0, "_"); switch (parts.tag) { case "_::_": switch (parts.h1) { case "": switch (parts.h2.tag) { case "_::_": return Lib_Parser_Impl_OK(null, "MkUnit", toks, com, Data_SortedMap_updateMap(null, null, parts.h2.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, "False", parts.h2.h2), ops)); default: return Lib_Parser_Impl_OK(null, "MkUnit", toks, com, Data_SortedMap_updateMap(null, null, parts.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, "True", parts.h2), ops)); } break; default: return Lib_Parser_Impl_OK(null, "MkUnit", toks, com, Data_SortedMap_updateMap(null, null, parts.h1, Lib_Common_MkOp(_$$0, _$$1, _$$2, "True", parts.h2), ops)); } break; case "Nil": return Lib_Parser_Impl_Fail(null, "True", Lib_Parser_Impl_perror(col.h0, toks, "Internal error parsing mixfix"), toks, com, ops); } })))));
const Lib_Common_MkOp = ( h0, h1, h2, h3, h4 ) => ({ tag: "MkOp",  h0: h0,  h1: h1,  h2: h2,  h3: h3,  h4: h4 });
const Prelude_split = (s, by) => {
  let parts = s.split(by)
  let rval = Prelude_Nil(null)
  parts.reverse()
  parts.forEach(p => { rval = Prelude__$3A$3A_(null, p, rval) })
  return rval
};
const Lib_Parser_parseMixfix = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "InfixL", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("infixl"))), Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "InfixR", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("infixr"))), Prelude__$3C$$_(null, null, null, Lib_Parser_Impl_Prelude_Functor$20Lib_Parser_Impl_Parser, "Infix", Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("infix"))))), ( fix ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Number")), ( prec ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_some(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("MixFix"))), ( ops ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Prelude_for(null, null, Prelude_Prelude_Traversable$20Prelude_List, Lib_Parser_Impl_Prelude_Applicative$20Lib_Parser_Impl_Parser, null, null, ops, ( op ) => (Lib_Parser_Impl_addOp(op, Prelude_stringToInt(prec), fix))), ( _ ) => (Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops1 ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_PMixFix(fc, ops, Prelude_stringToInt(prec), fix), toks, com, ops1))))))))))))))));
const Lib_Parser_parseDecl = Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseMixfix, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parsePType, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parsePFunc, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseNorm, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseData, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseShortData, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseSig, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseDef, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseClass, Lib_Parser_Impl_Prelude_Alternative$20Lib_Parser_Impl_Parser$2C_$3C$7C$3E_(null, Lib_Parser_parseInstance, Lib_Parser_parseRecord))))))))));
const Lib_Parser_Impl_partialParse = ( a$$0, _$$1, _$$2, _$$3, _$$4 ) => { const sc$$5 = Lib_Parser_Impl_runP(null, _$$2)(_$$4)("False")(_$$3)(Lib_Common_MkFC(_$$1, Prelude__$2C_(null, null, 0, 0))); switch (sc$$5.tag) { case "Fail": return Prelude_Left(null, null, Prelude__$2C_(null, null, sc$$5.h2, sc$$5.h3)); case "OK": return Prelude_Right(null, null, Prelude__$2C_(null, null, sc$$5.h1, Prelude__$2C_(null, null, sc$$5.h4, sc$$5.h2))); } };
const Serialize_loadModule = ( _$$0, _$$1 ) => { const fn = (("build/") + (Lib_Common_Prelude_Show$20Lib_Common_QName$2Cshow(_$$0))) + (".newtmod"); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Serialize_readModFile(fn)), ( $$sc ) => { switch ($$sc.tag) { case "Just": { const ops = Data_SortedMap_mapFromList(null, null, Prelude_Prelude_Ord$20Prim_String, $$sc.h1.h3.h3.h2); const defs = Data_SortedMap_mapFromList(null, null, Lib_Common_Prelude_Ord$20Lib_Common_QName, Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( entry ) => (Prelude__$2C_(null, null, entry.h1, entry)), $$sc.h1.h3.h2)); const mctx = Lib_Types_MC(Data_SortedMap_mapFromList(null, null, Lib_Common_Prelude_Ord$20Lib_Common_QName, $$sc.h1.h3.h3.h3), Prelude_Nil(null), 0, "NoCheck"); const sc$$22 = Prelude_jsEq(null, $$sc.h1.h2, _$$1); switch (sc$$22) { case "False": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); case "True": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Just(null, Lib_Types_MkModCtx($$sc.h1.h2, defs, mctx, ops))); } break; } default: return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude_Nothing(null)); } }); };
const Data_SortedMap_mapFromList = ( k$$0, v$$1, _$$2, _$$3 ) => (Prelude_foldl(null, null, ( eta ) => (( eta1 ) => (Data_SortedMap_mapFromList_go(k$$0, v$$1, _$$2, _$$3, null, eta, eta1))), Data_SortedMap_EmptyMap(null, null, _$$2.h1), _$$3));
const Data_SortedMap_mapFromList_go = ( _, _1, _2, _3, _4, _$$5, _$$6 ) => (Data_SortedMap_updateMap(null, null, _$$6.h2, _$$6.h3, _$$5));
const Serialize_readModFile = (fn) => (w) => {
  let fs = require('fs')
  try {
    let {DecFile} = require('./serializer')
    let data = fs.readFileSync(fn)
    let dec = DecFile.decode(data)
    return Prelude_MkIORes(null, Prelude_Just(null, dec), w)
  } catch (e) {
    return Prelude_MkIORes(null, Prelude_Nothing, w)
  }
};
const Main_moduleHash = ( _$$0, _$$1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Serialize_checksum(_$$0)), ( srcHash ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( top ) => { const mods = Prelude_mapMaybe(null, null, ( x ) => (Data_SortedMap_lookupMap$27(null, null, x, top.h0)), _$$1); const modHashes = Prelude_Prelude_Functor$20Prelude_List$2Cmap(null, null, ( x ) => (x.h0), mods); return Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Serialize_checksum(Prelude_fastConcat(Prelude__$3A$3A_(null, srcHash, modHashes)))); }))));
const Serialize_checksum = (a) => (w) => {
  const arr = new TextEncoder().encode(a);
  // djb2 hash
  let val = 5381
  for (let i = 0; i < arr.length; i++) {
    val = ((val * 33) + arr[i]) | 0
  }
  return Prelude_MkIORes(null, ""+val, w);
};
const Data_List1_split1 = ( _$$0, _$$1 ) => { const sc$$2 = Prelude_split(_$$0, _$$1); switch (sc$$2.tag) { case "_::_": return Data_List1__$3A$3A$3A_(null, sc$$2.h1, sc$$2.h2); case "Nil": return Data_List1__$3A$3A$3A_(null, _$$0, Prelude_Nil(null)); } };
const Data_List1__$3A$3A$3A_ = ( h0, h1, h2 ) => ({ tag: "_:::_",  h0: h0,  h1: h1,  h2: h2 });
const Data_List1_unsnoc = ( a$$0, _$$1 ) => (Data_List1_unsnoc_go(a$$0, _$$1, _$$1.h0, _$$1.h1, _$$1.h2, null, _$$1.h1, _$$1.h2));
const Data_List1_unsnoc_go = ( _, _1, _2, _3, _4, _5, _$$6, _$$7 ) => { switch (_$$7.tag) { case "_::_": { const sc$$11 = Data_List1_unsnoc_go(_, _1, _2, _3, _4, _5, _$$7.h1, _$$7.h2); return Prelude__$2C_(null, null, Prelude__$3A$3A_(null, _$$6, sc$$11.h2), sc$$11.h3); break; } case "Nil": return Prelude__$2C_(null, null, Prelude_Nil(null), _$$6); } };
const Lib_Syntax_MkImport = ( h0, h1 ) => ({ tag: "MkImport",  h0: h0,  h1: h1 });
const Lib_Parser_parseImport = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("import")), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_uident, ( $$sc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Projection"))), ( rest ) => { const name = Prelude_joinBy("", Prelude__$3A$3A_(null, $$sc, rest)); return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Lib_Syntax_MkImport(fc, name), toks, com, ops)))))); })))))));
const Lib_Parser_parseImports = Lib_Parser_Impl_many(null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_parseImport));
const Lib_Parser_parseModHeader = Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_sameLevel(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_keyword$27("module"))), ( _ ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_getPos, ( fc ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_uident, ( name ) => (Lib_Parser_Impl_Prelude_Monad$20Lib_Parser_Impl_Parser$2Cbind(null, null, Lib_Parser_Impl_many(null, Lib_Parser_Impl_indented(null, Lib_Parser_Impl_token$27("Projection"))), ( rest ) => { const name1 = Prelude_joinBy("", Prelude__$3A$3A_(null, name, rest)); return Lib_Parser_Impl_P(null, ( toks ) => (( com ) => (( ops ) => (( col ) => (Lib_Parser_Impl_OK(null, Prelude__$2C_(null, null, fc, name1), toks, com, ops)))))); })))))));
const Lib_Tokenizer_tokenise = ( _$$0, _$$1 ) => { const sc$$2 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(0, 0, Prelude_Lin(null), Prelude_unpack(_$$1))); switch (sc$$2.tag) { case "Right": switch (sc$$2.h2.h3.tag) { case "Nil": return Prelude_Right(null, null, Prelude__$3C$3E$3E_(null, sc$$2.h2.h2, Prelude_Nil(null))); default: return Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, sc$$2.h2.h0, sc$$2.h2.h1)), "Extra toks")); } break; case "Left": switch (sc$$2.h2.tag) { case "E": return Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC(_$$0, sc$$2.h2.h0.h1), sc$$2.h2.h1)); default: return Prelude_Left(null, null, sc$$2.h2); } break; } };
const Lib_Tokenizer_TS = ( h0, h1, h2, h3 ) => ({ tag: "TS",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Tokenizer_rawTokenise = ( _$$0 ) => (bouncer(Lib_Tokenizer_REC_rawTokenise, { tag: "Lib.Tokenizer.rawTokenise",  h0: _$$0 }));
const Lib_Tokenizer_REC_rawTokenise = ( arg ) => { switch (arg.tag) { case "Lib.Tokenizer.rawTokenise": switch (arg.h0.h3.tag) { case "_::_": switch (arg.h0.h3.h1) { case " ": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2) }; case "\n": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS((arg.h0.h0) + (1), 0, arg.h0.h2, arg.h0.h3.h2) }; case "\"": { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (1), "StartQuote", "\""); const sc$$18 = Lib_Tokenizer_quoteTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(null, arg.h0.h2, tok), arg.h0.h3.h2), arg.h0.h0, (arg.h0.h1) + (1), Prelude_Lin(null)); switch (sc$$18.tag) { case "Right": switch (sc$$18.h2.h3.tag) { case "_::_": switch (sc$$18.h2.h3.h1) { case "\"": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", sc$$18.h2.h0, (sc$$18.h2.h1) + (1), "EndQuote", "\""); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(sc$$18.h2.h0, (sc$$18.h2.h1) + (1), Prelude__$3A$3C_(null, sc$$18.h2.h2, tok1), sc$$18.h2.h3.h2) }; break; } default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '\"'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '\"'")) }; } break; case "Left": return { tag: "return",  h0: Prelude_Left(null, null, sc$$18.h2) }; } break; } case "}": return { tag: "return",  h0: Prelude_Right(null, null, arg.h0) }; case "{": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case "{": { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (2), "Keyword", "{{"); const sc$$21 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), Prelude__$3A$3C_(null, arg.h0.h2, tok), arg.h0.h3.h2.h2)); switch (sc$$21.tag) { case "Right": switch (sc$$21.h2.h3.tag) { case "_::_": switch (sc$$21.h2.h3.h1) { case "}": switch (sc$$21.h2.h3.h2.tag) { case "_::_": switch (sc$$21.h2.h3.h2.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", sc$$21.h2.h0, (sc$$21.h2.h1) + (2), "Keyword", "}}"); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(sc$$21.h2.h0, (sc$$21.h2.h1) + (2), Prelude__$3A$3C_(null, sc$$21.h2.h2, tok1), sc$$21.h2.h3.h2.h2) }; break; } default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}}'")) }; } break; case "Left": return { tag: "return",  h0: Prelude_Left(null, null, sc$$21.h2) }; } break; } default: { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (1), "Symbol", "{"); const sc$$21 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(null, arg.h0.h2, tok), arg.h0.h3.h2)); switch (sc$$21.tag) { case "Right": switch (sc$$21.h2.h3.tag) { case "_::_": switch (sc$$21.h2.h3.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", sc$$21.h2.h0, (sc$$21.h2.h1) + (1), "Symbol", "}"); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(sc$$21.h2.h0, (sc$$21.h2.h1) + (1), Prelude__$3A$3C_(null, sc$$21.h2.h2, tok1), sc$$21.h2.h3.h2) }; break; } default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$21.h2.h0, sc$$21.h2.h1)), "Expected '}'")) }; } break; case "Left": return { tag: "return",  h0: Prelude_Left(null, null, sc$$21.h2) }; } break; } } break; default: { const tok = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (1), "Symbol", "{"); const sc$$18 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(null, arg.h0.h2, tok), arg.h0.h3.h2)); switch (sc$$18.tag) { case "Right": switch (sc$$18.h2.h3.tag) { case "_::_": switch (sc$$18.h2.h3.h1) { case "}": { const tok1 = Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", sc$$18.h2.h0, (sc$$18.h2.h1) + (1), "Symbol", "}"); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(sc$$18.h2.h0, (sc$$18.h2.h1) + (1), Prelude__$3A$3C_(null, sc$$18.h2.h2, tok1), sc$$18.h2.h3.h2) }; break; } default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '}'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$18.h2.h0, sc$$18.h2.h1)), "Expected '}'")) }; } break; case "Left": return { tag: "return",  h0: Prelude_Left(null, null, sc$$18.h2) }; } break; } } break; case ",": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (1), "Ident", ",")), arg.h0.h3.h2) }; case "_": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case ",": switch (arg.h0.h3.h2.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h2.h1) { case "_": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (3), "MixFix", "_,_")), arg.h0.h3.h2.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; case ".": switch (arg.h0.h3.h2.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h2.h1) { case "_": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (3), "MixFix", "_._")), arg.h0.h3.h2.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; case "'": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case "\\": switch (arg.h0.h3.h2.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h2.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h2.h2.h1) { case "'": { const ch = Prelude_ite(null, Prelude_jsEq(null, arg.h0.h3.h2.h2.h1, "n"), "\n", arg.h0.h3.h2.h2.h1); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (4), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (4), "Character", Prelude_pack(Prelude__$3A$3A_(null, ch, Prelude_Nil(null))))), arg.h0.h3.h2.h2.h2.h2) }; break; } default: switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (3), "Character", Prelude_pack(Prelude__$3A$3A_(null, arg.h0.h3.h2.h1, Prelude_Nil(null))))), arg.h0.h3.h2.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } break; default: switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (3), "Character", Prelude_pack(Prelude__$3A$3A_(null, arg.h0.h3.h2.h1, Prelude_Nil(null))))), arg.h0.h3.h2.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: switch (arg.h0.h3.h2.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h2.h1) { case "'": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (3), Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, null, null, null, "False", arg.h0.h0, (arg.h0.h1) + (3), "Character", Prelude_pack(Prelude__$3A$3A_(null, arg.h0.h3.h2.h1, Prelude_Nil(null))))), arg.h0.h3.h2.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; case "#": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h13: "Pragma",  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(null, Prelude_Lin(null), "#") }; case "/": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case "-": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; case "`": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h9: Prelude_Lin(null) }; case ".": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h13: "Projection",  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(null, Prelude_Lin(null), ".") }; case "-": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case "-": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2) }; default: { const sc$$20 = Prelude_isDigit(arg.h0.h3.h2.h1); switch (sc$$20) { case "False": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, Prelude__$3A$3A_(null, arg.h0.h3.h2.h1, arg.h0.h3.h2.h2)),  h13: "Ident",  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null, eta)),  h15: Prelude__$3A$3C_(null, Prelude_Lin(null), "-") }; case "True": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h13: "Number",  h14: Prelude_isDigit,  h15: Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, Prelude_Lin(null), "-"), arg.h0.h3.h2.h1) }; } break; } } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar",  h0: arg.h0,  h1: arg.h0.h0,  h2: arg.h0.h1,  h3: arg.h0.h2,  h4: arg.h0.h3,  h5: null,  h6: null,  h7: null,  h8: null,  h9: null,  h10: null,  h11: null,  h12: null,  h13: arg.h0.h3.h1,  h14: arg.h0.h3.h2 }; } break; case "Nil": return { tag: "return",  h0: Prelude_Right(null, null, arg.h0) }; } break; case "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest.doChar": { const sc$$15 = Prelude_elem(null, Prelude_Prelude_Eq$20Prim_Char, arg.h13, Lib_Tokenizer_standalone); switch (sc$$15) { case "False": { let kind; const sc$$16 = Prelude_isDigit(arg.h13); switch (sc$$16) { case "False": { const sc$$17 = Prelude_isUpper(arg.h13); switch (sc$$17) { case "False": { kind = "Ident"; break; } case "True": { kind = "UIdent"; break; } } break; } case "True": { kind = "Number"; break; } } return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: Lib_Tokenizer_TS(arg.h1, arg.h2, arg.h3, Prelude__$3A$3A_(null, arg.h13, arg.h14)),  h13: kind,  h14: ( eta ) => (Lib_Tokenizer_rawTokenise_isIdent(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, eta)),  h15: Prelude_Lin(null) }; break; } case "True": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h1, (arg.h2) + (1), Prelude__$3A$3C_(null, arg.h3, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, "True", arg.h1, (arg.h2) + (1), "Symbol", Prelude_pack(Prelude__$3A$3A_(null, arg.h13, Prelude_Nil(null))))), arg.h14) }; } break; } case "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest": switch (arg.h12.h3.tag) { case "_::_": { const sc$$23 = arg.h14(arg.h12.h3.h1); switch (sc$$23) { case "False": { let kind; const sc$$24 = Data_SnocList_snocelem(null, Prelude_Prelude_Eq$20Prim_Char, "_", arg.h15); switch (sc$$24) { case "False": { kind = arg.h13; break; } case "True": { kind = "MixFix"; break; } } return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h12.h0, arg.h12.h1, Prelude__$3A$3C_(null, arg.h12.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, "True", arg.h12.h0, (arg.h12.h1) - (1), kind, Prelude_pack(Prelude__$3C$3E$3E_(null, arg.h15, Prelude_Nil(null))))), Prelude__$3A$3A_(null, arg.h12.h3.h1, arg.h12.h3.h2)) }; break; } case "True": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment.doRest",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: arg.h11,  h12: Lib_Tokenizer_TS(arg.h12.h0, (arg.h12.h1) + (1), arg.h12.h2, arg.h12.h3.h2),  h13: arg.h13,  h14: arg.h14,  h15: Prelude__$3A$3C_(null, arg.h15, arg.h12.h3.h1) }; } break; } case "Nil": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h12.h0, arg.h12.h1, Prelude__$3A$3C_(null, arg.h12.h2, Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h4, arg.h5, arg.h6, arg.h7, arg.h8, "True", arg.h12.h0, arg.h12.h1, arg.h13, Prelude_pack(Prelude__$3C$3E$3E_(null, arg.h15, Prelude_Nil(null))))), Prelude_Nil(null)) }; } break; case "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment": switch (arg.h11.h3.tag) { case "_::_": switch (arg.h11.h3.h1) { case "-": switch (arg.h11.h3.h2.tag) { case "_::_": switch (arg.h11.h3.h2.h1) { case "/": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (2), arg.h11.h2, arg.h11.h3.h2.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } break; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } break; case "\n": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS((arg.h11.h0) + (1), 0, arg.h11.h2, arg.h11.h3.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment.blockComment",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: arg.h10,  h11: Lib_Tokenizer_TS(arg.h11.h0, (arg.h11.h1) + (1), arg.h11.h2, arg.h11.h3.h2) }; } break; case "Nil": return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, arg.h11.h0, arg.h11.h1)), "EOF in block comment")) }; } break; case "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick": switch (arg.h8.h3.tag) { case "_::_": switch (arg.h8.h3.h1) { case "`": { const tok = Lib_Token_MkBounded(null, Lib_Token_Tok("JSLit", Prelude_pack(Prelude__$3C$3E$3E_(null, arg.h9, Prelude_Nil(null)))), Lib_Token_MkBounds(arg.h1, arg.h2, arg.h8.h0, arg.h8.h1)); return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h8.h0, (arg.h8.h1) + (1), Prelude__$3A$3C_(null, arg.h8.h2, tok), arg.h8.h3.h2) }; break; } case "\n": return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Lib_Tokenizer_TS((arg.h8.h0) + (1), 0, arg.h8.h2, arg.h8.h3.h2),  h9: Prelude__$3A$3C_(null, arg.h9, "\n") }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: Lib_Tokenizer_TS(arg.h8.h0, (arg.h8.h1) + (1), arg.h8.h2, arg.h8.h3.h2),  h9: Prelude__$3A$3C_(null, arg.h9, arg.h8.h3.h1) }; } break; case "Nil": return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, arg.h8.h0, arg.h8.h1)), "EOF in backtick string")) }; } break; case "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment": switch (arg.h10.h3.tag) { case "_::_": switch (arg.h10.h3.h1) { case "\n": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS((arg.h10.h0) + (1), 0, arg.h10.h2, arg.h10.h3.h2) }; default: return { tag: "Lib.Tokenizer.rawTokenise.isIdent.isUIdent.doBacktick.mktok.lineComment",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3,  h4: arg.h4,  h5: arg.h5,  h6: arg.h6,  h7: arg.h7,  h8: arg.h8,  h9: arg.h9,  h10: Lib_Tokenizer_TS(arg.h10.h0, (arg.h10.h1) + (1), arg.h10.h2, arg.h10.h3.h2) }; } break; case "Nil": return { tag: "Lib.Tokenizer.rawTokenise",  h0: Lib_Tokenizer_TS(arg.h10.h0, arg.h10.h1, arg.h10.h2, Prelude_Nil(null)) }; } break; } };
const Lib_Token_MkBounds = ( h0, h1, h2, h3 ) => ({ tag: "MkBounds",  h0: h0,  h1: h1,  h2: h2,  h3: h3 });
const Lib_Token_Tok = ( h0, h1 ) => ({ tag: "Tok",  h0: h0,  h1: h1 });
const Lib_Token_MkBounded = ( h0, h1, h2 ) => ({ tag: "MkBounded",  h0: h0,  h1: h1,  h2: h2 });
const Lib_Tokenizer_rawTokenise_isIdent_isUIdent_doBacktick_mktok = ( _, _1, _2, _3, _4, _5, _6, _7, _8, _$$9, _$$10, _$$11, _$$12, _$$13 ) => { let kind; const sc$$14 = Prelude__$26$26_(_$$9, Prelude_elem(null, Prelude_Prelude_Eq$20Prim_String, _$$13, Lib_Tokenizer_keywords)); switch (sc$$14) { case "False": { kind = _$$12; break; } case "True": { kind = "Keyword"; break; } } return Lib_Token_MkBounded(null, Lib_Token_Tok(kind, _$$13), Lib_Token_MkBounds(_1, _2, _$$10, _$$11)); };
const Lib_Tokenizer_keywords = Prelude__$3A$3A_(null, "let", Prelude__$3A$3A_(null, "in", Prelude__$3A$3A_(null, "where", Prelude__$3A$3A_(null, "case", Prelude__$3A$3A_(null, "of", Prelude__$3A$3A_(null, "data", Prelude__$3A$3A_(null, "U", Prelude__$3A$3A_(null, "do", Prelude__$3A$3A_(null, "ptype", Prelude__$3A$3A_(null, "pfunc", Prelude__$3A$3A_(null, "module", Prelude__$3A$3A_(null, "infixl", Prelude__$3A$3A_(null, "infixr", Prelude__$3A$3A_(null, "infix", Prelude__$3A$3A_(null, "", Prelude__$3A$3A_(null, "forall", Prelude__$3A$3A_(null, "import", Prelude__$3A$3A_(null, "uses", Prelude__$3A$3A_(null, "class", Prelude__$3A$3A_(null, "instance", Prelude__$3A$3A_(null, "record", Prelude__$3A$3A_(null, "constructor", Prelude__$3A$3A_(null, "if", Prelude__$3A$3A_(null, "then", Prelude__$3A$3A_(null, "else", Prelude__$3A$3A_(null, "$", Prelude__$3A$3A_(null, "", Prelude__$3A$3A_(null, "?", Prelude__$3A$3A_(null, "@", Prelude__$3A$3A_(null, ".", Prelude__$3A$3A_(null, "->", Prelude__$3A$3A_(null, "", Prelude__$3A$3A_(null, ":", Prelude__$3A$3A_(null, "=>", Prelude__$3A$3A_(null, ":=", Prelude__$3A$3A_(null, "$=", Prelude__$3A$3A_(null, "=", Prelude__$3A$3A_(null, "<-", Prelude__$3A$3A_(null, "\\", Prelude__$3A$3A_(null, "_", Prelude__$3A$3A_(null, "|", Prelude_Nil(null))))))))))))))))))))))))))))))))))))))))));
const Prelude_Prelude_Eq$20Prim_Char$2C_$3D$3D_ = ( _$$0, _$$1 ) => (Prelude_jsEq(null, _$$0, _$$1));
const Prelude_Prelude_Eq$20Prim_Char = Prelude_MkEq(null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Eq$20Prim_Char$2C_$3D$3D_(eta, eta1))));
const Data_SnocList_snocelem = ( a$$0, _$$1, _$$2, _$$3 ) => (bouncer(Data_SnocList_REC_snocelem, { tag: "Data.SnocList.snocelem",  h0: a$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Data_SnocList_REC_snocelem = ( arg ) => { switch (arg.h3.tag) { case "_:<_": { const sc$$7 = Prelude__$3D$3D_(null, arg.h1)(arg.h2)(arg.h3.h2); switch (sc$$7) { case "False": return { tag: "Data.SnocList.snocelem",  h0: null,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1 }; case "True": return { tag: "return",  h0: "True" }; } break; } case "Lin": return { tag: "return",  h0: "False" }; } };
const Lib_Tokenizer_rawTokenise_isIdent = ( _, _1, _2, _3, _4, _5, _$$6 ) => (Prelude_not(Prelude__$7C$7C_(Prelude_isSpace(_$$6), Prelude_elem(null, Prelude_Prelude_Eq$20Prim_Char, _$$6, Lib_Tokenizer_standalone))));
const Lib_Tokenizer_standalone = Prelude_unpack("()\\{}[],.@;");
const Prelude_isSpace = ( _$$0 ) => { switch (_$$0) { case " ": return "True"; case "\n": return "True"; default: return "False"; } };
const Prelude_isUpper = ( _$$0 ) => { const o = Prelude_ord(_$$0); return Prelude__$26$26_(Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, 64, o), "LT"), Prelude_Prelude_Eq$20Prelude_Ordering$2C_$3D$3D_(Prelude_jsCompare(null, o, 91), "LT")); };
const Prelude_isDigit = ( _$$0 ) => { switch (_$$0) { case "0": return "True"; case "1": return "True"; case "2": return "True"; case "3": return "True"; case "4": return "True"; case "5": return "True"; case "6": return "True"; case "7": return "True"; case "8": return "True"; case "9": return "True"; default: return "False"; } };
const Lib_Tokenizer_quoteTokenise = ( _$$0, _$$1, _$$2, _$$3 ) => (bouncer(Lib_Tokenizer_REC_quoteTokenise, { tag: "Lib.Tokenizer.quoteTokenise",  h0: _$$0,  h1: _$$1,  h2: _$$2,  h3: _$$3 }));
const Lib_Tokenizer_REC_quoteTokenise = ( arg ) => { switch (arg.h0.h3.tag) { case "_::_": switch (arg.h0.h3.h1) { case "\"": return { tag: "return",  h0: Prelude_Right(null, null, Lib_Tokenizer_TS(arg.h0.h0, arg.h0.h1, Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_quoteTokenise_stok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null)), arg.h0.h3)) }; case "\n": return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, arg.h0.h0, arg.h0.h1)), "Newline in string")) }; case "\\": switch (arg.h0.h3.h2.tag) { case "_::_": switch (arg.h0.h3.h2.h1) { case "{": { const tok = Lib_Token_MkBounded(null, Lib_Token_Tok("StartInterp", "\\{"), Lib_Token_MkBounds(arg.h0.h0, arg.h0.h1, arg.h0.h0, (arg.h0.h1) + (2))); const sc$$17 = Lib_Tokenizer_rawTokenise(Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), Prelude__$3A$3C_(null, Prelude__$3A$3C_(null, arg.h0.h2, Lib_Tokenizer_quoteTokenise_stok(arg.h0, arg.h1, arg.h2, arg.h3, arg.h0.h0, arg.h0.h1, arg.h0.h2, arg.h0.h3, null)), tok), arg.h0.h3.h2.h2)); switch (sc$$17.tag) { case "Right": switch (sc$$17.h2.h3.tag) { case "_::_": switch (sc$$17.h2.h3.h1) { case "}": { const tok1 = Lib_Token_MkBounded(null, Lib_Token_Tok("EndInterp", "}"), Lib_Token_MkBounds(sc$$17.h2.h0, sc$$17.h2.h1, sc$$17.h2.h0, (sc$$17.h2.h1) + (1))); return { tag: "Lib.Tokenizer.quoteTokenise",  h0: Lib_Tokenizer_TS(sc$$17.h2.h0, (sc$$17.h2.h1) + (1), Prelude__$3A$3C_(null, sc$$17.h2.h2, tok1), sc$$17.h2.h3.h2),  h1: sc$$17.h2.h0,  h2: (sc$$17.h2.h1) + (1),  h3: Prelude_Lin(null) }; break; } default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$17.h2.h0, sc$$17.h2.h1)), "Expected '{'")) }; } break; default: return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, sc$$17.h2.h0, sc$$17.h2.h1)), "Expected '{'")) }; } break; case "Left": return { tag: "return",  h0: Prelude_Left(null, null, sc$$17.h2) }; } break; } case "n": return { tag: "Lib.Tokenizer.quoteTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(null, arg.h3, "\n") }; default: return { tag: "Lib.Tokenizer.quoteTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (2), arg.h0.h2, arg.h0.h3.h2.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(null, arg.h3, arg.h0.h3.h2.h1) }; } break; default: return { tag: "Lib.Tokenizer.quoteTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(null, arg.h3, arg.h0.h3.h1) }; } break; default: return { tag: "Lib.Tokenizer.quoteTokenise",  h0: Lib_Tokenizer_TS(arg.h0.h0, (arg.h0.h1) + (1), arg.h0.h2, arg.h0.h3.h2),  h1: arg.h1,  h2: arg.h2,  h3: Prelude__$3A$3C_(null, arg.h3, arg.h0.h3.h1) }; } break; case "Nil": return { tag: "return",  h0: Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC("", Prelude__$2C_(null, null, arg.h0.h0, arg.h0.h1)), "Expected '\"' at EOF")) }; } };
const Lib_Tokenizer_quoteTokenise_stok = ( _, _1, _2, _3, _4, _5, _6, _7, _8 ) => (Lib_Token_MkBounded(null, Lib_Token_Tok("StringKind", Prelude_pack(Prelude__$3C$3E$3E_(null, _3, Prelude_Nil(null)))), Lib_Token_MkBounds(_1, _2, _4, _5)));
const Node_readFile = (fn) => (w) => {
  let fs = require('fs')
  let result
  try {
    let content = fs.readFileSync(fn, 'utf8')
    result = Prelude_Right(null, null, content)
  } catch (e) {
    let err = ""+e
    result = Prelude_Left(null, null, e)
  }
  return Prelude_MkIORes(null, result, w)
};
const Lib_Types_emptyModCtx = ( _$$0 ) => (Lib_Types_MkModCtx(_$$0, Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Lib_Types_MC(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), 0, "NoCheck"), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))))));
const Lib_Util_getBaseDir = ( _$$0, _$$1 ) => { const sc$$3 = Data_List1_unsnoc(null, Data_List1_split1(_$$1, ".")); const parts = Data_List1_split1(_$$0, "/"); const sc$$9 = Data_List1_unsnoc(null, parts); const sc$$14 = Data_List1_splitFileName(sc$$9.h3); const parts1 = Data_List1_split1(_$$0, "/"); const sc$$20 = Data_List1_unsnoc(null, parts1); const sc$$25 = Data_List1_unsnoc(null, Data_List1_split1(_$$1, ".")); return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_not(Prelude_jsEq(null, sc$$25.h3, sc$$14.h2)), ( _ ) => (Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, 0, 0)), (((("module name ") + (sc$$25.h3)) + (" doesn't match ")) + (sc$$14.h2)) + (""))), eta)))))), ( _ ) => { const sc$$31 = Lib_Util_getBaseDir_baseDir(_$$0, _$$1, null, Prelude__$3C$3E$3C_(null, Prelude_Lin(null), sc$$20.h2), Prelude__$3C$3E$3C_(null, Prelude_Lin(null), sc$$25.h2)); switch (sc$$31.tag) { case "Right": { let base; const sc$$35 = Prelude_jsEq(null, sc$$31.h2, ""); switch (sc$$35) { case "False": { base = sc$$31.h2; break; } case "True": { base = "."; break; } } return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, base, Lib_Common_QN(sc$$25.h2, sc$$25.h3))); break; } case "Left": return Lib_Types_MkM(null, ( _1 ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_MkFC(_$$0, Prelude__$2C_(null, null, 0, 0)), sc$$31.h2)), eta)))); } }); };
const Lib_Util_getBaseDir_baseDir = ( _, _1, _2, _$$3, _$$4 ) => (bouncer(Lib_Util_REC_getBaseDir_baseDir, { tag: "Lib.Util.getBaseDir.baseDir",  h0: _,  h1: _1,  h2: _2,  h3: _$$3,  h4: _$$4 }));
const Lib_Util_REC_getBaseDir_baseDir = ( arg ) => { switch (arg.h4.tag) { case "_:<_": switch (arg.h3.tag) { case "_:<_": { const sc$$11 = Prelude_jsEq(null, arg.h3.h2, arg.h4.h2); switch (sc$$11) { case "False": return { tag: "return",  h0: Prelude_Left(null, null, "module path doesn't match directory") }; case "True": return { tag: "Lib.Util.getBaseDir.baseDir",  h0: arg.h0,  h1: arg.h1,  h2: arg.h2,  h3: arg.h3.h1,  h4: arg.h4.h1 }; } break; } case "Lin": return { tag: "return",  h0: Prelude_Left(null, null, "module path doesn't match directory") }; } break; case "Lin": return { tag: "return",  h0: Prelude_Right(null, null, Prelude_joinBy("/", Prelude__$3C$3E$3E_(null, arg.h3, Prelude_Nil(null)))) }; } };
const Data_List1_splitFileName = ( _$$0 ) => { const sc$$1 = Data_List1_split1(_$$0, "."); switch (sc$$1.h2.tag) { case "Nil": return Prelude__$2C_(null, null, sc$$1.h1, ""); default: return Prelude_mapFst(null, null, null, null, Prelude_Prelude_Bifunctor$20Prelude__$D7_, ( eta ) => (Prelude_joinBy(".", eta)), Data_List1_unsnoc(null, sc$$1)); } };
const Prelude_MkBifunctor = ( h0, h1 ) => ({ tag: "MkBifunctor",  h0: h0,  h1: h1 });
const Prelude_Prelude_Bifunctor$20Prelude__$D7_ = Prelude_MkBifunctor(null, ( a ) => (( b ) => (( c ) => (( d ) => (( eta ) => (( eta1 ) => (( eta2 ) => (Prelude_Prelude_Bifunctor$20Prelude__$D7_$2Cbimap(null, null, null, null, eta, eta1, eta2)))))))));
const Prelude_mapFst = ( a$$0, b$$1, c$$2, f$$3, _$$4, _$$5, _$$6 ) => (Prelude_bimap(null, _$$4)(null)(null)(null)(null)(_$$5)(( _$$1 ) => (_$$1))(_$$6));
const Prelude_bimap = ( f$$0, _$$1 ) => (( a ) => (( b ) => (( c ) => (( d ) => (_$$1.h1(null)(null)(null)(null))))));
const Main_cmdLine = ( _$$0 ) => (bouncer(Main_REC_cmdLine, { tag: "Main.cmdLine",  h0: _$$0 }));
const Main_REC_cmdLine = ( arg ) => { switch (arg.h0.tag) { case "_::_": switch (arg.h0.h1) { case "--top": return { tag: "Main.cmdLine",  h0: arg.h0.h2 }; case "-v": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_getTop, ( tc ) => (Lib_Types_putTop(Lib_Types_MkTop(tc.h0, tc.h1, tc.h2, tc.h3, tc.h4, tc.h5, (1) + (tc.h6), tc.h7, tc.h8)))), ( _ ) => (Main_cmdLine(arg.h0.h2))) }; case "-o": switch (arg.h0.h2.tag) { case "_::_": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_cmdLine(arg.h0.h2.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Prelude_Prelude_Alternative$20Prelude_Maybe$2C_$3C$7C$3E_(null, $$sc.h2, Prelude_Just(null, arg.h0.h2.h1)), $$sc.h3)))) }; default: { const sc$$4 = Prelude_isSuffixOf(".newt", arg.h0.h1); switch (sc$$4) { case "True": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_cmdLine(arg.h0.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, $$sc.h2, Prelude__$3A$3A_(null, arg.h0.h1, $$sc.h3))))) }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("Bad argument ") + (arg.h0.h1)) + (""))), eta)))) }; } break; } } break; default: { const sc$$4 = Prelude_isSuffixOf(".newt", arg.h0.h1); switch (sc$$4) { case "True": return { tag: "return",  h0: Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_cmdLine(arg.h0.h2), ( $$sc ) => (Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, $$sc.h2, Prelude__$3A$3A_(null, arg.h0.h1, $$sc.h3))))) }; default: return { tag: "return",  h0: Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, (("Bad argument ") + (arg.h0.h1)) + (""))), eta)))) }; } break; } } break; case "Nil": return { tag: "return",  h0: Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, Prelude__$2C_(null, null, Prelude_Nothing(null), Prelude_Nil(null))) }; } };
const Prelude_isSuffixOf = (pfx, s) => s.endsWith(pfx) ? Prelude_True : Prelude_False;
const Node_getArgs = (w) => Prelude_MkIORes(null, Prelude_arrayToList(null, process.argv.slice(1)), w);
const Main_main$27 = Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Node_getArgs), ( $$sc ) => { switch ($$sc.tag) { case "_::_": return Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_cmdLine($$sc.h2), ( $$sc1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_Prelude_Traversable$20Prelude_List$2Ctraverse(null, null, null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Main_processFile, $$sc1.h3), ( _ ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Prelude_when(null, Lib_Types_Prelude_Applicative$20Lib_Types_M, Prelude_elem(null, Prelude_Prelude_Eq$20Prim_String, "--top", $$sc.h2), ( _1 ) => (Lib_Types_Prelude_Monad$20Lib_Types_M$2Cbind(null, null, Main_jsonTopContext, ( json ) => (Lib_Types_Prelude_HasIO$20Lib_Types_M$2CliftIO(null, Prelude_primPutStrLn((("TOP:") + (Lib_Common_renderJson(json))) + (""))))))), ( _1 ) => { switch ($$sc1.h2.tag) { case "Nothing": return Lib_Types_Prelude_Applicative$20Lib_Types_M$2Creturn(null, "MkUnit"); case "Just": return Main_writeSource($$sc1.h2.h1); } }))))); default: return Lib_Types_MkM(null, ( _ ) => (( eta ) => (Prelude_MkIORes(null, Prelude_Left(null, null, Lib_Common_E(Lib_Common_emptyFC, "error reading args")), eta)))); } });
const Lib_TopContext_emptyTop = ((  ) => { const mcctx = Lib_Types_MC(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), 0, "CheckAll"); return ( io ) => (( _ ) => (( _1 ) => (Prelude_bind(null, _)(null)(null)(Prelude_liftIO(null, _1)(null)(Data_IORef_primNewIORef(null, Prelude_Nil(null))))(( errs ) => (Prelude_pure(null, _)(null)(Lib_Types_MkTop(Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20$28Prelude_List$20BND$3A1$29$2Ccompare(null, Prelude_Prelude_Ord$20Prim_String, eta, eta1)))), Prelude_Nil(null), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), Prelude_Nil(null), Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Lib_Common_Prelude_Ord$20Lib_Common_QName$2Ccompare(eta, eta1)))), mcctx, 0, errs, Data_SortedMap_EmptyMap(null, null, ( eta ) => (( eta1 ) => (Prelude_Prelude_Ord$20Prim_String$2Ccompare(eta, eta1))))))))))); })();
const Main_main = ( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, Lib_TopContext_emptyTop(null)(Prelude_Prelude_Monad$20Prelude_IO)(Prelude_Prelude_HasIO$20Prelude_IO), ( ctx ) => (( eta ) => (Prelude_Prelude_Monad$20Prelude_IO$2Cbind(null, null, Lib_Types__runM(null, Main_main$27)(ctx), ( $$sc ) => { switch ($$sc.tag) { case "Right": return Prelude_primPutStrLn("done"); case "Left": return Node_exitFailure(null, (((("ERROR at ") + (Lib_Common_Prelude_Show$20Lib_Common_FC$2Cshow(Lib_Types_Lib_Common_HasFC$20Lib_Common_Error$2CgetFC($$sc.h2)))) + (": ")) + (Lib_Types_errorMsg($$sc.h2))) + ("")); } }, eta))), eta));
Main_main();