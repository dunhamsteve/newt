module Main

import Prelude
import Data.List1
import Data.SortedMap
import Lib.Common
import Lib.Compile
import Lib.Parser
import Lib.Elab
import Lib.Util
import Lib.Parser.Impl
import Lib.Prettier
import Lib.ProcessDecl
import Lib.ProcessModule
import Lib.Tokenizer
import Lib.TopContext
import Lib.Types
import Lib.Syntax
import Lib.ReplParser
import Node
import Revision

dirFileSource : String → FileSource
dirFileSource base = MkFileSource $ \fc fn => do
        let fn = base ++ "/" ++ fn
        (Right src) <- liftIO {M} $ readFile fn
            | Left err => throwError $ E fc "error reading \{fn}: \{show err}"
        pure (fn,src)

-- For editors, dump some information about the context (fc, name, type)
jsonTopContext : M Json
jsonTopContext = do
  top <- getTop
  let defs = join $ map (\mod => listValues mod.modDefs) $ listValues top.modules
  pure $ JsonObj (("context", JsonArray (map jsonDef $ defs)) :: Nil)
  where
    jsonDef : TopEntry -> Json
    -- There is no FC here...
    jsonDef (MkEntry fc (QN ns name) type def _) = JsonObj
      (  ("fc", toJson fc)
      :: ("name", toJson name)
      :: ("type", toJson (render 80 $ pprint Nil type) )
      :: Nil)

writeSource : String -> M Unit
writeSource fn = do
  docs <- compile
  let src = unlines $
        ( "\"use strict\";"
        :: "const bouncer = (f,ini) => { let obj = ini; while (obj.tag) obj = f(obj); return obj.h0 };"
        :: Nil)
        ++ map (render 90 ∘ noAlt) docs
  (Right _) <- liftIO {M} $ writeFile fn src
    | Left err => throwError $ E (MkFC fn $ MkBounds 0 0 0 0) err
  pure MkUnit

-- unwind the module part of the path name
baseDir : SnocList String -> SnocList String -> Either String String
baseDir dirs Lin = Right $ joinBy "/" (dirs <>> Nil)
baseDir (dirs :< d) (ns :< n) = if d == n
  then baseDir dirs ns
  else Left "module path doesn't match directory"
baseDir Lin _ = Left "module path doesn't match directory"

showErrors : String -> String -> M Unit
showErrors fn src = do
  top <- getTop
  -- TODO {M} needed to sort out scrutinee
  let (Nil) = top.errors
    | errors => do
        traverse (putStrLn ∘ showError src) errors
        throwError $ E (MkFC fn $ MkBounds 0 0 0 0) "Compile failed"
  pure MkUnit



-- processFile called on the top level file
-- it sets up everything and then recurses into processModule
processFile : String -> M Unit
processFile fn = do
  putStrLn "*** Process \{fn}"
  let parts = split1 fn "/"
  let (dirs,file) = unsnoc parts
  let dir = if dirs == Nil then "." else joinBy "/" dirs
  let (name, ext) = splitFileName file
  log 1 $ \ _ => "\{show dir} \{show name} \{show ext}"

  (Right src) <- liftIO {M} $ readFile fn
    | Left err => error (emptyFC' fn) "error reading \{fn}: \{show err}"
  let (Right toks) = tokenise fn src
    | Left err => throwError err
  let (Right ((nameFC, modName), _, _)) = partialParse fn parseModHeader emptyMap toks
    | Left (err,toks) => throwError err

  let modns = split modName "."
  base <- getBaseDir fn nameFC modns
  addPrimitives

  invalidateModule modns
  let repo = dirFileSource base
  mod <- processModule emptyFC repo Nil modns
  top <- getTop

  showErrors fn mod.modSource
  pure MkUnit

cmdLine : List String -> M (Maybe String × List String)
cmdLine Nil = pure (Nothing, Nil)
cmdLine ("--top" :: args) = cmdLine args -- handled later
cmdLine ("-v" :: args) = do
  modifyTop [ verbose $= _+_ 1 ]
  cmdLine args
cmdLine ("-o" :: fn :: args) = do
  (out, files) <- cmdLine args
  pure ((out <|> Just fn), files)

cmdLine (fn :: args) = do
  let (True) = isSuffixOf ".newt" fn
    | _ => error emptyFC "Bad argument \{show fn}"
  (out, files) <- cmdLine args
  pure (out, fn :: files)

browseTop : QName → M Unit
browseTop qn@(QN ns x) = do
  top <- getTop
  let ns = snoc ns x
  let (Just mod) = lookupMap' ns top.modules
    | _ => putStrLn "module \{show qn} not loaded"
  go $ listValues mod.modDefs
  where
    go : List TopEntry → M Unit
    go Nil = pure MkUnit
    go (e :: es) = do
      putStrLn "\{show e.fc} \{show e.name} : \{rpprint Nil e.type}"
      go es

replHeader : M Unit
replHeader = putStrLn "Newt REPL (\{show gitRevision})\n"

getDoc : String → M Unit
getDoc name = do
  top <- getTop
  for_ (lookupAll name top) $ \e =>
      putStrLn "\{show e.name} : \{rpprint Nil e.type}"

replHelp : M Unit
replHelp =
  for_ commands $ \cmd => do
    let args = case cmd of
      MkCmd _ _ ArgNone _ => ""
      MkCmd _ _ ArgQName _ => " Lib.Types"
      MkCmd _ _ ArgOptInt _ => " [ 1 ]"
      MkCmd _ _ ArgIdent _ => " map"
      MkCmd _ _ ArgString _ => " \"name\""
    case cmd of
      (MkCmd kw desc _ _) => putStrLn "\{kw}\{args} - \{desc}"

runCommand : ReplCommand → M Unit
runCommand (Load fn) = processFile fn
runCommand (HelpCmd) = replHelp
runCommand (BrowseCmd qn) = browseTop qn
runCommand (GetDoc name) = getDoc name
runCommand (Verbose Nothing) = modifyTop [ verbose $= _+_ 1 ]
runCommand (Verbose (Just v)) = modifyTop [ verbose := v ]
runCommand (OutputJS fn) = writeSource fn
runCommand DumpTop = do
  json <- jsonTopContext
  putStrLn "TOP:\{renderJson json}"

-- Broken out to a separate function so I can hook it.
runString : String → M Unit
runString line = do
  let (Right toks) = tokenise "<stdin>" line
    | Left err => putStrLn (showError line err)
  let (Right cmd) = parse "<stdin>" parseCommand toks
    | Left err => putStrLn (showError line err)
  catchError (runCommand cmd) (\ err => putStrLn $ showError line err)

runRepl : M Unit
runRepl = do
  liftIO $ putStr "> "
  Right line <- liftIO {M} $ readLine
    | Left err => pure MkUnit
  runString line
  runRepl

-- TODO translate args into REPL commands?
main' : M Unit
main' = do
  (arg0 :: args) <- liftIO {M} $ getArgs
    | _ => error emptyFC "error reading args"
  -- run REPL if there are no args
  let (_ :: _) = args
        | _ => do
            replHeader
            runRepl
  (out, files) <- cmdLine args

  traverse processFile files

  when (elem "--top" args) $ \ _ => do
    json <- jsonTopContext
    putStrLn "TOP:\{renderJson json}"

  case out of
    Nothing => pure MkUnit
    Just name => writeSource name

main : IO Unit
main = do
  (Right _)  <- .runM main' emptyTop
    | Left err => exitFailure "ERROR at \{show $ getFC err}: \{errorMsg err}"
  putStrLn "done"
