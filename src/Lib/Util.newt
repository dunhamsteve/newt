module Lib.Util

import Prelude
import Lib.Common
import Lib.Types
import Data.List1

-- pi arity is primitive functions
piArity : Tm -> Nat
piArity (Pi _ _ _ quant _ b) = S (piArity b)
piArity _ = Z

funArgs : Tm -> (Tm × List Tm)
funArgs tm = go tm Nil
  where
    go : Tm -> List Tm -> (Tm × List Tm)
    go (App _ t u) args = go t (u :: args)
    go t args = (t, args)

data Binder : U where
  MkBinder : FC -> String -> Icit -> Quant -> Tm -> Binder

-- I don't have a show for terms without a name list

instance Show Binder where
  show (MkBinder _ nm icit quant t) = "[\{show quant}\{nm} \{show icit} : ...]"

splitTele : Tm -> (Tm × List Binder)
splitTele = go Nil
  where
    go : List Binder -> Tm -> (Tm × List Binder)
    go ts (Pi fc nm icit quant t u) = go (MkBinder fc nm icit quant t :: ts) u
    go ts tm = (tm, reverse ts)

-- given a filename and split module name, return the base path or an error
getBaseDir : String → FC → List String → M String
getBaseDir fn fc modName = do
  let path = fst $ splitFileName fn
  let dirs = split path "/"
  let (Right base) = baseDir (Lin <>< dirs) (Lin <>< modName)
    | Left err => error fc err
  let base = if base == "" then "." else base
  pure base
  where
    baseDir : SnocList String -> SnocList String -> Either String String
    baseDir dirs Lin = Right $ joinBy "/" (dirs <>> Nil)
    baseDir (dirs :< d) (ns :< n) = if d == n
      then baseDir dirs ns
      else Left "module name \{joinBy "." modName} doesn't match path \{fn}"
    baseDir Lin _ = Left "module name \{joinBy "." modName} doesn't match path \{fn}"

