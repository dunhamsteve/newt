module Lib.ProcessModule

import Prelude
import Serialize
import Lib.Types
import Lib.Common
import Lib.Syntax
import Lib.ProcessDecl
import Lib.TopContext
import Lib.Tokenizer
import Data.SortedMap
import Lib.Parser.Impl
import Lib.Parser
import Data.List1
import Lib.Elab

-- declare internal primitives
addPrimitives : M Unit
addPrimitives = do
  processDecl primNS (PType emptyFC "Int" Nothing)
  processDecl primNS (PType emptyFC "String" Nothing)
  processDecl primNS (PType emptyFC "Char" Nothing)
  setDef (QN primNS "PiType") emptyFC (Erased emptyFC) (PrimFn "(h0, h1) => ({ tag: \"PiType\", h0, h1 });" (S (S Z)) Nil) Nil


record FileSource where
  getFile : FC → String → M (String × String)

parseDecls : String → Operators → TokenList → SnocList Decl → M (List Decl × Operators)
parseDecls fn ops Nil acc = pure (acc <>> Nil, ops)
parseDecls fn ops toks@(first :: _) acc =
  case partialParse fn (sameLevel parseDecl) ops toks of
    Left (err, toks) => do
      putStrLn $ showError "" err
      addError err
      parseDecls fn ops (recover toks) acc
    Right (decl,ops,toks) => parseDecls fn ops toks (acc :< decl)
  where
    recover : TokenList → TokenList
    recover Nil = Nil
    -- skip to top token, but make sure there is progress
    recover (tok :: toks) = if tok.bounds.startCol == 0 && tok.bounds /= first.bounds
      then (tok :: toks)
      else recover toks

moduleHash : String → List (List String) → M String
moduleHash src imports = do
  srcHash <- liftIO $ checksum src
  top <- getTop
  let mods = mapMaybe (\x => lookupMap' x top.modules) imports
  let modHashes = map (\x => x.csum) mods
  liftIO $ checksum $ fastConcat $ srcHash :: modHashes

importToName : Import → List String
importToName  (MkImport fc (_,name)) = split name "."

importHints : List TopEntry → M Unit
importHints Nil = pure MkUnit
importHints (entry :: entries) = do
  when (elem Hint entry.eflags) $ \ _ => addHint entry.name
  importHints entries

processModule : FC → FileSource → List String → List String → M String
processModule importFC repo stk modns = do
  top <- getTop
  -- let modns = (snoc ns nm)
  let name = joinBy "." modns
  let (Nothing) = lookupMap modns top.modules | _ => pure ""
  -- dummy entry for processing
  modifyTop [modules := updateMap modns (emptyModCtx "") top.modules]

  let fn = joinBy "/" modns ++ ".newt"
  -- TODO now we can pass in the module name...
  (fn,src) <- repo.getFile importFC fn
  let (Right toks) = tokenise fn src
    | Left err => throwError err

  let (Right ((nameFC, modName), ops, toks)) = partialParse fn parseModHeader top.ops toks
    | Left (err, toks) => throwError err

  log 1 $ \ _ => "scan imports for module \{modName}"
  let (True) = modns == split modName "."
    | _ => throwError $ E nameFC "module name \{show modName} doesn't match file name \{show fn}"

  let (Right (imports, ops, toks)) = partialParse fn parseImports ops toks
    | Left (err, toks) => throwError err

  let importNames = map importToName imports

  imported <- for imports $ \case
    MkImport fc (nameFC,name') => do
      let imp = split name' "."
      when (elem name' stk) $ \ _ => error nameFC "import loop \{show name} → \{show name'}"
      processModule nameFC repo (name :: stk) imp
      pure $ imp
  let imported = snoc imported primNS
  srcSum <- liftIO $ checksum src
  csum <- moduleHash srcSum imported

  putStrLn "module \{modName}"
  top <- getTop
  -- TODO we need a flag on this so `make newt3.js` properly tests self-compile
  (Nothing) <- loadModule modns csum
    | Just mod => do
      let modules = updateMap modns mod top.modules

      -- FIXME - we don't want stray operators in a module.
      -- inject module ops into top
      let ops = foldMap const top.ops $ toList mod.ctxOps
      modifyTop [modules := modules; ops := ops ]
      pure src  -- why am I returning this?

  log 1 $ \ _ => "MODNS " ++ show modns
  top <- getTop
  (decls, ops) <- parseDecls fn top.ops toks Lin

  top <- getTop
  let freshMC = MC emptyMap Nil 0 CheckAll
  -- set imported, mod, freshMC, ops  before processing
  modifyTop [ imported := imported
            ; hints := emptyMap
            ; ns := modns
            ; defs := emptyMap
            ; metaCtx := freshMC
            ; ops := ops
            ]
  for imported $ \ ns => do
    let (Just mod) = lookupMap' ns top.modules | _ => error emptyFC "namespace \{show ns} missing"
    importHints (listValues mod.modDefs)

  log 1 $ \ _ => "process Decls"
  traverse (tryProcessDecl src modns) (collectDecl decls)

  -- update modules with result, leave the rest of context in case this is top file
  top <- getTop

  let mod = MkModCtx csum top.defs top.metaCtx top.ops importNames
  if stk /= Nil && length' top.errors == 0
    then dumpModule modns src mod
    else pure MkUnit

  let modules = updateMap modns mod top.modules
  modifyTop [modules := modules]

  logMetas $ reverse $ listValues top.metaCtx.metas
  let (Nil) = top.errors
    | errors => throwError $ E importFC "Failed to compile module \{joinBy "." modns}"
  pure src
  where
    tryProcessDecl : String → List String → Decl → M Unit
    tryProcessDecl src ns decl = do
      (Left err) <- tryError $ processDecl ns decl | _ => pure MkUnit
      putStrLn $ showError src err
      addError err
