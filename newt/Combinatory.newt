module Combinatory

data Unit : U where
  MkUnit : Unit

infixr 7 _::_
data List : U -> U where
  Nil : {A : U} -> List A
  _::_ : {A : U} -> A -> List A -> List A

-- prj/menagerie/papers/combinatory

infixr 6 _~>_
data Type : U where
  ι : Type
  _~>_ : Type -> Type -> Type

A : U
A = Unit

Val : Type -> U
Val ι = A
Val (x ~> y) = Val x -> Val y

Ctx : U
Ctx = List Type

data Ref : Type -> Ctx -> U where
  Here : {σ : Type} {Γ : Ctx} -> Ref σ (σ :: Γ)
  There : {σ τ : Type} {Γ : Ctx} -> Ref σ Γ -> Ref σ (τ :: Γ)

data Term : Ctx -> Type -> U where
  App : {Γ : Ctx} {σ τ : Type} -> Term Γ (σ ~> τ) -> Term Γ σ -> Term Γ τ
  Lam : {Γ : Ctx} {σ τ : Type} -> Term (σ :: Γ) τ -> Term Γ (σ ~> τ)
  Var : {Γ : Ctx} {σ : Type} -> Ref σ Γ → Term Γ σ

-- FIXME, I'm not getting an error for Nil, but it's shadowing Nil
infixr 7 _:::_
data Env : Ctx -> U where
  ENil : Env Nil
  _:::_ : {Γ : Ctx} {σ : Type} → Val σ → Env Γ → Env (σ :: Γ)

-- TODO there is a problem here with coverage checking
-- I suspect something is being split before it's ready

-- lookup : {σ : Type} {Γ : Ctx} → Ref σ Γ → Env Γ → Val σ
-- lookup Z (x ::: y) = x
-- lookup (S i) (x ::: env) = lookup i env


-- lookup2 : {σ : Type} {Γ : Ctx} → Env Γ → Ref σ Γ → Val σ
-- lookup2 (x ::: y) Here = x
-- lookup2 (x ::: env) (There i) = lookup2 env i

-- -- MixFix - this was ⟦_⟧
-- eval : {Γ : Ctx} {σ : Type} → Term Γ σ → (Env Γ → Val σ)
-- eval (App t u) env = ? -- (eval t env) (eval u env)
-- eval (Lam t) env = \ x => ? -- eval t (x ::: env)
-- eval (Var i) env = lookup2 env i

-- something really strange here, the arrow in the goal type is backwards...
foo : {σ τ ξ : Type} → Val (σ ~> (τ ~> ξ))
foo {σ} {τ} {ξ} = ? -- \ x y => x

-- data Comb : (Γ : Ctx) → (u : Type) → (Env Γ → Val u) → U where
--   -- S : {Γ : Ctx} {σ τ τ' : Type} → Comb Γ ((σ ~> τ ~> τ') ~> (σ ~> τ) ~> (σ ~> τ')) (\ env => \ f g x => (f x) (g x))
--   K : {Γ : Ctx} {σ τ : Type} → Comb Γ (σ ~> τ ~> σ) (\ env => \ x => \ y => x)


