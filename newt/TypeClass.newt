module TypeClass

-- experiment on one option for typeclass (we don't have record yet)

-- this would be nicer with records and copatterns

-- At this point, for Agda style, I'll probably need to postpone, or collect constraints
-- at lesat. Idris style, I might get away without short term.

-- So I can read mcbride paper and maybe agda source.



-- we need a bit more than this, but
data Monad : (U -> U) -> U where
  MkMonad : { M : U -> U } ->
            (bind : {A B : U} -> (M A) -> (A -> M B) -> M B) ->
            Monad M

data Maybe : U -> U where
  Just    : {A : U} -> A -> Maybe A
  Nothing : {A : U} -> Maybe A


data Either : U -> U -> U where
  Left : {A B : U} -> A -> Either A B
  Right : {A B : U} -> B -> Either A B

bindEither : {A B C : U} -> (Either A B) -> (B -> Either A C) -> Either A C
bindEither (Left a) amb = Left a
bindEither (Right b) amb = amb b

EitherMonad : {A : U} -> Monad (Either A)
EitherMonad = MkMonad {Either A} bindEither

bindMaybe : {A B : U} -> Maybe A -> (A -> Maybe B) -> Maybe B
bindMaybe Nothing amb = Nothing
bindMaybe (Just a) amb = amb a

-- I think it was picking up the Maybe before I made it less aggressive about eval

MaybeMonad : Monad Maybe
MaybeMonad = MkMonad bindMaybe

-- So the idea here is to have some implicits that are solved by search

-- Error here is from foo, with a bad FC. I think it might be showing up during search.
_>>=_ : {a b : U} -> {m : U -> U} -> {{x : Monad m}} -> (m a) -> (a -> m b) -> m b
_>>=_ {a} {b} {m} {{MkMonad bind'}}  ma amb = bind' {a} {b} ma amb

infixl 1 _>>=_

ptype Int

-- It's bailing on MaybeMonad and picking up Either?

foo : Int -> Maybe Int
foo x = (Just x) >>= (\ x  => Just 10)

-- NOW

-- Older notes below, but this is _close_, we're doing something like agda, and we're getting the right solution
-- It's over-expanded, and there is an unsolved meta that I think the solution would unlock. (Need to collect and
-- retry constraints)

-- *SOLVE meta 6 sp [< (%var 0 [< ]), (%meta 4 [< (%var 0 [< ])])] val (%ref Maybe [< (%meta 9 [< (%var 0 [< ]), (%var 1 [< ])])])

-- Essentially   (m6 v0) (m4 ...) == Maybe Int and (m6 v0) (m2 v0) == Maybe Int

-- Idris gets this by specially treating determining arguments of an auto as "invertible". It then unifies
-- the last arg on each side and tries the rest, which is now in the pattern fragment.

-- Agda may do this slightly differently from Idris:
--    https://agda.readthedocs.io/en/v2.6.0.1/language/instance-arguments.html#instance-resolution

-- I think it searches, pulls in all possibilities and tries to unify them into place.
-- We'll want to extend our example to what I have in Foo2.agda to test that it finds the right
-- one. Maybe look at the source to see if there is any invertible trickery going on?

-- I know that here, if I fill in the instance, everything works out, so finding the instance that works
-- out might be sufficient.  That might mean that a instance constraint is a pile of options that get
-- winnowed down?

-- Putting MaybeMonad in there helps the unification
-- of Maybe Int =?= ?m6 ?m2 (as Monad Maybe (the type) gives ?m6 is Maybe)
-- and MaybeEither would fail after a couple of steps. But it seems expensive/complex
-- to have to run the process down for each candidate.

-- Agda seems complicated, minting fresh metas for bits of potential solutions (which
-- may be tossed if the solution is ruled out.)


--                         ^
/-
So, agda style we'd guess ?m8 is MonadMaybe or MonadEither - agda's "maybe" case

-/
