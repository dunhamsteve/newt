module TypeClass

-- experiment on one option for typeclass (we don't have record yet)

-- this would be nicer with records and copatterns

-- we need a bit more than this, but
data Monad : (U -> U) -> U where
  MkMonad : { M : U -> U } ->
            (bind : {A B : U} -> (M A) -> (A -> M B) -> M B) ->
            Monad M

data Maybe : U -> U where
  Just    : {A : U} -> A -> Maybe A
  Nothing : {A : U} -> Maybe A


-- NEXT trying to get this to work. An equivalence is not found in pattern
-- matching

-- [instance]
MaybeMonad : Monad Maybe
-- Agda case lambda might be nice..
-- The {Maybe} isn't solved in type for the case
MaybeMonad = MkMonad {Maybe} (\ {A} ma amb =>
  case ma of
      Nothing => Nothing
      -- It doesn't discover pat$5 is A during pattern matching
      -- oh, but var 0 value is var5
      Just a => amb a)

-- so if we added {{ }} and search...
-- second arg will be {{}}
-- add implicit patterns first

-- I need a way to tag `x : Monad m` as auto.  I could do {{}}, but maybe I should tag the `data` for search?
-- It should be a record, but I don't have records yet

bind : {m : U -> U} -> {x : Monad m} -> {a b : U} -> (m a) -> (a -> m b) -> m b
bind {m} {MkMonad bind'} = bind'

ptype Int

-- For now, we may try to solve this at creation time, but it's possible postpone is needed

/-

So I think we need to solve meta 7 first, and then if we're lucky, it's var 0 and we're
good to go.

failed to unify ( Maybe ( ?m:9 x:0 ) )
    with ( ( ?m:4 x:0 ) ( ?m:7 x:0 ) )
  non-variable in pattern (%meta 7 [< (%var 0 [< ])])
-/

foo : Int -> Maybe Int
foo x = bind {_} {_} (Just x) (\ x => Just x)
