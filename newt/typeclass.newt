module TypeClass

-- experiment on one option for typeclass (we don't have record yet)

-- this would be nicer with records and copatterns

-- we need a bit more than this, but
data Monad : (U -> U) -> U where
  MkMonad : { M : U -> U } ->
            (bind : {A B : U} -> (M A) -> (A -> M B) -> M B) ->
            Monad M

data Maybe : U -> U where
  Just    : {A : U} -> A -> Maybe A
  Nothing : {A : U} -> Maybe A


-- [instance]
MaybeMonad : Monad Maybe
-- Agda case lambda might be nice..
-- The {Maybe} isn't solved in type for the case
MaybeMonad = MkMonad {Maybe} (\ {A} ma amb =>
  case ma of
      Nothing => Nothing
      -- It doesn't discover pat$5 is A during pattern matching
      -- oh, but var 0 value is var5
      Just a => amb a)

-- So the idea here is to have some implicits that are solved by search

_>>=_ : {a b : U} -> {m : U -> U} -> {x : Monad m} -> (m a) -> (a -> m b) -> m b
_>>=_ {a} {b} {m} {MkMonad bind'}  ma amb = bind' {a} {b} ma amb

infixl 1 _>>=_

ptype Int

-- For now, we may try to solve this at creation time, but it's possible postpone is needed

-- *SOLVE meta 6 sp [< (%var 0 [< ]), (%meta 4 [< (%var 0 [< ])])] val (%ref Maybe [< (%meta 9 [< (%var 0 [< ]), (%var 1 [< ])])])

-- Essentially   (m6 v0) (m4 ...) == Maybe Int and (m6 v0) (m2 v0) == Maybe Int

-- Idris gets this by specially treating determining arguments of an auto as "invertible". It then unifies
-- the last arg on each side and tries the rest, which is now in the pattern fragment.

foo : Int -> Maybe Int
foo x = _>>=_ (Just x) (\ x  => Just 10)
