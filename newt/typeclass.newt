module TypeClass

-- experiment on one option for typeclass (we don't have record yet)

-- this would be nicer with records and copatterns

-- we need a bit more than this, but
data Monad : (U -> U) -> U where
  MkMonad : { M : U -> U } ->
            (bind : {A B : U} -> (M A) -> (A -> M B) -> M B) ->
            Monad M

data Maybe : U -> U where
  Just    : {A : U} -> A -> Maybe A
  Nothing : {A : U} -> Maybe A


-- NEXT trying to get this to work. An equivalence is not found in pattern
-- matching

-- [instance]
MaybeMonad : Monad Maybe
-- Agda case lambda might be nice..
-- The {Maybe} isn't solved in type for the case
MaybeMonad = MkMonad {Maybe} (\ {A} ma amb =>
  case ma of
      Nothing => Nothing
      -- It doesn't discover pat$5 is A during pattern matching
      -- oh, but var 0 value is var5
      Just a => amb a)

-- so if we added {{ }} and search...
-- second arg will be {{}}
-- add implicit patterns first

-- I need a way to tag `x : Monad m` as auto.  I could do {{}}, but maybe I should tag the `data` for search?
-- It should be a record, but I don't have records yet

bind : {m : U -> U} -> {x : Monad m} -> {a b : U} -> (m a) -> (a -> m b) -> m b
bind {m} {MkMonad bind'} = bind'

ptype Int

-- For now, we may try to solve this at creation time, but it's possible postpone is needed

/-

So I think we need to solve meta 7 first, and then if we're lucky, it's var 0 and we're
good to go.

  foo x = bind {_} {_} {_} (Just x) (\ x => Just x)
  failed to unify ( Maybe ( ?m:10 x:0 ) )
    with ( ( ?m:4 x:0 ) ( ?m:8 x:0 ) )
  non-variable in pattern (%meta 8 [< (%var 0 [< ])])

  If I stick Int in third slot:
  foo x = bind {_} {_} {Int} (Just x) (\ x => Just x)
                                    ^
  failed to unify ( Maybe ( ?m:8 x:0 ) )
    with ( ( ?m:4 x:0 ) Int )
  non-variable in pattern (%ref Int [< ])

  -- If I slot in MaybeMonad, all is happy.
  foo x = bind {_} {MaybeMonad} {_} (Just x) (\ x => Just x)

  -- And a maybe up front has only the auto unsolved.

-/

foo : Int -> Maybe Int
foo x = bind {Maybe} {_} {_} (Just x) (\ x => Just x)
